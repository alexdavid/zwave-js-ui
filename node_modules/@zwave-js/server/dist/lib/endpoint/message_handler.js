"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EndpointMessageHandler = void 0;
const error_1 = require("../error");
const state_1 = require("../state");
const command_1 = require("./command");
const common_1 = require("../common");
const isBufferObject = (obj) => {
    return (obj instanceof Object &&
        Object.keys(obj).length === 2 &&
        "type" in obj &&
        obj.type === "Buffer" &&
        "data" in obj &&
        Array.isArray(obj.data));
};
const deserializeBufferInArray = (array) => {
    // Iterate over all items in array and deserialize any Buffer objects
    for (var idx = 0; idx < array.length; idx++) {
        const value = array[idx];
        if (isBufferObject(value)) {
            array[idx] = Buffer.from(value.data);
        }
    }
    return array;
};
class EndpointMessageHandler {
    static async handle(message, driver, client) {
        const { nodeId, command } = message;
        let endpoint;
        const node = driver.controller.nodes.get(nodeId);
        if (!node) {
            throw new error_1.NodeNotFoundError(nodeId);
        }
        if (message.endpoint) {
            endpoint = node.getEndpoint(message.endpoint);
            if (!endpoint) {
                throw new error_1.EndpointNotFoundError(nodeId, message.endpoint);
            }
        }
        else {
            endpoint = node;
        }
        switch (message.command) {
            case command_1.EndpointCommand.invokeCCAPI: {
                const response = await endpoint.invokeCCAPI(message.commandClass, message.methodName, ...deserializeBufferInArray(message.args));
                return { response };
            }
            case command_1.EndpointCommand.supportsCCAPI: {
                const supported = endpoint.supportsCCAPI(message.commandClass);
                return { supported };
            }
            case command_1.EndpointCommand.supportsCC: {
                const supported = endpoint.supportsCC(message.commandClass);
                return { supported };
            }
            case command_1.EndpointCommand.controlsCC: {
                const controlled = endpoint.controlsCC(message.commandClass);
                return { controlled };
            }
            case command_1.EndpointCommand.isCCSecure: {
                const secure = endpoint.isCCSecure(message.commandClass);
                return { secure };
            }
            case command_1.EndpointCommand.getCCVersion: {
                const version = endpoint.getCCVersion(message.commandClass);
                return { version };
            }
            case command_1.EndpointCommand.getNodeUnsafe: {
                const node = endpoint.getNodeUnsafe();
                return {
                    node: node === undefined ? node : (0, state_1.dumpNode)(node, client.schemaVersion),
                };
            }
            case command_1.EndpointCommand.setRawConfigParameterValue: {
                return (0, common_1.setRawConfigParameterValue)(message, endpoint);
            }
            default: {
                throw new error_1.UnknownCommandError(command);
            }
        }
    }
}
exports.EndpointMessageHandler = EndpointMessageHandler;
