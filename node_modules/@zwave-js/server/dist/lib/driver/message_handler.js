"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DriverMessageHandler = void 0;
const error_1 = require("../error");
const command_1 = require("./command");
const state_1 = require("../state");
class DriverMessageHandler {
    static async handle(message, remoteController, clientsController, logger, driver, client) {
        const { command } = message;
        switch (message.command) {
            case command_1.DriverCommand.getConfig: {
                const config = (0, state_1.dumpDriver)(driver, client.schemaVersion);
                return { config };
            }
            case command_1.DriverCommand.disableStatistics: {
                driver.disableStatistics();
                return {};
            }
            case command_1.DriverCommand.enableStatistics: {
                driver.enableStatistics({
                    applicationName: message.applicationName,
                    applicationVersion: message.applicationVersion,
                });
                return {};
            }
            case command_1.DriverCommand.getLogConfig: {
                const config = (0, state_1.dumpLogConfig)(driver, client.schemaVersion);
                return { config };
            }
            case command_1.DriverCommand.updateLogConfig: {
                driver.updateLogConfig(message.config);
                // If the logging event forwarder is enabled, we need to restart
                // it so that it picks up the new config.
                clientsController.restartLoggingEventForwarderIfNeeded();
                clientsController.clients.forEach((cl) => {
                    cl.sendEvent({
                        source: "driver",
                        event: "log config updated",
                        config: (0, state_1.dumpLogConfig)(driver, cl.schemaVersion),
                    });
                });
                return {};
            }
            case command_1.DriverCommand.isStatisticsEnabled: {
                const statisticsEnabled = driver.statisticsEnabled;
                return { statisticsEnabled };
            }
            case command_1.DriverCommand.startListeningLogs: {
                client.receiveLogs = true;
                clientsController.configureLoggingEventForwarder(message.filter);
                return {};
            }
            case command_1.DriverCommand.stopListeningLogs: {
                client.receiveLogs = false;
                clientsController.cleanupLoggingEventForwarder();
                return {};
            }
            case command_1.DriverCommand.checkForConfigUpdates: {
                const installedVersion = driver.configVersion;
                const newVersion = await driver.checkForConfigUpdates();
                const updateAvailable = newVersion !== undefined;
                return { installedVersion, updateAvailable, newVersion };
            }
            case command_1.DriverCommand.installConfigUpdate: {
                const success = await driver.installConfigUpdate();
                return { success };
            }
            case command_1.DriverCommand.setPreferredScales: {
                driver.setPreferredScales(message.scales);
                return {};
            }
            case command_1.DriverCommand.enableErrorReporting: {
                // This capability no longer exists but we keep the command here for backwards
                // compatibility.
                logger.warn("Z-Wave JS no longer supports enabling error reporting. If you are using " +
                    "an application that integrates with Z-Wave JS and you receive this " +
                    "error, you may need to update the application.");
                return {};
            }
            case command_1.DriverCommand.softReset: {
                await driver.softReset();
                return {};
            }
            case command_1.DriverCommand.trySoftReset: {
                await driver.trySoftReset();
                return {};
            }
            case command_1.DriverCommand.hardReset: {
                setTimeout(() => remoteController.hardResetController(), 1);
                return {};
            }
            case command_1.DriverCommand.shutdown: {
                const success = await driver.shutdown();
                return { success };
            }
            case command_1.DriverCommand.updateOptions: {
                driver.updateOptions(message.options);
                return {};
            }
            default: {
                throw new error_1.UnknownCommandError(command);
            }
        }
    }
}
exports.DriverMessageHandler = DriverMessageHandler;
