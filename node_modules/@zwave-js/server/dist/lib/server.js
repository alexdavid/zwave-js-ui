"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZwavejsServer = exports.ZwavejsServerRemoteController = exports.ClientsController = exports.Client = void 0;
const ws_1 = __importDefault(require("ws"));
const ciao_1 = require("@homebridge/ciao");
const zwave_js_1 = require("zwave-js");
const zwave_js_2 = require("zwave-js");
const forward_1 = require("./forward");
const state_1 = require("./state");
const http_1 = require("http");
const events_1 = require("events");
const const_1 = require("./const");
const message_handler_1 = require("./node/message_handler");
const message_handler_2 = require("./controller/message_handler");
const error_1 = require("./error");
const instance_1 = require("./instance");
const command_1 = require("./command");
const message_handler_3 = require("./driver/message_handler");
const logging_1 = require("./logging");
const message_handler_4 = require("./broadcast_node/message_handler");
const message_handler_5 = require("./multicast_group/message_handler");
const message_handler_6 = require("./endpoint/message_handler");
const message_handler_7 = require("./utils/message_handler");
const inclusion_user_callbacks_1 = require("./inclusion_user_callbacks");
class Client {
    socket;
    clientsController;
    driver;
    logger;
    remoteController;
    receiveEvents = false;
    _outstandingPing = false;
    schemaVersion = const_1.minSchemaVersion;
    receiveLogs = false;
    additionalUserAgentComponents;
    instanceHandlers = {
        [instance_1.Instance.controller]: (message) => message_handler_2.ControllerMessageHandler.handle(message, this.clientsController, this.driver, this),
        [instance_1.Instance.driver]: (message) => message_handler_3.DriverMessageHandler.handle(message, this.remoteController, this.clientsController, this.logger, this.driver, this),
        [instance_1.Instance.node]: (message) => this.clientsController.nodeMessageHandler.handle(message, this.clientsController, this.driver, this),
        [instance_1.Instance.multicast_group]: (message) => message_handler_5.MulticastGroupMessageHandler.handle(message, this.driver, this),
        [instance_1.Instance.broadcast_node]: (message) => message_handler_4.BroadcastNodeMessageHandler.handle(message, this.driver, this),
        [instance_1.Instance.endpoint]: (message) => message_handler_6.EndpointMessageHandler.handle(message, this.driver, this),
        [instance_1.Instance.utils]: (message) => message_handler_7.UtilsMessageHandler.handle(message),
    };
    constructor(socket, clientsController, driver, logger, remoteController) {
        this.socket = socket;
        this.clientsController = clientsController;
        this.driver = driver;
        this.logger = logger;
        this.remoteController = remoteController;
        socket.on("pong", () => {
            this._outstandingPing = false;
        });
        socket.on("message", (data) => this.receiveMessage(data));
    }
    get isConnected() {
        return this.socket.readyState === this.socket.OPEN;
    }
    setSchemaVersion(schemaVersion) {
        // Handle schema version
        this.schemaVersion = schemaVersion;
        if (this.schemaVersion < const_1.minSchemaVersion ||
            this.schemaVersion > const_1.maxSchemaVersion) {
            throw new error_1.SchemaIncompatibleError(this.schemaVersion);
        }
    }
    async receiveMessage(data) {
        let msg;
        try {
            msg = JSON.parse(data);
        }
        catch (err) {
            // We don't have the message ID. Just close it.
            this.logger.debug(`Unable to parse data: ${data}`);
            this.socket.close();
            return;
        }
        try {
            if (msg.command === command_1.ServerCommand.initialize) {
                this.setSchemaVersion(msg.schemaVersion);
                this.additionalUserAgentComponents = msg.additionalUserAgentComponents;
                this.sendResultSuccess(msg.messageId, {});
                return;
            }
            if (msg.command === command_1.ServerCommand.setApiSchema) {
                this.setSchemaVersion(msg.schemaVersion);
                this.sendResultSuccess(msg.messageId, {});
                return;
            }
            if (msg.command === command_1.ServerCommand.startListening) {
                this.sendResultSuccess(msg.messageId, {
                    state: (0, state_1.dumpState)(this.driver, this.schemaVersion),
                }, true);
                this.receiveEvents = true;
                return;
            }
            if (msg.command === command_1.ServerCommand.updateLogConfig) {
                this.driver.updateLogConfig(msg.config);
                this.sendResultSuccess(msg.messageId, {});
                return;
            }
            if (msg.command === command_1.ServerCommand.getLogConfig) {
                this.sendResultSuccess(msg.messageId, {
                    config: (0, state_1.dumpLogConfig)(this.driver, this.schemaVersion),
                });
                return;
            }
            if (msg.command === command_1.ServerCommand.startListeningLogs) {
                this.receiveLogs = true;
                this.clientsController.configureLoggingEventForwarder(msg.filter);
                this.sendResultSuccess(msg.messageId, {});
                return;
            }
            if (msg.command === command_1.ServerCommand.stopListeningLogs) {
                this.receiveLogs = false;
                this.clientsController.cleanupLoggingEventForwarder();
                this.sendResultSuccess(msg.messageId, {});
                return;
            }
            const instance = msg.command.split(".")[0];
            if (this.instanceHandlers[instance]) {
                return this.sendResultSuccess(msg.messageId, await this.instanceHandlers[instance](msg));
            }
            throw new error_1.UnknownCommandError(msg.command);
        }
        catch (err) {
            if (err instanceof error_1.BaseError) {
                this.logger.error("Message error", err);
                const { errorCode, name, message, stack, ...args } = err;
                return this.sendResultError(msg.messageId, errorCode, message, args);
            }
            if (err instanceof zwave_js_1.ZWaveError) {
                this.logger.error("Z-Wave error", err);
                return this.sendResultZWaveError(msg.messageId, err.code, err.message);
            }
            let error;
            if (err instanceof Error) {
                error = err;
            }
            else {
                error = new Error(`${err}`);
            }
            this.logger.error("Unexpected error", error);
            this.sendResultError(msg.messageId, error_1.ErrorCode.unknownError, error.stack ?? error.message, {});
        }
    }
    sendVersion() {
        this.sendData({
            type: "version",
            driverVersion: zwave_js_2.libVersion,
            serverVersion: const_1.version,
            homeId: this.driver.controller.homeId,
            minSchemaVersion: const_1.minSchemaVersion,
            maxSchemaVersion: const_1.maxSchemaVersion,
        });
    }
    sendResultSuccess(messageId, result, compress = false) {
        this.sendData({
            type: "result",
            success: true,
            messageId,
            result,
        }, compress);
    }
    sendResultError(messageId, errorCode, message, args) {
        if (this.schemaVersion <= 31) {
            // `sendResultError` didn't support passing the error message before schema 32.
            // We `sendResultZWaveError` instead so that we can pass the error message in
            // for the client to consume and display.
            this.sendResultZWaveError(messageId, -1, `${errorCode}: ${message}`);
        }
        else {
            this.sendData({
                type: "result",
                success: false,
                messageId,
                errorCode,
                message,
                args,
            });
        }
    }
    sendResultZWaveError(messageId, zjsErrorCode, message) {
        if (this.schemaVersion <= 31) {
            this.sendData({
                type: "result",
                success: false,
                messageId,
                errorCode: error_1.ErrorCode.zwaveError,
                zwaveErrorCode: zjsErrorCode,
                zwaveErrorMessage: message,
            });
        }
        else {
            this.sendData({
                type: "result",
                success: false,
                messageId,
                errorCode: error_1.ErrorCode.zwaveError,
                zwaveErrorCode: zjsErrorCode,
                zwaveErrorCodeName: (0, zwave_js_1.getEnumMemberName)(zwave_js_1.ZWaveErrorCodes, zjsErrorCode),
                zwaveErrorMessage: message,
            });
        }
    }
    sendEvent(event) {
        this.sendData({
            type: "event",
            event,
        });
    }
    sendData(data, compress = false) {
        this.socket.send(JSON.stringify(data), { compress });
    }
    checkAlive() {
        if (this._outstandingPing) {
            this.disconnect();
            return;
        }
        this._outstandingPing = true;
        this.socket.ping();
    }
    disconnect() {
        this.socket.close();
    }
}
exports.Client = Client;
class ClientsController extends events_1.EventEmitter {
    driver;
    logger;
    remoteController;
    clients = [];
    pingInterval;
    eventForwarder;
    cleanupScheduled = false;
    loggingEventForwarder;
    grantSecurityClassesPromise;
    validateDSKAndEnterPinPromise;
    nodeMessageHandler = new message_handler_1.NodeMessageHandler();
    constructor(driver, logger, remoteController) {
        super();
        this.driver = driver;
        this.logger = logger;
        this.remoteController = remoteController;
    }
    addSocket(socket) {
        this.logger.debug("New client");
        const client = new Client(socket, this, this.driver, this.logger, this.remoteController);
        socket.on("error", (error) => {
            this.logger.error("Client socket error", error);
        });
        socket.on("close", (code, reason) => {
            this.logger.info("Client disconnected");
            this.logger.debug(`Code ${code}: ${reason}`);
            this.scheduleClientCleanup();
        });
        client.sendVersion();
        this.clients.push(client);
        if (this.pingInterval === undefined) {
            this.pingInterval = setInterval(() => {
                const newClients = [];
                for (const client of this.clients) {
                    if (client.isConnected) {
                        newClients.push(client);
                    }
                    else {
                        client.disconnect();
                    }
                }
                this.clients = newClients;
            }, 30000);
        }
        if (this.eventForwarder === undefined) {
            this.eventForwarder = new forward_1.EventForwarder(this);
            this.eventForwarder.start();
        }
    }
    get loggingEventForwarderStarted() {
        return this.loggingEventForwarder?.started === true;
    }
    restartLoggingEventForwarderIfNeeded() {
        this.loggingEventForwarder?.restartIfNeeded();
    }
    configureLoggingEventForwarder(filter) {
        if (this.loggingEventForwarder === undefined) {
            this.loggingEventForwarder = new logging_1.LoggingEventForwarder(this, this.driver, this.logger);
        }
        if (!this.loggingEventForwarderStarted) {
            this.loggingEventForwarder?.start(filter);
        }
    }
    cleanupLoggingEventForwarder() {
        if (this.clients.filter((cl) => cl.receiveLogs).length == 0 &&
            this.loggingEventForwarderStarted) {
            this.loggingEventForwarder?.stop();
        }
    }
    scheduleClientCleanup() {
        if (this.cleanupScheduled) {
            return;
        }
        this.cleanupScheduled = true;
        setTimeout(() => this.cleanupClients(), 0);
    }
    cleanupClients() {
        this.cleanupScheduled = false;
        this.clients = this.clients.filter((cl) => cl.isConnected);
        this.cleanupLoggingEventForwarder();
    }
    disconnect() {
        if (this.pingInterval !== undefined) {
            clearInterval(this.pingInterval);
        }
        this.pingInterval = undefined;
        this.clients.forEach((client) => client.disconnect());
        this.clients = [];
        this.cleanupLoggingEventForwarder();
    }
}
exports.ClientsController = ClientsController;
/**
 * This class allows the hard reset driver command to be passed to the
 * ClientsController, Client, and Message Handler instances without
 * providing access to the base server and eventing system.
 */
class ZwavejsServerRemoteController {
    destroyServerOnHardReset;
    driver;
    zwaveJsServer;
    constructor(destroyServerOnHardReset = false, driver, zwaveJsServer) {
        this.destroyServerOnHardReset = destroyServerOnHardReset;
        this.driver = driver;
        this.zwaveJsServer = zwaveJsServer;
    }
    async hardResetController() {
        if (this.destroyServerOnHardReset) {
            await this.zwaveJsServer.destroy();
            this.driver.once("driver ready", () => {
                this.zwaveJsServer.start(true);
            });
        }
        await this.driver.hardReset();
        this.zwaveJsServer.emit("hard reset");
    }
}
exports.ZwavejsServerRemoteController = ZwavejsServerRemoteController;
class ZwavejsServer extends events_1.EventEmitter {
    driver;
    options;
    server;
    wsServer;
    sockets;
    logger;
    defaultPort = 3000;
    defaultHost = "0.0.0.0";
    responder;
    service;
    remoteController;
    constructor(driver, options = {}, destroyServerOnHardReset = false) {
        super();
        this.driver = driver;
        this.options = options;
        this.remoteController = new ZwavejsServerRemoteController(destroyServerOnHardReset, driver, this);
        this.logger = options.logger ?? console;
    }
    async start(shouldSetInclusionUserCallbacks = false) {
        if (!this.driver.ready) {
            throw new Error("Cannot start server when driver not ready");
        }
        this.driver.updateUserAgent({ [const_1.applicationName]: const_1.version });
        this.server = (0, http_1.createServer)();
        this.wsServer = new ws_1.default.Server({
            server: this.server,
            perMessageDeflate: true,
        });
        this.sockets = new ClientsController(this.driver, this.logger, this.remoteController);
        if (shouldSetInclusionUserCallbacks) {
            this.setInclusionUserCallbacks();
        }
        this.wsServer.on("connection", (socket) => this.sockets.addSocket(socket));
        const port = this.options.port || this.defaultPort;
        const host = this.options.host || this.defaultHost;
        const localEndpointString = `${host}:${port}`;
        this.logger.debug(`Starting server on ${localEndpointString}`);
        this.wsServer.on("error", this.onError.bind(this, this.wsServer));
        this.server.on("error", this.onError.bind(this, this.server));
        this.server.listen(port, host);
        await (0, events_1.once)(this.server, "listening");
        this.emit("listening");
        this.logger.info(`ZwaveJS server listening on ${localEndpointString}`);
        if (this.options.enableDNSServiceDiscovery) {
            this.responder = (0, ciao_1.getResponder)();
            this.service = this.responder.createService({
                name: this.driver.controller.homeId.toString(),
                port,
                type: const_1.dnssdServiceType,
                protocol: "tcp" /* Protocol.TCP */,
                txt: {
                    homeId: this.driver.controller.homeId,
                },
            });
            this.service.advertise().then(() => {
                this.logger.info(`DNS Service Discovery enabled`);
            });
        }
    }
    setInclusionUserCallbacks() {
        if (this.sockets === undefined) {
            throw new Error("Server must be started before setting the inclusion user callbacks");
        }
        this.driver.updateOptions({
            inclusionUserCallbacks: (0, inclusion_user_callbacks_1.inclusionUserCallbacks)(this.sockets),
        });
    }
    onError(sourceClass, error) {
        this.emit("error", error, sourceClass);
        this.logger.error(error);
    }
    async destroy() {
        this.logger.debug(`Closing server...`);
        if (this.sockets) {
            this.sockets.disconnect();
            this.sockets.removeAllListeners();
            delete this.sockets;
        }
        if (this.wsServer) {
            this.wsServer.close();
            await (0, events_1.once)(this.wsServer, "close");
            this.wsServer.removeAllListeners();
            delete this.wsServer;
        }
        if (this.server) {
            this.server.close();
            await (0, events_1.once)(this.server, "close");
            this.server.removeAllListeners();
            delete this.server;
        }
        if (this.service) {
            await this.service.end();
            await this.service.destroy();
            this.service.removeAllListeners();
            delete this.service;
        }
        if (this.responder) {
            await this.responder.shutdown();
            delete this.responder;
        }
        this.logger.info(`Server closed`);
    }
}
exports.ZwavejsServer = ZwavejsServer;
