"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeMessageHandler = void 0;
const core_1 = require("@zwave-js/core");
const error_1 = require("../error");
const state_1 = require("../state");
const command_1 = require("./command");
const __1 = require("..");
const common_1 = require("../common");
class NodeMessageHandler {
    async handle(message, clientsController, driver, client) {
        const { nodeId, command } = message;
        const node = driver.controller.nodes.get(nodeId);
        if (!node) {
            throw new error_1.NodeNotFoundError(nodeId);
        }
        switch (message.command) {
            case command_1.NodeCommand.setValue: {
                const result = await node.setValue(message.valueId, message.value, message.options);
                return (0, common_1.setValueOutgoingMessage)(result, client.schemaVersion);
            }
            case command_1.NodeCommand.refreshInfo: {
                await node.refreshInfo(message.options);
                return {};
            }
            case command_1.NodeCommand.getDefinedValueIDs: {
                const valueIds = node.getDefinedValueIDs();
                return { valueIds };
            }
            case command_1.NodeCommand.getValueMetadata: {
                if (message.valueId.commandClass == core_1.CommandClasses.Configuration) {
                    return (0, state_1.dumpConfigurationMetadata)(node.getValueMetadata(message.valueId), client.schemaVersion);
                }
                return (0, state_1.dumpMetadata)(node.getValueMetadata(message.valueId), client.schemaVersion);
            }
            case command_1.NodeCommand.beginFirmwareUpdate: {
                const firmwareFile = Buffer.from(message.firmwareFile, "base64");
                let firmware = (0, core_1.extractFirmware)(firmwareFile, message.firmwareFileFormat ??
                    (0, core_1.guessFirmwareFileFormat)(message.firmwareFilename, firmwareFile));
                // Defer to the target provided in the messaage when available
                firmware.firmwareTarget = message.target ?? firmware.firmwareTarget;
                const result = await node.updateFirmware([firmware]);
                return (0, common_1.firmwareUpdateOutgoingMessage)(result, client.schemaVersion);
            }
            case command_1.NodeCommand.updateFirmware: {
                const updates = message.updates.map((update) => {
                    const file = Buffer.from(update.file, "base64");
                    let firmware = (0, core_1.extractFirmware)(file, update.fileFormat ?? (0, core_1.guessFirmwareFileFormat)(update.filename, file));
                    // Defer to the target provided in the messaage when available
                    firmware.firmwareTarget =
                        update.firmwareTarget ?? firmware.firmwareTarget;
                    return firmware;
                });
                const result = await node.updateFirmware(updates);
                return (0, common_1.firmwareUpdateOutgoingMessage)(result, client.schemaVersion);
            }
            case command_1.NodeCommand.abortFirmwareUpdate: {
                await node.abortFirmwareUpdate();
                return {};
            }
            case command_1.NodeCommand.getFirmwareUpdateCapabilities: {
                const capabilities = await node.getFirmwareUpdateCapabilities();
                return { capabilities };
            }
            case command_1.NodeCommand.getFirmwareUpdateCapabilitiesCached: {
                const capabilities = node.getFirmwareUpdateCapabilitiesCached();
                return { capabilities };
            }
            case command_1.NodeCommand.pollValue: {
                const value = await node.pollValue(message.valueId);
                return { value };
            }
            case command_1.NodeCommand.setRawConfigParameterValue: {
                return (0, common_1.setRawConfigParameterValue)(message, node);
            }
            case command_1.NodeCommand.refreshValues: {
                await node.refreshValues();
                return {};
            }
            case command_1.NodeCommand.refreshCCValues: {
                await node.refreshCCValues(message.commandClass);
                return {};
            }
            case command_1.NodeCommand.ping: {
                const responded = await node.ping();
                return { responded };
            }
            case command_1.NodeCommand.hasSecurityClass: {
                const hasSecurityClass = node.hasSecurityClass(message.securityClass);
                return { hasSecurityClass };
            }
            case command_1.NodeCommand.getHighestSecurityClass: {
                const highestSecurityClass = node.getHighestSecurityClass();
                return { highestSecurityClass };
            }
            case command_1.NodeCommand.testPowerlevel: {
                const framesAcked = await node.testPowerlevel(message.testNodeId, message.powerlevel, message.testFrameCount, (acknowledged, total) => {
                    clientsController.clients.forEach((client) => client.sendEvent({
                        source: "node",
                        event: "test powerlevel progress",
                        nodeId: message.nodeId,
                        acknowledged,
                        total,
                    }));
                });
                return { framesAcked };
            }
            case command_1.NodeCommand.checkLifelineHealth: {
                const summary = await node.checkLifelineHealth(message.rounds, (round, totalRounds, lastRating, lastResult) => {
                    const returnEvent0 = {
                        source: "node",
                        event: "check lifeline health progress",
                        nodeId: message.nodeId,
                        round,
                        totalRounds,
                        lastRating,
                    };
                    const returnEvent31 = { ...returnEvent0, lastResult };
                    clientsController.clients.forEach((client) => {
                        client.sendEvent(client.schemaVersion >= 31 ? returnEvent31 : returnEvent0);
                    });
                });
                return { summary };
            }
            case command_1.NodeCommand.checkRouteHealth: {
                const summary = await node.checkRouteHealth(message.targetNodeId, message.rounds, (round, totalRounds, lastRating, lastResult) => {
                    const returnEvent0 = {
                        source: "node",
                        event: "check route health progress",
                        nodeId: message.nodeId,
                        round,
                        totalRounds,
                        lastRating,
                    };
                    const returnEvent31 = { ...returnEvent0, lastResult };
                    clientsController.clients.forEach((client) => {
                        client.sendEvent(client.schemaVersion >= 31 ? returnEvent31 : returnEvent0);
                    });
                });
                return { summary };
            }
            case command_1.NodeCommand.getValue: {
                const value = node.getValue(message.valueId);
                return { value };
            }
            case command_1.NodeCommand.getEndpointCount: {
                const count = node.getEndpointCount();
                return { count };
            }
            case command_1.NodeCommand.interviewCC: {
                await node.interviewCC(message.commandClass);
                return {};
            }
            case command_1.NodeCommand.getState: {
                const state = (0, __1.dumpNode)(node, client.schemaVersion);
                return { state };
            }
            case command_1.NodeCommand.setKeepAwake: {
                node.keepAwake = message.keepAwake;
                return {};
            }
            case command_1.NodeCommand.setLocation: {
                node.location = message.location;
                if ((message.updateCC ?? true) &&
                    node.supportsCC(core_1.CommandClasses["Node Naming and Location"])) {
                    await node.commandClasses["Node Naming and Location"].setLocation(message.location);
                }
                return {};
            }
            case command_1.NodeCommand.setName: {
                node.name = message.name;
                if ((message.updateCC ?? true) &&
                    node.supportsCC(core_1.CommandClasses["Node Naming and Location"])) {
                    await node.commandClasses["Node Naming and Location"].setName(message.name);
                }
                return {};
            }
            case command_1.NodeCommand.getFirmwareUpdateProgress:
            case command_1.NodeCommand.isFirmwareUpdateInProgress: {
                const progress = node.isFirmwareUpdateInProgress();
                return { progress };
            }
            case command_1.NodeCommand.waitForWakeup: {
                await node.waitForWakeup();
                return {};
            }
            case command_1.NodeCommand.interview: {
                await node.interview();
                return {};
            }
            case command_1.NodeCommand.getValueTimestamp: {
                const timestamp = node.getValueTimestamp(message.valueId);
                return { timestamp };
            }
            case command_1.NodeCommand.manuallyIdleNotificationValue: {
                node.manuallyIdleNotificationValue(message.valueId);
                return {};
            }
            case command_1.NodeCommand.setDateAndTime: {
                const success = await node.setDateAndTime(message.date === undefined ? undefined : new Date(message.date));
                return { success };
            }
            case command_1.NodeCommand.getDateAndTime: {
                const dateAndTime = await node.getDateAndTime();
                return { dateAndTime };
            }
            case command_1.NodeCommand.isHealthCheckInProgress: {
                const progress = node.isHealthCheckInProgress();
                return { progress };
            }
            case command_1.NodeCommand.abortHealthCheck: {
                await node.abortHealthCheck();
                return {};
            }
            case command_1.NodeCommand.setDefaultVolume: {
                node.defaultVolume = message.defaultVolume;
                return {};
            }
            case command_1.NodeCommand.setDefaultTransitionDuration: {
                node.defaultTransitionDuration = message.defaultTransitionDuration;
                return {};
            }
            case command_1.NodeCommand.hasDeviceConfigChanged: {
                const changed = node.hasDeviceConfigChanged();
                return { changed };
            }
            default: {
                throw new error_1.UnknownCommandError(command);
            }
        }
    }
}
exports.NodeMessageHandler = NodeMessageHandler;
