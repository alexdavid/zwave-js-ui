"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ControllerMessageHandler = void 0;
const zwave_js_1 = require("zwave-js");
const __1 = require("..");
const error_1 = require("../error");
const command_1 = require("./command");
const common_1 = require("../common");
const inclusion_user_callbacks_1 = require("../inclusion_user_callbacks");
class ControllerMessageHandler {
    static async handle(message, clientsController, driver, client) {
        const { command } = message;
        switch (message.command) {
            case command_1.ControllerCommand.beginInclusion: {
                if (clientsController.grantSecurityClassesPromise ||
                    clientsController.validateDSKAndEnterPinPromise)
                    throw new error_1.InclusionAlreadyInProgressError();
                const success = await driver.controller.beginInclusion(processInclusionOptions(clientsController, client, message));
                return { success };
            }
            case command_1.ControllerCommand.grantSecurityClasses: {
                if (!clientsController.grantSecurityClassesPromise)
                    throw new error_1.InclusionPhaseNotInProgressError("grantSecurityClassesPromise");
                clientsController.grantSecurityClassesPromise.resolve(message.inclusionGrant);
                return {};
            }
            case command_1.ControllerCommand.validateDSKAndEnterPIN: {
                if (!clientsController.validateDSKAndEnterPinPromise)
                    throw new error_1.InclusionPhaseNotInProgressError("validateDSKAndEnterPinPromise");
                clientsController.validateDSKAndEnterPinPromise.resolve(message.pin);
                return {};
            }
            case command_1.ControllerCommand.provisionSmartStartNode: {
                if (typeof message.entry === "string") {
                    driver.controller.provisionSmartStartNode((0, zwave_js_1.parseQRCodeString)(message.entry));
                }
                else {
                    driver.controller.provisionSmartStartNode(message.entry);
                }
                return {};
            }
            case command_1.ControllerCommand.unprovisionSmartStartNode: {
                driver.controller.unprovisionSmartStartNode(message.dskOrNodeId);
                return {};
            }
            case command_1.ControllerCommand.getProvisioningEntry: {
                const dskOrNodeId = message.dskOrNodeId || message.dsk;
                if (!dskOrNodeId) {
                    throw new error_1.InvalidParamsPassedToCommandError("Must include one of dsk or dskOrNodeId in call to getProvisioningEntry");
                }
                const entry = driver.controller.getProvisioningEntry(dskOrNodeId);
                return { entry };
            }
            case command_1.ControllerCommand.getProvisioningEntries: {
                const entries = driver.controller.getProvisioningEntries();
                return { entries };
            }
            case command_1.ControllerCommand.stopInclusion: {
                const success = await driver.controller.stopInclusion();
                return { success };
            }
            case command_1.ControllerCommand.beginExclusion: {
                const success = await driver.controller.beginExclusion(processExclusionOptions(message));
                return { success };
            }
            case command_1.ControllerCommand.stopExclusion: {
                const success = await driver.controller.stopExclusion();
                return { success };
            }
            case command_1.ControllerCommand.removeFailedNode: {
                await driver.controller.removeFailedNode(message.nodeId);
                return {};
            }
            case command_1.ControllerCommand.replaceFailedNode: {
                const success = await driver.controller.replaceFailedNode(message.nodeId, processInclusionOptions(clientsController, client, message));
                return { success };
            }
            // Schema <= 31
            case command_1.ControllerCommand.healNode:
            case command_1.ControllerCommand.rebuildNodeRoutes: {
                const success = await driver.controller.rebuildNodeRoutes(message.nodeId);
                return { success };
            }
            // Schema <= 31
            case command_1.ControllerCommand.beginHealingNetwork: {
                const success = driver.controller.beginRebuildingRoutes();
                return { success };
            }
            // Schema >= 32
            case command_1.ControllerCommand.beginRebuildingRoutes: {
                const success = driver.controller.beginRebuildingRoutes(message.options);
                return { success };
            }
            // Schema <= 31
            case command_1.ControllerCommand.stopHealingNetwork:
            // Schema >= 32
            case command_1.ControllerCommand.stopRebuildingRoutes: {
                const success = driver.controller.stopRebuildingRoutes();
                return { success };
            }
            case command_1.ControllerCommand.isFailedNode: {
                const failed = await driver.controller.isFailedNode(message.nodeId);
                return { failed };
            }
            case command_1.ControllerCommand.getAssociationGroups: {
                const groups = {};
                driver.controller
                    .getAssociationGroups({
                    nodeId: message.nodeId,
                    endpoint: message.endpoint,
                })
                    .forEach((value, key) => (groups[key] = value));
                return { groups };
            }
            case command_1.ControllerCommand.getAssociations: {
                const associations = {};
                driver.controller
                    .getAssociations({
                    nodeId: message.nodeId,
                    endpoint: message.endpoint,
                })
                    .forEach((value, key) => (associations[key] = value));
                return { associations };
            }
            case command_1.ControllerCommand.isAssociationAllowed: {
                const allowed = driver.controller.isAssociationAllowed({ nodeId: message.nodeId, endpoint: message.endpoint }, message.group, message.association);
                return { allowed };
            }
            case command_1.ControllerCommand.addAssociations: {
                await driver.controller.addAssociations({ nodeId: message.nodeId, endpoint: message.endpoint }, message.group, message.associations);
                return {};
            }
            case command_1.ControllerCommand.removeAssociations: {
                await driver.controller.removeAssociations({ nodeId: message.nodeId, endpoint: message.endpoint }, message.group, message.associations);
                return {};
            }
            case command_1.ControllerCommand.removeNodeFromAllAssocations:
            case command_1.ControllerCommand.removeNodeFromAllAssociations: {
                await driver.controller.removeNodeFromAllAssociations(message.nodeId);
                return {};
            }
            case command_1.ControllerCommand.getNodeNeighbors: {
                const neighbors = await driver.controller.getNodeNeighbors(message.nodeId);
                return { neighbors };
            }
            case command_1.ControllerCommand.supportsFeature: {
                const supported = driver.controller.supportsFeature(message.feature);
                return { supported };
            }
            case command_1.ControllerCommand.backupNVMRaw: {
                const nvmDataRaw = await driver.controller.backupNVMRaw((bytesRead, total) => {
                    clientsController.clients.forEach((client) => client.sendEvent({
                        source: "controller",
                        event: "nvm backup progress",
                        bytesRead,
                        total,
                    }));
                });
                return { nvmData: nvmDataRaw.toString("base64") };
            }
            case command_1.ControllerCommand.restoreNVM: {
                const nvmData = Buffer.from(message.nvmData, "base64");
                await driver.controller.restoreNVM(nvmData, (bytesRead, total) => {
                    clientsController.clients.forEach((client) => client.sendEvent({
                        source: "controller",
                        event: "nvm convert progress",
                        bytesRead,
                        total,
                    }));
                }, (bytesWritten, total) => {
                    clientsController.clients.forEach((client) => client.sendEvent({
                        source: "controller",
                        event: "nvm restore progress",
                        bytesWritten,
                        total,
                    }));
                });
                return {};
            }
            case command_1.ControllerCommand.setRFRegion: {
                const success = await driver.controller.setRFRegion(message.region);
                return { success };
            }
            case command_1.ControllerCommand.getRFRegion: {
                const region = await driver.controller.getRFRegion();
                return { region };
            }
            case command_1.ControllerCommand.setPowerlevel: {
                const success = await driver.controller.setPowerlevel(message.powerlevel, message.measured0dBm);
                return { success };
            }
            case command_1.ControllerCommand.getPowerlevel: {
                return await driver.controller.getPowerlevel();
            }
            case command_1.ControllerCommand.getState: {
                const state = (0, __1.dumpController)(driver, client.schemaVersion);
                return { state };
            }
            case command_1.ControllerCommand.getKnownLifelineRoutes: {
                const routes = driver.controller.getKnownLifelineRoutes();
                return { routes };
            }
            case command_1.ControllerCommand.getAnyFirmwareUpdateProgress:
            case command_1.ControllerCommand.isAnyOTAFirmwareUpdateInProgress: {
                return {
                    progress: driver.controller.isAnyOTAFirmwareUpdateInProgress(),
                };
            }
            case command_1.ControllerCommand.getAvailableFirmwareUpdates: {
                return {
                    updates: await driver.controller.getAvailableFirmwareUpdates(message.nodeId, {
                        apiKey: message.apiKey,
                        additionalUserAgentComponents: client.additionalUserAgentComponents,
                        includePrereleases: message.includePrereleases,
                    }),
                };
            }
            case command_1.ControllerCommand.beginOTAFirmwareUpdate: {
                throw new error_1.NoLongerSupportedError(command_1.ControllerCommand.beginOTAFirmwareUpdate +
                    " is a legacy command that is no longer supported.");
            }
            case command_1.ControllerCommand.firmwareUpdateOTA: {
                if (message.updates !== undefined) {
                    throw new error_1.NoLongerSupportedError(command_1.ControllerCommand.firmwareUpdateOTA +
                        " no longer accepts the `updates` parameter and expects `updateInfo` instead.");
                }
                if (message.updateInfo === undefined) {
                    throw new error_1.InvalidParamsPassedToCommandError("Missing required parameter `updateInfo`");
                }
                const result = await driver.controller.firmwareUpdateOTA(message.nodeId, message.updateInfo);
                return (0, common_1.firmwareUpdateOutgoingMessage)(result, client.schemaVersion);
            }
            case command_1.ControllerCommand.firmwareUpdateOTW: {
                const file = Buffer.from(message.file, "base64");
                const result = await driver.controller.firmwareUpdateOTW((0, zwave_js_1.extractFirmware)(file, message.fileFormat ??
                    (0, zwave_js_1.guessFirmwareFileFormat)(message.filename, file)).data);
                return (0, common_1.firmwareUpdateOutgoingMessage)(result, client.schemaVersion);
            }
            case command_1.ControllerCommand.isFirmwareUpdateInProgress: {
                const progress = driver.controller.isFirmwareUpdateInProgress();
                return { progress };
            }
            default: {
                throw new error_1.UnknownCommandError(command);
            }
        }
    }
}
exports.ControllerMessageHandler = ControllerMessageHandler;
function processExclusionOptions(message) {
    if ("options" in message) {
        return message.options;
    }
    else if ("unprovision" in message) {
        if (typeof message.unprovision === "boolean") {
            return {
                strategy: message.unprovision
                    ? zwave_js_1.ExclusionStrategy.Unprovision
                    : zwave_js_1.ExclusionStrategy.ExcludeOnly,
            };
        }
        else if (message.unprovision === "inactive") {
            return {
                strategy: zwave_js_1.ExclusionStrategy.DisableProvisioningEntry,
            };
        }
    }
    else if ("strategy" in message && message.strategy !== undefined) {
        return { strategy: message.strategy };
    }
}
function processInclusionOptions(clientsController, client, message) {
    // Schema 8+ inclusion handling
    if ("options" in message) {
        const options = message.options;
        if (options.strategy === zwave_js_1.InclusionStrategy.Default ||
            options.strategy === zwave_js_1.InclusionStrategy.Security_S2) {
            // When using Security_S2 inclusion, the user can either provide the provisioning details ahead
            // of time or go through a standard inclusion process and let the driver/client prompt them
            // for provisioning details based on information received from the device. We have to handle
            // each scenario separately.
            if ("provisioning" in options) {
                // There are three input options when providing provisioning details ahead of time:
                // PlannedProvisioningEntry, QRProvisioningInformation, or a QR code string which the server
                // will automatically parse into a QRProvisioningInformation object before proceeding with the
                // inclusion process
                if (typeof options.provisioning === "string") {
                    options.provisioning = (0, zwave_js_1.parseQRCodeString)(options.provisioning);
                }
            }
            else {
                // @ts-expect-error
                options.userCallbacks = (0, inclusion_user_callbacks_1.inclusionUserCallbacks)(clientsController, client);
            }
        }
        return options;
    }
    // Schema <=7 inclusion handling (backwards compatibility logic)
    if ("includeNonSecure" in message && message.includeNonSecure)
        return {
            strategy: zwave_js_1.InclusionStrategy.Insecure,
        };
    return {
        strategy: zwave_js_1.InclusionStrategy.Security_S0,
    };
}
