"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventForwarder = void 0;
const zwave_js_1 = require("zwave-js");
const core_1 = require("@zwave-js/core");
const state_1 = require("./state");
const error_1 = require("./error");
class EventForwarder {
    clientsController;
    /**
     * Only load this once the driver is ready.
     *
     * @param clientsController
     */
    constructor(clientsController) {
        this.clientsController = clientsController;
    }
    start() {
        this.clientsController.driver.controller.nodes.forEach((node) => this.setupNode(node));
        // Bind to all controller events
        // https://github.com/zwave-js/node-zwave-js/blob/master/packages/zwave-js/src/lib/controller/Controller.ts#L112
        this.clientsController.driver.controller.on("node added", (node, result) => {
            // forward event to all connected clients, respecting schemaVersion it supports
            this.clientsController.clients.forEach((client) => this.sendEvent(client, {
                source: "controller",
                event: "node added",
                node: (0, state_1.dumpNode)(node, client.schemaVersion),
                result,
            }));
            this.setupNode(node);
        });
        this.clientsController.driver.controller.on("node found", (node) => {
            // forward event to all connected clients, respecting schemaVersion it supports
            this.clientsController.clients
                .filter((client) => client.schemaVersion > 18)
                .forEach((client) => this.sendEvent(client, {
                source: "controller",
                event: "node found",
                node: (0, state_1.dumpFoundNode)(node, client.schemaVersion),
            }));
        });
        {
            const events = [
                "inclusion failed",
                "exclusion failed",
                "exclusion started",
                "inclusion stopped",
                "exclusion stopped",
            ];
            for (const event of events) {
                this.clientsController.driver.controller.on(event, () => this.forwardEvent({
                    source: "controller",
                    event,
                }));
            }
        }
        this.clientsController.driver.controller.on("inclusion started", (secure) => this.forwardEvent({
            source: "controller",
            event: "inclusion started",
            secure,
        }));
        this.clientsController.driver.controller.on("firmware update progress", (progress) => this.forwardEvent({
            source: "controller",
            event: "firmware update progress",
            progress,
        }));
        this.clientsController.driver.controller.on("firmware update finished", (result) => this.forwardEvent({
            source: "controller",
            event: "firmware update finished",
            result,
        }));
        this.clientsController.driver.controller.on("node removed", (node, reason) => 
        // forward event to all connected clients, respecting schemaVersion it supports
        this.clientsController.clients.forEach((client) => {
            if (client.schemaVersion < 29) {
                this.sendEvent(client, {
                    source: "controller",
                    event: "node removed",
                    node: (0, state_1.dumpNode)(node, client.schemaVersion),
                    replaced: [
                        zwave_js_1.RemoveNodeReason.Replaced,
                        zwave_js_1.RemoveNodeReason.ProxyReplaced,
                    ].includes(reason),
                });
            }
            else {
                this.sendEvent(client, {
                    source: "controller",
                    event: "node removed",
                    node: (0, state_1.dumpNode)(node, client.schemaVersion),
                    reason,
                });
            }
        }));
        this.clientsController.driver.controller.on("rebuild routes progress", (progress) => {
            this.clientsController.clients.forEach((client) => {
                if (client.schemaVersion <= 31) {
                    client.sendEvent({
                        source: "controller",
                        event: "heal network progress",
                        progress: Object.fromEntries(progress),
                    });
                }
                else {
                    client.sendEvent({
                        source: "controller",
                        event: "rebuild routes progress",
                        progress: Object.fromEntries(progress),
                    });
                }
            });
        });
        this.clientsController.driver.controller.on("status changed", (status) => this.forwardEvent({
            source: "controller",
            event: "status changed",
            status,
        }, 31));
        this.clientsController.driver.controller.on("rebuild routes done", (result) => {
            this.clientsController.clients.forEach((client) => {
                if (client.schemaVersion <= 31) {
                    client.sendEvent({
                        source: "controller",
                        event: "heal network done",
                        result: Object.fromEntries(result),
                    });
                }
                else {
                    client.sendEvent({
                        source: "controller",
                        event: "rebuild routes done",
                        result: Object.fromEntries(result),
                    });
                }
            });
        });
        this.clientsController.driver.controller.on("statistics updated", (statistics) => this.forwardEvent({
            source: "controller",
            event: "statistics updated",
            statistics,
        }));
        this.clientsController.driver.controller.on("identify", (triggeringNode) => this.forwardEvent({
            source: "controller",
            event: "identify",
            nodeId: triggeringNode.nodeId,
        }, 31));
    }
    forwardEvent(data, minSchemaVersion) {
        // Forward event to all clients
        this.clientsController.clients.forEach((client) => this.sendEvent(client, data, minSchemaVersion));
    }
    sendEvent(client, data, minSchemaVersion) {
        // Send event to connected client only
        if (client.receiveEvents &&
            client.isConnected &&
            client.schemaVersion >= (minSchemaVersion ?? 0)) {
            client.sendEvent(data);
        }
    }
    setupNode(node) {
        // Bind to all node events
        // https://github.com/zwave-js/node-zwave-js/blob/master/packages/zwave-js/src/lib/node/Types.ts#L84-L103
        const notifyNode = (node, event, extra = {}) => this.forwardEvent({
            source: "node",
            event,
            nodeId: node.nodeId,
            ...extra,
        });
        node.on("ready", (changedNode) => {
            // Dump full node state on ready event
            this.clientsController.clients.forEach((client) => this.sendEvent(client, {
                source: "node",
                event: "ready",
                nodeId: changedNode.nodeId,
                nodeState: (0, state_1.dumpNode)(changedNode, client.schemaVersion),
            }));
        });
        {
            const events = ["wake up", "sleep", "dead", "alive"];
            for (const event of events) {
                node.on(event, (changedNode, oldStatus) => notifyNode(changedNode, event, { oldStatus }));
            }
        }
        {
            const events = [
                "interview completed",
                "interview started",
                "interview failed",
            ];
            for (const event of events) {
                node.on(event, (changedNode, args) => {
                    notifyNode(changedNode, event, { args });
                });
            }
        }
        node.on("interview stage completed", (changedNode, stageName) => {
            notifyNode(changedNode, "interview stage completed", { stageName });
        });
        {
            const events = [
                "value updated",
                "value removed",
                "value added",
                "value notification",
            ];
            for (const event of events) {
                node.on(event, (changedNode, args) => {
                    // only forward value events for ready nodes
                    if (!changedNode.ready)
                        return;
                    notifyNode(changedNode, event, { args });
                });
            }
        }
        node.on("metadata updated", (changedNode, oldArgs) => {
            // only forward value events for ready nodes
            if (!changedNode.ready)
                return;
            this.clientsController.clients.forEach((client) => {
                // Copy arguments for each client so transforms don't impact all clients
                const args = { ...oldArgs };
                if (args.metadata != undefined) {
                    if (args.commandClass === core_1.CommandClasses.Configuration) {
                        args.metadata = (0, state_1.dumpConfigurationMetadata)(args.metadata, client.schemaVersion);
                    }
                    else {
                        args.metadata = (0, state_1.dumpMetadata)(args.metadata, client.schemaVersion);
                    }
                }
                this.sendEvent(client, {
                    source: "node",
                    event: "metadata updated",
                    nodeId: changedNode.nodeId,
                    args,
                });
            });
        });
        node.on("notification", (endpoint, ccId, args) => {
            // only forward value events for ready nodes
            const changedNode = endpoint.getNodeUnsafe();
            if (!changedNode) {
                throw new error_1.NodeNotFoundError(endpoint.nodeId);
            }
            if (!changedNode.ready)
                return;
            this.clientsController.clients.forEach((client) => {
                // Only send notification events from the Notification CC for schema version < 3
                if (client.schemaVersion < 3 && ccId == core_1.CommandClasses.Notification) {
                    let eventData = {
                        source: "node",
                        event: "notification",
                        nodeId: changedNode.nodeId,
                        notificationLabel: args.eventLabel,
                    };
                    if ("parameters" in args) {
                        eventData["parameters"] = args.parameters;
                    }
                    this.sendEvent(client, eventData);
                }
                else if (client.schemaVersion >= 3) {
                    if (client.schemaVersion < 21) {
                        if ([
                            core_1.CommandClasses["Multilevel Switch"],
                            core_1.CommandClasses["Entry Control"],
                        ].includes(ccId)) {
                            delete args.eventTypeLabel;
                        }
                        if (ccId == core_1.CommandClasses["Entry Control"]) {
                            delete args.dataTypeLabel;
                        }
                    }
                    if (client.schemaVersion <= 31) {
                        this.sendEvent(client, {
                            source: "node",
                            event: "notification",
                            nodeId: changedNode.nodeId,
                            ccId,
                            args,
                        });
                    }
                    else {
                        this.sendEvent(client, {
                            source: "node",
                            event: "notification",
                            nodeId: endpoint.nodeId,
                            endpointIndex: endpoint.index,
                            ccId,
                            args,
                        });
                    }
                }
            });
        });
        node.on("firmware update progress", (changedNode, progress) => {
            // only forward value events for ready nodes
            if (!changedNode.ready)
                return;
            this.clientsController.clients.forEach((client) => {
                if (client.schemaVersion <= 23) {
                    this.sendEvent(client, {
                        source: "node",
                        event: "firmware update progress",
                        nodeId: changedNode.nodeId,
                        sentFragments: progress.sentFragments,
                        totalFragments: progress.totalFragments,
                    });
                }
                else {
                    this.sendEvent(client, {
                        source: "node",
                        event: "firmware update progress",
                        nodeId: changedNode.nodeId,
                        progress,
                    });
                }
            });
        });
        node.on("firmware update finished", (changedNode, result) => {
            // only forward value events for ready nodes
            if (!changedNode.ready)
                return;
            this.clientsController.clients.forEach((client) => {
                if (client.schemaVersion <= 23) {
                    this.sendEvent(client, {
                        source: "node",
                        event: "firmware update finished",
                        nodeId: changedNode.nodeId,
                        status: result.status,
                        waitTime: result.waitTime,
                    });
                }
                else {
                    this.sendEvent(client, {
                        source: "node",
                        event: "firmware update finished",
                        nodeId: changedNode.nodeId,
                        result,
                    });
                }
            });
        });
        node.on("statistics updated", (changedNode, statistics) => {
            notifyNode(changedNode, "statistics updated", { statistics });
        });
    }
}
exports.EventForwarder = EventForwarder;
