/// <reference types="node" />
import { type Notification, type NotificationValueDefinition } from "@zwave-js/config";
import { CommandClasses, Duration, type IZWaveEndpoint, type IZWaveNode, type MaybeNotKnown, type MessageOrCCLogEntry, type SinglecastCC, type SupervisionResult, type ValueID, type ValueMetadataNumeric } from "@zwave-js/core/safe";
import type { ZWaveApplicationHost, ZWaveHost } from "@zwave-js/host/safe";
import { POLL_VALUE, PhysicalCCAPI, type PollValueImplementation } from "../lib/API";
import { type CCCommandOptions, CommandClass, type CommandClassDeserializationOptions } from "../lib/CommandClass";
import { NotificationCommand } from "../lib/_Types";
export declare const NotificationCCValues: Readonly<{
    notificationVariable: ((notificationName: string, variableName: string) => {
        readonly meta: {
            readonly type: "any";
            readonly readable: true;
            readonly writeable: true;
        };
        readonly id: {
            commandClass: CommandClasses.Notification;
            property: string;
            propertyKey: string;
        };
        readonly endpoint: (endpoint?: number | undefined) => {
            readonly commandClass: CommandClasses.Notification;
            readonly endpoint: number;
            readonly property: string;
            readonly propertyKey: string;
        };
    }) & {
        is: (valueId: ValueID) => boolean;
        readonly options: {
            readonly internal: false;
            readonly minVersion: 1;
            readonly secret: false;
            readonly stateful: true;
            readonly supportsEndpoints: true;
            readonly autoCreate: true;
        };
    };
    unknownNotificationVariable: ((notificationType: number, notificationName: string) => {
        readonly meta: {
            readonly label: `${string}: Unknown value`;
            readonly ccSpecific: {
                readonly notificationType: number;
            };
            readonly writeable: false;
            readonly min: 0;
            readonly max: 255;
            readonly type: "number";
            readonly readable: true;
        };
        readonly id: {
            commandClass: CommandClasses.Notification;
            property: string;
            propertyKey: "unknown";
        };
        readonly endpoint: (endpoint?: number | undefined) => {
            readonly commandClass: CommandClasses.Notification;
            readonly endpoint: number;
            readonly property: string;
            readonly propertyKey: "unknown";
        };
    }) & {
        is: (valueId: ValueID) => boolean;
        readonly options: {
            readonly internal: false;
            readonly minVersion: 1;
            readonly secret: false;
            readonly stateful: true;
            readonly supportsEndpoints: true;
            readonly autoCreate: true;
        };
    };
    unknownNotificationType: ((notificationType: number) => {
        readonly meta: {
            readonly label: `Unknown notification (${string})`;
            readonly ccSpecific: {
                readonly notificationType: number;
            };
            readonly writeable: false;
            readonly min: 0;
            readonly max: 255;
            readonly type: "number";
            readonly readable: true;
        };
        readonly id: {
            commandClass: CommandClasses.Notification;
            property: string;
        };
        readonly endpoint: (endpoint?: number | undefined) => {
            readonly commandClass: CommandClasses.Notification;
            readonly endpoint: number;
            readonly property: string;
        };
    }) & {
        is: (valueId: ValueID) => boolean;
        readonly options: {
            readonly internal: false;
            readonly minVersion: 1;
            readonly secret: false;
            readonly stateful: true;
            readonly supportsEndpoints: true;
            readonly autoCreate: true;
        };
    };
    supportedNotificationEvents: ((notificationType: number) => {
        readonly meta: {
            readonly type: "any";
            readonly readable: true;
            readonly writeable: true;
        };
        readonly id: {
            commandClass: CommandClasses.Notification;
            property: "supportedNotificationEvents";
            propertyKey: number;
        };
        readonly endpoint: (endpoint?: number | undefined) => {
            readonly commandClass: CommandClasses.Notification;
            readonly endpoint: number;
            readonly property: "supportedNotificationEvents";
            readonly propertyKey: number;
        };
    }) & {
        is: (valueId: ValueID) => boolean;
        readonly options: {
            readonly stateful: true;
            readonly secret: false;
            readonly minVersion: 1;
            readonly autoCreate: true;
            readonly internal: true;
            readonly supportsEndpoints: false;
        };
    };
    doorStateSimple: {
        readonly id: {
            commandClass: CommandClasses.Notification;
            property: "Access Control";
            propertyKey: "Door state (simple)";
        };
        readonly endpoint: (endpoint?: number | undefined) => {
            readonly commandClass: CommandClasses.Notification;
            readonly endpoint: number;
            readonly property: "Access Control";
            readonly propertyKey: "Door state (simple)";
        };
        readonly is: (valueId: ValueID) => boolean;
        readonly meta: {
            readonly label: "Door state (simple)";
            readonly states: {
                readonly 22: "Window/door is open";
                readonly 23: "Window/door is closed";
            };
            readonly ccSpecific: {
                readonly notificationType: 6;
            };
            readonly writeable: false;
            readonly min: 0;
            readonly max: 255;
            readonly type: "number";
            readonly readable: true;
        };
        readonly options: {
            readonly stateful: true;
            readonly secret: false;
            readonly internal: false;
            readonly minVersion: 1;
            readonly supportsEndpoints: true;
            readonly autoCreate: (applHost: ZWaveApplicationHost, endpoint: IZWaveEndpoint) => boolean;
        };
    };
    alarmLevel: {
        readonly id: {
            commandClass: CommandClasses.Notification;
            property: "alarmLevel";
        };
        readonly endpoint: (endpoint?: number | undefined) => {
            readonly commandClass: CommandClasses.Notification;
            readonly endpoint: number;
            readonly property: "alarmLevel";
        };
        readonly is: (valueId: ValueID) => boolean;
        readonly meta: {
            readonly label: "Alarm Level";
            readonly writeable: false;
            readonly min: 0;
            readonly max: 255;
            readonly type: "number";
            readonly readable: true;
        };
        readonly options: {
            readonly internal: false;
            readonly minVersion: 1;
            readonly secret: false;
            readonly stateful: true;
            readonly supportsEndpoints: true;
            readonly autoCreate: true;
        };
    };
    alarmType: {
        readonly id: {
            commandClass: CommandClasses.Notification;
            property: "alarmType";
        };
        readonly endpoint: (endpoint?: number | undefined) => {
            readonly commandClass: CommandClasses.Notification;
            readonly endpoint: number;
            readonly property: "alarmType";
        };
        readonly is: (valueId: ValueID) => boolean;
        readonly meta: {
            readonly label: "Alarm Type";
            readonly writeable: false;
            readonly min: 0;
            readonly max: 255;
            readonly type: "number";
            readonly readable: true;
        };
        readonly options: {
            readonly internal: false;
            readonly minVersion: 1;
            readonly secret: false;
            readonly stateful: true;
            readonly supportsEndpoints: true;
            readonly autoCreate: true;
        };
    };
    lastRefresh: {
        readonly id: {
            commandClass: CommandClasses.Notification;
            property: "lastRefresh";
        };
        readonly endpoint: (endpoint?: number | undefined) => {
            readonly commandClass: CommandClasses.Notification;
            readonly endpoint: number;
            readonly property: "lastRefresh";
        };
        readonly is: (valueId: ValueID) => boolean;
        readonly meta: {
            readonly type: "any";
            readonly readable: true;
            readonly writeable: true;
        };
        readonly options: {
            readonly stateful: true;
            readonly secret: false;
            readonly minVersion: 1;
            readonly supportsEndpoints: true;
            readonly autoCreate: true;
            readonly internal: true;
        };
    };
    notificationMode: {
        readonly id: {
            commandClass: CommandClasses.Notification;
            property: "notificationMode";
        };
        readonly endpoint: (endpoint?: number | undefined) => {
            readonly commandClass: CommandClasses.Notification;
            readonly endpoint: number;
            readonly property: "notificationMode";
        };
        readonly is: (valueId: ValueID) => boolean;
        readonly meta: {
            readonly type: "any";
            readonly readable: true;
            readonly writeable: true;
        };
        readonly options: {
            readonly stateful: true;
            readonly secret: false;
            readonly minVersion: 1;
            readonly autoCreate: true;
            readonly internal: true;
            readonly supportsEndpoints: false;
        };
    };
    supportedNotificationTypes: {
        readonly id: {
            commandClass: CommandClasses.Notification;
            property: "supportedNotificationTypes";
        };
        readonly endpoint: (endpoint?: number | undefined) => {
            readonly commandClass: CommandClasses.Notification;
            readonly endpoint: number;
            readonly property: "supportedNotificationTypes";
        };
        readonly is: (valueId: ValueID) => boolean;
        readonly meta: {
            readonly type: "any";
            readonly readable: true;
            readonly writeable: true;
        };
        readonly options: {
            readonly stateful: true;
            readonly secret: false;
            readonly minVersion: 1;
            readonly autoCreate: true;
            readonly internal: true;
            readonly supportsEndpoints: false;
        };
    };
    supportsV1Alarm: {
        readonly id: {
            commandClass: CommandClasses.Notification;
            property: "supportsV1Alarm";
        };
        readonly endpoint: (endpoint?: number | undefined) => {
            readonly commandClass: CommandClasses.Notification;
            readonly endpoint: number;
            readonly property: "supportsV1Alarm";
        };
        readonly is: (valueId: ValueID) => boolean;
        readonly meta: {
            readonly type: "any";
            readonly readable: true;
            readonly writeable: true;
        };
        readonly options: {
            readonly stateful: true;
            readonly secret: false;
            readonly minVersion: 1;
            readonly autoCreate: true;
            readonly internal: true;
            readonly supportsEndpoints: false;
        };
    };
}>;
export declare class NotificationCCAPI extends PhysicalCCAPI {
    supportsCommand(cmd: NotificationCommand): MaybeNotKnown<boolean>;
    protected get [POLL_VALUE](): PollValueImplementation;
    sendReport(options: NotificationCCReportOptions): Promise<SupervisionResult | undefined>;
    get(options: NotificationCCGetSpecificOptions): Promise<Pick<NotificationCCReport, "alarmLevel" | "notificationEvent" | "eventParameters" | "sequenceNumber" | "notificationStatus" | "zensorNetSourceNodeId"> | undefined>;
    set(notificationType: number, notificationStatus: boolean): Promise<SupervisionResult | undefined>;
    getSupported(): Promise<Pick<NotificationCCSupportedReport, "supportsV1Alarm" | "supportedNotificationTypes"> | undefined>;
    getSupportedEvents(notificationType: number): Promise<MaybeNotKnown<readonly number[]>>;
}
export declare function getNotificationEnumBehavior(notificationConfig: Notification, valueConfig: NotificationValueDefinition & {
    type: "state";
}): "none" | "extend" | "replace";
export declare function getNotificationStateValueWithEnum(stateValue: number, enumValue: number): number;
/**
 * Returns the metadata to use for a known notification value.
 * Can be used to extend a previously defined metadata,
 * e.g. for V2 notifications that don't allow discovering supported events.
 */
export declare function getNotificationValueMetadata(previous: ValueMetadataNumeric | undefined, notificationConfig: Notification, valueConfig: NotificationValueDefinition & {
    type: "state";
}): ValueMetadataNumeric;
export declare class NotificationCC extends CommandClass {
    ccCommand: NotificationCommand;
    determineRequiredCCInterviews(): readonly CommandClasses[];
    private determineNotificationMode;
    /** Whether the node implements push or pull notifications */
    static getNotificationMode(applHost: ZWaveApplicationHost, node: IZWaveNode): MaybeNotKnown<"push" | "pull">;
    interview(applHost: ZWaveApplicationHost): Promise<void>;
    refreshValues(applHost: ZWaveApplicationHost): Promise<void>;
    shouldRefreshValues(this: SinglecastCC<this>, applHost: ZWaveApplicationHost): boolean;
}
export interface NotificationCCSetOptions extends CCCommandOptions {
    notificationType: number;
    notificationStatus: boolean;
}
export declare class NotificationCCSet extends NotificationCC {
    constructor(host: ZWaveHost, options: CommandClassDeserializationOptions | NotificationCCSetOptions);
    notificationType: number;
    notificationStatus: boolean;
    serialize(): Buffer;
    toLogEntry(applHost: ZWaveApplicationHost): MessageOrCCLogEntry;
}
export type NotificationCCReportOptions = {
    alarmType: number;
    alarmLevel: number;
} | {
    notificationType: number;
    notificationEvent: number;
    eventParameters?: Buffer;
    sequenceNumber?: number;
};
export declare class NotificationCCReport extends NotificationCC {
    constructor(host: ZWaveHost, options: CommandClassDeserializationOptions | (NotificationCCReportOptions & CCCommandOptions));
    persistValues(applHost: ZWaveApplicationHost): boolean;
    alarmType: number | undefined;
    alarmLevel: number | undefined;
    notificationType: number | undefined;
    notificationStatus: boolean | number | undefined;
    notificationEvent: number | undefined;
    readonly zensorNetSourceNodeId: number | undefined;
    eventParameters: Buffer | Duration | Record<string, number> | number | undefined;
    sequenceNumber: number | undefined;
    toLogEntry(applHost: ZWaveApplicationHost): MessageOrCCLogEntry;
    private parseEventParameters;
    serialize(): Buffer;
}
type NotificationCCGetSpecificOptions = {
    alarmType: number;
} | {
    notificationType: number;
    notificationEvent?: number;
};
export type NotificationCCGetOptions = CCCommandOptions & NotificationCCGetSpecificOptions;
export declare class NotificationCCGet extends NotificationCC {
    constructor(host: ZWaveHost, options: CommandClassDeserializationOptions | NotificationCCGetOptions);
    /** Proprietary V1/V2 alarm type */
    alarmType: number | undefined;
    /** Regulated V3+ notification type */
    notificationType: number | undefined;
    notificationEvent: number | undefined;
    serialize(): Buffer;
    toLogEntry(applHost: ZWaveApplicationHost): MessageOrCCLogEntry;
}
export interface NotificationCCSupportedReportOptions extends CCCommandOptions {
    supportsV1Alarm: boolean;
    supportedNotificationTypes: number[];
}
export declare class NotificationCCSupportedReport extends NotificationCC {
    constructor(host: ZWaveHost, options: NotificationCCSupportedReportOptions | CommandClassDeserializationOptions);
    supportsV1Alarm: boolean;
    supportedNotificationTypes: number[];
    serialize(): Buffer;
    toLogEntry(applHost: ZWaveApplicationHost): MessageOrCCLogEntry;
}
export declare class NotificationCCSupportedGet extends NotificationCC {
}
export interface NotificationCCEventSupportedReportOptions extends CCCommandOptions {
    notificationType: number;
    supportedEvents: number[];
}
export declare class NotificationCCEventSupportedReport extends NotificationCC {
    constructor(host: ZWaveHost, options: CommandClassDeserializationOptions | NotificationCCEventSupportedReportOptions);
    persistValues(applHost: ZWaveApplicationHost): boolean;
    notificationType: number;
    supportedEvents: number[];
    serialize(): Buffer;
    toLogEntry(applHost: ZWaveApplicationHost): MessageOrCCLogEntry;
}
export interface NotificationCCEventSupportedGetOptions extends CCCommandOptions {
    notificationType: number;
}
export declare class NotificationCCEventSupportedGet extends NotificationCC {
    constructor(host: ZWaveHost, options: CommandClassDeserializationOptions | NotificationCCEventSupportedGetOptions);
    notificationType: number;
    serialize(): Buffer;
    toLogEntry(applHost: ZWaveApplicationHost): MessageOrCCLogEntry;
}
export {};
//# sourceMappingURL=NotificationCC.d.ts.map