/// <reference types="node" />
import { CommandClasses, type IZWaveEndpoint, type MaybeNotKnown, type MessageOrCCLogEntry, type SupervisionResult } from "@zwave-js/core/safe";
import type { ZWaveApplicationHost, ZWaveHost } from "@zwave-js/host/safe";
import { CCAPI, POLL_VALUE, type PollValueImplementation, SET_VALUE, type SetValueImplementation } from "../lib/API";
import { type CCCommandOptions, CommandClass, type CommandClassDeserializationOptions } from "../lib/CommandClass";
import { IndicatorCommand, type IndicatorTimeout } from "../lib/_Types";
export declare const IndicatorCCValues: Readonly<{
    indicatorDescription: ((indicatorId: number) => {
        readonly meta: {
            readonly type: "any";
            readonly readable: true;
            readonly writeable: true;
        };
        readonly id: {
            commandClass: CommandClasses.Indicator;
            property: number;
        };
        readonly endpoint: (endpoint?: number | undefined) => {
            readonly commandClass: CommandClasses.Indicator;
            readonly endpoint: number;
            readonly property: number;
        };
    }) & {
        is: (valueId: import("@zwave-js/core/safe").ValueID) => boolean;
        readonly options: {
            readonly stateful: true;
            readonly secret: false;
            readonly supportsEndpoints: true;
            readonly autoCreate: true;
            readonly internal: true;
            readonly minVersion: 4;
        };
    };
    valueV2: ((indicatorId: number, propertyId: number) => {
        readonly meta: {
            readonly ccSpecific: {
                indicatorId: number;
                propertyId: number;
            };
            readonly type: "any";
            readonly readable: true;
            readonly writeable: true;
        };
        readonly id: {
            commandClass: CommandClasses.Indicator;
            property: number;
            propertyKey: number;
        };
        readonly endpoint: (endpoint?: number | undefined) => {
            readonly commandClass: CommandClasses.Indicator;
            readonly endpoint: number;
            readonly property: number;
            readonly propertyKey: number;
        };
    }) & {
        is: (valueId: import("@zwave-js/core/safe").ValueID) => boolean;
        readonly options: {
            readonly stateful: true;
            readonly secret: false;
            readonly internal: false;
            readonly supportsEndpoints: true;
            readonly autoCreate: true;
            readonly minVersion: 2;
        };
    };
    supportedPropertyIDs: ((indicatorId: number) => {
        readonly meta: {
            readonly type: "any";
            readonly readable: true;
            readonly writeable: true;
        };
        readonly id: {
            commandClass: CommandClasses.Indicator;
            property: "supportedPropertyIDs";
            propertyKey: number;
        };
        readonly endpoint: (endpoint?: number | undefined) => {
            readonly commandClass: CommandClasses.Indicator;
            readonly endpoint: number;
            readonly property: "supportedPropertyIDs";
            readonly propertyKey: number;
        };
    }) & {
        is: (valueId: import("@zwave-js/core/safe").ValueID) => boolean;
        readonly options: {
            readonly stateful: true;
            readonly secret: false;
            readonly minVersion: 1;
            readonly supportsEndpoints: true;
            readonly autoCreate: true;
            readonly internal: true;
        };
    };
    timeout: {
        readonly id: {
            commandClass: CommandClasses.Indicator;
            property: "timeout";
        };
        readonly endpoint: (endpoint?: number | undefined) => {
            readonly commandClass: CommandClasses.Indicator;
            readonly endpoint: number;
            readonly property: "timeout";
        };
        readonly is: (valueId: import("@zwave-js/core/safe").ValueID) => boolean;
        readonly meta: {
            readonly label: "Timeout";
            readonly type: "string";
            readonly readable: true;
            readonly writeable: true;
        };
        readonly options: {
            readonly stateful: true;
            readonly secret: false;
            readonly internal: false;
            readonly supportsEndpoints: true;
            readonly autoCreate: true;
            readonly minVersion: 3;
        };
    };
    identify: {
        readonly id: {
            commandClass: CommandClasses.Indicator;
            property: "identify";
        };
        readonly endpoint: (endpoint?: number | undefined) => {
            readonly commandClass: CommandClasses.Indicator;
            readonly endpoint: number;
            readonly property: "identify";
        };
        readonly is: (valueId: import("@zwave-js/core/safe").ValueID) => boolean;
        readonly meta: {
            readonly label: "Identify";
            readonly states: {
                readonly true: "Identify";
            };
            readonly readable: false;
            readonly type: "boolean";
            readonly writeable: true;
        };
        readonly options: {
            readonly stateful: true;
            readonly secret: false;
            readonly internal: false;
            readonly supportsEndpoints: true;
            readonly autoCreate: true;
            readonly minVersion: 3;
        };
    };
    valueV1: {
        readonly id: {
            commandClass: CommandClasses.Indicator;
            property: "value";
        };
        readonly endpoint: (endpoint?: number | undefined) => {
            readonly commandClass: CommandClasses.Indicator;
            readonly endpoint: number;
            readonly property: "value";
        };
        readonly is: (valueId: import("@zwave-js/core/safe").ValueID) => boolean;
        readonly meta: {
            readonly label: "Indicator value";
            readonly ccSpecific: {
                readonly indicatorId: 0;
            };
            readonly min: 0;
            readonly max: 255;
            readonly type: "number";
            readonly readable: true;
            readonly writeable: true;
        };
        readonly options: {
            readonly internal: false;
            readonly minVersion: 1;
            readonly secret: false;
            readonly stateful: true;
            readonly supportsEndpoints: true;
            readonly autoCreate: true;
        };
    };
    supportedIndicatorIds: {
        readonly id: {
            commandClass: CommandClasses.Indicator;
            property: "supportedIndicatorIds";
        };
        readonly endpoint: (endpoint?: number | undefined) => {
            readonly commandClass: CommandClasses.Indicator;
            readonly endpoint: number;
            readonly property: "supportedIndicatorIds";
        };
        readonly is: (valueId: import("@zwave-js/core/safe").ValueID) => boolean;
        readonly meta: {
            readonly type: "any";
            readonly readable: true;
            readonly writeable: true;
        };
        readonly options: {
            readonly stateful: true;
            readonly secret: false;
            readonly minVersion: 1;
            readonly supportsEndpoints: true;
            readonly autoCreate: true;
            readonly internal: true;
        };
    };
}>;
export declare class IndicatorCCAPI extends CCAPI {
    supportsCommand(cmd: IndicatorCommand): MaybeNotKnown<boolean>;
    protected get [SET_VALUE](): SetValueImplementation;
    protected get [POLL_VALUE](): PollValueImplementation;
    get(indicatorId?: number): Promise<MaybeNotKnown<number | IndicatorObject[]>>;
    set(value: number | IndicatorObject[]): Promise<SupervisionResult | undefined>;
    getSupported(indicatorId: number): Promise<{
        indicatorId?: number;
        supportedProperties: readonly number[];
        nextIndicatorId: number;
    } | undefined>;
    reportSupported(indicatorId: number, supportedProperties: readonly number[], nextIndicatorId: number): Promise<void>;
    /**
     * Instructs the node to identify itself. Available starting with V3 of this CC.
     */
    identify(): Promise<SupervisionResult | undefined>;
    /**
     * Set a timeout for a given indicator ID after which the indicator will be turned off.
     * @param timeout The timeout in one of the supported forms:
     * 	- a timeout string in the form `12h18m17.59s`. All parts (hours, minutes, seconds, hundredths) are optional, but must be specified in this order. An empty string will be treated like `undefined`.
     * 	- an object specifying the timeout parts. An empty object will be treated like `undefined`.
     * 	- `undefined` to disable the timeout.
     */
    setTimeout(indicatorId: number, timeout: IndicatorTimeout | string | undefined): Promise<SupervisionResult | undefined>;
    /**
     * Returns the timeout after which the given indicator will be turned off.
     */
    getTimeout(indicatorId: number): Promise<MaybeNotKnown<IndicatorTimeout>>;
    getDescription(indicatorId: number): Promise<MaybeNotKnown<string>>;
}
export declare class IndicatorCC extends CommandClass {
    ccCommand: IndicatorCommand;
    interview(applHost: ZWaveApplicationHost): Promise<void>;
    refreshValues(applHost: ZWaveApplicationHost): Promise<void>;
    translatePropertyKey(applHost: ZWaveApplicationHost, property: string | number, propertyKey: string | number): string | undefined;
    translateProperty(applHost: ZWaveApplicationHost, property: string | number, propertyKey?: string | number): string;
    protected supportsV2Indicators(applHost: ZWaveApplicationHost): boolean;
    static getSupportedPropertyIDsCached(applHost: ZWaveApplicationHost, endpoint: IZWaveEndpoint, indicatorId: number): MaybeNotKnown<number[]>;
}
export interface IndicatorObject {
    indicatorId: number;
    propertyId: number;
    value: number | boolean;
}
export type IndicatorCCSetOptions = {
    value: number;
} | {
    values: IndicatorObject[];
};
export declare class IndicatorCCSet extends IndicatorCC {
    constructor(host: ZWaveHost, options: CommandClassDeserializationOptions | (IndicatorCCSetOptions & CCCommandOptions));
    indicator0Value: number | undefined;
    values: IndicatorObject[] | undefined;
    serialize(): Buffer;
    toLogEntry(applHost: ZWaveApplicationHost): MessageOrCCLogEntry;
}
export type IndicatorCCReportSpecificOptions = {
    value: number;
} | {
    values: IndicatorObject[];
};
export declare class IndicatorCCReport extends IndicatorCC {
    constructor(host: ZWaveHost, options: CommandClassDeserializationOptions | (IndicatorCCReportSpecificOptions & CCCommandOptions));
    persistValues(applHost: ZWaveApplicationHost): boolean;
    readonly indicator0Value: number | undefined;
    readonly values: IndicatorObject[] | undefined;
    private setIndicatorValue;
    serialize(): Buffer;
    toLogEntry(applHost: ZWaveApplicationHost): MessageOrCCLogEntry;
}
export interface IndicatorCCGetOptions extends CCCommandOptions {
    indicatorId?: number;
}
export declare class IndicatorCCGet extends IndicatorCC {
    constructor(host: ZWaveHost, options: CommandClassDeserializationOptions | IndicatorCCGetOptions);
    indicatorId: number | undefined;
    serialize(): Buffer;
    toLogEntry(applHost: ZWaveApplicationHost): MessageOrCCLogEntry;
}
export interface IndicatorCCSupportedReportOptions extends CCCommandOptions {
    indicatorId: number;
    nextIndicatorId: number;
    supportedProperties: readonly number[];
}
export declare class IndicatorCCSupportedReport extends IndicatorCC {
    constructor(host: ZWaveHost, options: CommandClassDeserializationOptions | IndicatorCCSupportedReportOptions);
    persistValues(applHost: ZWaveApplicationHost): boolean;
    readonly indicatorId: number;
    readonly nextIndicatorId: number;
    readonly supportedProperties: readonly number[];
    serialize(): Buffer;
    toLogEntry(applHost: ZWaveApplicationHost): MessageOrCCLogEntry;
}
export interface IndicatorCCSupportedGetOptions extends CCCommandOptions {
    indicatorId: number;
}
export declare class IndicatorCCSupportedGet extends IndicatorCC {
    constructor(host: ZWaveHost, options: CommandClassDeserializationOptions | IndicatorCCSupportedGetOptions);
    indicatorId: number;
    serialize(): Buffer;
    toLogEntry(applHost: ZWaveApplicationHost): MessageOrCCLogEntry;
}
export declare class IndicatorCCDescriptionReport extends IndicatorCC {
    constructor(host: ZWaveHost, options: CommandClassDeserializationOptions);
    indicatorId: number;
    description: string;
    persistValues(applHost: ZWaveApplicationHost): boolean;
    toLogEntry(applHost: ZWaveApplicationHost): MessageOrCCLogEntry;
}
export interface IndicatorCCDescriptionGetOptions extends CCCommandOptions {
    indicatorId: number;
}
export declare class IndicatorCCDescriptionGet extends IndicatorCC {
    constructor(host: ZWaveHost, options: CommandClassDeserializationOptions | IndicatorCCDescriptionGetOptions);
    indicatorId: number;
    serialize(): Buffer;
    toLogEntry(applHost: ZWaveApplicationHost): MessageOrCCLogEntry;
}
//# sourceMappingURL=IndicatorCC.d.ts.map