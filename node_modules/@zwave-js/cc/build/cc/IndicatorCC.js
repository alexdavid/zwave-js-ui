"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndicatorCCDescriptionGet = exports.IndicatorCCDescriptionReport = exports.IndicatorCCSupportedGet = exports.IndicatorCCSupportedReport = exports.IndicatorCCGet = exports.IndicatorCCReport = exports.IndicatorCCSet = exports.IndicatorCC = exports.IndicatorCCAPI = exports.IndicatorCCValues = void 0;
function __assertType(argName, typeName, boundHasError) {
    const { ZWaveError, ZWaveErrorCodes } = require("@zwave-js/core");
    if (boundHasError()) {
        throw new ZWaveError(typeName ? `${argName} is not a ${typeName}` : `${argName} has the wrong type`, ZWaveErrorCodes.Argument_Invalid);
    }
}
const __assertType__optional_number = $o => {
    function _number($o) {
        return typeof $o !== "number" ? {} : null;
    }
    function optional__number($o) {
        if ($o !== undefined) {
            const error = _number($o);
            if (error)
                return error;
        }
        return null;
    }
    return optional__number($o);
};
const __assertType__su__number_sa__5_ea_5_5_5_eu = $o => {
    function _number($o) {
        return typeof $o !== "number" ? {} : null;
    }
    function _false($o) {
        return $o !== false ? {} : null;
    }
    function _true($o) {
        return $o !== true ? {} : null;
    }
    function su__number__7__8_eu($o) {
        const conditions = [_number, _false, _true];
        for (const condition of conditions) {
            const error = condition($o);
            if (!error)
                return null;
        }
        return {};
    }
    function _5($o) {
        if (typeof $o !== "object" || $o === null || Array.isArray($o))
            return {};
        if ("indicatorId" in $o && $o["indicatorId"] !== undefined) {
            const error = _number($o["indicatorId"]);
            if (error)
                return error;
        }
        else
            return {};
        if ("propertyId" in $o && $o["propertyId"] !== undefined) {
            const error = _number($o["propertyId"]);
            if (error)
                return error;
        }
        else
            return {};
        if ("value" in $o && $o["value"] !== undefined) {
            const error = su__number__7__8_eu($o["value"]);
            if (error)
                return error;
        }
        else
            return {};
        return null;
    }
    function sa__5_ea_5($o) {
        if (!Array.isArray($o))
            return {};
        for (let i = 0; i < $o.length; i++) {
            const error = _5($o[i]);
            if (error)
                return error;
        }
        return null;
    }
    function su__number_sa__5_ea_5_5_5_eu($o) {
        const conditions = [_number, sa__5_ea_5];
        for (const condition of conditions) {
            const error = condition($o);
            if (!error)
                return null;
        }
        return {};
    }
    return su__number_sa__5_ea_5_5_5_eu($o);
};
const __assertType__number = $o => {
    function _number($o) {
        return typeof $o !== "number" ? {} : null;
    }
    return _number($o);
};
const __assertType__sa__number_ea_2 = $o => {
    function _number($o) {
        return typeof $o !== "number" ? {} : null;
    }
    function sa__number_ea_2($o) {
        if (!Array.isArray($o))
            return {};
        for (let i = 0; i < $o.length; i++) {
            const error = _number($o[i]);
            if (error)
                return error;
        }
        return null;
    }
    return sa__number_ea_2($o);
};
const __assertType__su__undefined__string__3_eu = $o => {
    function _undefined($o) {
        return $o !== undefined ? {} : null;
    }
    function _string($o) {
        return typeof $o !== "string" ? {} : null;
    }
    function _number($o) {
        return typeof $o !== "number" ? {} : null;
    }
    function _3($o) {
        if (typeof $o !== "object" || $o === null || Array.isArray($o))
            return {};
        if ("hours" in $o && $o["hours"] !== undefined) {
            const error = _number($o["hours"]);
            if (error)
                return error;
        }
        if ("minutes" in $o && $o["minutes"] !== undefined) {
            const error = _number($o["minutes"]);
            if (error)
                return error;
        }
        if ("seconds" in $o && $o["seconds"] !== undefined) {
            const error = _number($o["seconds"]);
            if (error)
                return error;
        }
        return null;
    }
    function su__undefined__string__3_eu($o) {
        const conditions = [_undefined, _string, _3];
        for (const condition of conditions) {
            const error = condition($o);
            if (!error)
                return null;
        }
        return {};
    }
    return su__undefined__string__3_eu($o);
};
const safe_1 = require("@zwave-js/core/safe");
const safe_2 = require("@zwave-js/shared/safe");
const math_1 = require("alcalzone-shared/math");
const typeguards_1 = require("alcalzone-shared/typeguards");
const API_1 = require("../lib/API");
const CommandClass_1 = require("../lib/CommandClass");
const CommandClassDecorators_1 = require("../lib/CommandClassDecorators");
const Values_1 = require("../lib/Values");
const _Types_1 = require("../lib/_Types");
function isManufacturerDefinedIndicator(indicatorId) {
    return indicatorId >= 0x80 && indicatorId <= 0x9f;
}
const timeoutStringRegex = /^(?:(?<hoursStr>\d+)h)?(?:(?<minutesStr>\d+)m)?(?:(?<secondsStr>\d+(?:\.\d+)?)s)?$/i;
function parseIndicatorTimeoutString(text) {
    if (!text.length)
        return undefined;
    // Try to parse the numeric parts from a timeout
    const match = timeoutStringRegex.exec(text);
    if (!match)
        return undefined;
    const { hoursStr, minutesStr, secondsStr } = match.groups;
    if (!hoursStr && !minutesStr && !secondsStr)
        return undefined;
    const ret = {};
    if (hoursStr) {
        ret.hours = (0, math_1.clamp)(parseInt(hoursStr, 10), 0, 255);
    }
    if (minutesStr) {
        ret.minutes = (0, math_1.clamp)(parseInt(minutesStr, 10), 0, 255);
    }
    if (secondsStr) {
        ret.seconds = (0, math_1.clamp)((0, math_1.roundTo)(parseFloat(secondsStr), 2), 0, 59.99);
    }
    return ret;
}
function indicatorObjectsToTimeout(values) {
    const timeoutValues = values.filter((v) => [0x0a, 0x06, 0x07, 0x08].includes(v.propertyId));
    if (!timeoutValues.length)
        return undefined;
    const hours = (timeoutValues.find((v) => v.propertyId === 0x0a)?.value
        ?? 0);
    const minutes = (timeoutValues.find((v) => v.propertyId === 0x06)?.value
        ?? 0);
    const seconds = (0, math_1.clamp)(timeoutValues.find((v) => v.propertyId === 0x07)
        ?.value ?? 0, 0, 59)
        + (0, math_1.clamp)(timeoutValues.find((v) => v.propertyId === 0x08)
            ?.value ?? 0, 0, 99)
            / 100;
    return {
        hours,
        minutes,
        seconds,
    };
}
exports.IndicatorCCValues = Object.freeze({
    ...Values_1.V.defineStaticCCValues(safe_1.CommandClasses.Indicator, {
        ...Values_1.V.staticProperty("supportedIndicatorIds", undefined, {
            internal: true,
        }),
        ...Values_1.V.staticPropertyWithName("valueV1", "value", {
            ...safe_1.ValueMetadata.UInt8,
            label: "Indicator value",
            ccSpecific: {
                indicatorId: 0,
            },
        }),
        // Convenience values for indicators that are split across multiple properties
        ...Values_1.V.staticProperty("identify", {
            ...safe_1.ValueMetadata.WriteOnlyBoolean,
            label: "Identify",
            states: {
                true: "Identify",
            },
        }, { minVersion: 3 }),
        ...Values_1.V.staticProperty("timeout", {
            ...safe_1.ValueMetadata.String,
            label: "Timeout",
        }, { minVersion: 3 }),
    }),
    ...Values_1.V.defineDynamicCCValues(safe_1.CommandClasses.Indicator, {
        ...Values_1.V.dynamicPropertyAndKeyWithName("supportedPropertyIDs", "supportedPropertyIDs", (indicatorId) => indicatorId, ({ property, propertyKey }) => property === "supportedPropertyIDs"
            && typeof propertyKey === "number", undefined, { internal: true }),
        ...Values_1.V.dynamicPropertyAndKeyWithName("valueV2", 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        (indicatorId, propertyId) => indicatorId, (indicatorId, propertyId) => propertyId, ({ property, propertyKey }) => typeof property === "number" && typeof propertyKey === "number", 
        // The metadata is highly dependent on the indicator and property
        // so this is just a baseline
        (indicatorId, propertyId) => ({
            ...safe_1.ValueMetadata.Any,
            ccSpecific: {
                indicatorId,
                propertyId,
            },
        }), { minVersion: 2 }),
        ...Values_1.V.dynamicPropertyWithName("indicatorDescription", (indicatorId) => indicatorId, ({ property }) => typeof property === "number", undefined, { internal: true, minVersion: 4 }),
    }),
});
/**
 * Looks up the configured metadata for the given indicator and property
 */
function getIndicatorMetadata(configManager, indicatorId, propertyId, overrideIndicatorLabel) {
    const label = overrideIndicatorLabel
        || configManager.lookupIndicator(indicatorId);
    const prop = configManager.lookupProperty(propertyId);
    const baseMetadata = exports.IndicatorCCValues.valueV2(indicatorId, propertyId).meta;
    if (!label && !prop) {
        return {
            ...baseMetadata,
            ...safe_1.ValueMetadata.UInt8,
        };
    }
    else if (!prop) {
        return {
            ...baseMetadata,
            ...safe_1.ValueMetadata.UInt8,
            label,
        };
    }
    else {
        if (prop.type === "boolean") {
            return {
                ...baseMetadata,
                ...safe_1.ValueMetadata.Boolean,
                label: `${label} - ${prop.label}`,
                description: prop.description,
                readable: !prop.readonly,
            };
        }
        else {
            // UInt8
            return {
                ...baseMetadata,
                ...safe_1.ValueMetadata.UInt8,
                label: `${label} - ${prop.label}`,
                description: prop.description,
                min: prop.min,
                max: prop.max,
                readable: !prop.readonly,
            };
        }
    }
}
function getIndicatorName(configManager, indicatorId) {
    let indicatorName = "0 (default)";
    if (indicatorId) {
        indicatorName = `${(0, safe_2.num2hex)(indicatorId)} (${configManager.lookupIndicator(indicatorId) ?? `Unknown`})`;
    }
    return indicatorName;
}
const MAX_INDICATOR_OBJECTS = 31;
let IndicatorCCAPI = class IndicatorCCAPI extends API_1.CCAPI {
    supportsCommand(cmd) {
        switch (cmd) {
            case _Types_1.IndicatorCommand.Get:
            case _Types_1.IndicatorCommand.Report:
                return this.isSinglecast();
            case _Types_1.IndicatorCommand.Set:
                return true; // This is mandatory
            case _Types_1.IndicatorCommand.SupportedGet:
            case _Types_1.IndicatorCommand.SupportedReport:
                return this.version >= 2 && this.isSinglecast();
            case _Types_1.IndicatorCommand.DescriptionGet:
                return this.version >= 4 && this.isSinglecast();
        }
        return super.supportsCommand(cmd);
    }
    get [API_1.SET_VALUE]() {
        return async function ({ property, propertyKey }, value) {
            if (property === "value") {
                // V1 value
                if (typeof value !== "number") {
                    (0, API_1.throwWrongValueType)(this.ccId, property, "number", typeof value);
                }
                return this.set(value);
            }
            else if (typeof property === "number"
                && typeof propertyKey === "number") {
                const indicatorId = property;
                const propertyId = propertyKey;
                const expectedType = getIndicatorMetadata(this.applHost.configManager, indicatorId, propertyId).type;
                // V2+ value
                if (typeof value !== expectedType) {
                    (0, API_1.throwWrongValueType)(this.ccId, property, expectedType, typeof value);
                }
                return this.set([
                    {
                        indicatorId: property,
                        propertyId: propertyKey,
                        value: value,
                    },
                ]);
            }
            else if (property === "identify") {
                if (typeof value !== "boolean") {
                    (0, API_1.throwWrongValueType)(this.ccId, property, "boolean", typeof value);
                }
                return this.identify();
            }
            else {
                (0, API_1.throwUnsupportedProperty)(this.ccId, property);
            }
        };
    }
    get [API_1.POLL_VALUE]() {
        return async function ({ property }) {
            if (property === "value")
                return this.get();
            if (typeof property === "number") {
                return this.get(property);
            }
            (0, API_1.throwUnsupportedProperty)(this.ccId, property);
        };
    }
    async get(indicatorId) {
        __assertType("indicatorId", "(optional) number", __assertType__optional_number.bind(void 0, indicatorId));
        this.assertSupportsCommand(_Types_1.IndicatorCommand, _Types_1.IndicatorCommand.Get);
        const cc = new IndicatorCCGet(this.applHost, {
            nodeId: this.endpoint.nodeId,
            endpoint: this.endpoint.index,
            indicatorId,
        });
        const response = await this.applHost.sendCommand(cc, this.commandOptions);
        if (!response)
            return;
        if (response.values)
            return response.values;
        return response.indicator0Value;
    }
    async set(value) {
        __assertType("value", undefined, __assertType__su__number_sa__5_ea_5_5_5_eu.bind(void 0, value));
        this.assertSupportsCommand(_Types_1.IndicatorCommand, _Types_1.IndicatorCommand.Set);
        const cc = new IndicatorCCSet(this.applHost, {
            nodeId: this.endpoint.nodeId,
            endpoint: this.endpoint.index,
            ...(typeof value === "number" ? { value } : { values: value }),
        });
        return this.applHost.sendCommand(cc, this.commandOptions);
    }
    async getSupported(indicatorId) {
        __assertType("indicatorId", "number", __assertType__number.bind(void 0, indicatorId));
        this.assertSupportsCommand(_Types_1.IndicatorCommand, _Types_1.IndicatorCommand.SupportedGet);
        const cc = new IndicatorCCSupportedGet(this.applHost, {
            nodeId: this.endpoint.nodeId,
            endpoint: this.endpoint.index,
            indicatorId,
        });
        const response = await this.applHost.sendCommand(cc, this.commandOptions);
        if (response) {
            return {
                // Include the actual indicator ID if 0x00 was requested
                ...(indicatorId === 0x00
                    ? { indicatorId: response.indicatorId }
                    : undefined),
                supportedProperties: response.supportedProperties,
                nextIndicatorId: response.nextIndicatorId,
            };
        }
    }
    async reportSupported(indicatorId, supportedProperties, nextIndicatorId) {
        __assertType("indicatorId", "number", __assertType__number.bind(void 0, indicatorId));
        __assertType("supportedProperties", undefined, __assertType__sa__number_ea_2.bind(void 0, supportedProperties));
        __assertType("nextIndicatorId", "number", __assertType__number.bind(void 0, nextIndicatorId));
        this.assertSupportsCommand(_Types_1.IndicatorCommand, _Types_1.IndicatorCommand.SupportedReport);
        const cc = new IndicatorCCSupportedReport(this.applHost, {
            nodeId: this.endpoint.nodeId,
            endpoint: this.endpoint.index,
            indicatorId,
            supportedProperties,
            nextIndicatorId,
        });
        await this.applHost.sendCommand(cc, this.commandOptions);
    }
    /**
     * Instructs the node to identify itself. Available starting with V3 of this CC.
     */
    async identify() {
        if (this.version < 3) {
            throw new safe_1.ZWaveError(`The identify command is only supported in Indicator CC version 3 and above`, safe_1.ZWaveErrorCodes.CC_NotSupported);
        }
        return this.set([
            {
                indicatorId: 0x50,
                propertyId: 0x03,
                value: 0x08,
            },
            {
                indicatorId: 0x50,
                propertyId: 0x04,
                value: 0x03,
            },
            {
                indicatorId: 0x50,
                propertyId: 0x05,
                value: 0x06,
            },
        ]);
    }
    /**
     * Set a timeout for a given indicator ID after which the indicator will be turned off.
     * @param timeout The timeout in one of the supported forms:
     * 	- a timeout string in the form `12h18m17.59s`. All parts (hours, minutes, seconds, hundredths) are optional, but must be specified in this order. An empty string will be treated like `undefined`.
     * 	- an object specifying the timeout parts. An empty object will be treated like `undefined`.
     * 	- `undefined` to disable the timeout.
     */
    async setTimeout(indicatorId, timeout) {
        __assertType("indicatorId", "number", __assertType__number.bind(void 0, indicatorId));
        __assertType("timeout", undefined, __assertType__su__undefined__string__3_eu.bind(void 0, timeout));
        this.assertPhysicalEndpoint(this.endpoint);
        if (this.version < 3) {
            throw new safe_1.ZWaveError(`The setTimeout command is only supported in Indicator CC version 3 and above`, safe_1.ZWaveErrorCodes.CC_NotSupported);
        }
        if (typeof timeout === "string") {
            if (timeout === "") {
                timeout = undefined;
            }
            else {
                const parsed = parseIndicatorTimeoutString(timeout);
                if (!parsed) {
                    throw new safe_1.ZWaveError(`The timeout string "${timeout}" is not valid`, safe_1.ZWaveErrorCodes.Argument_Invalid);
                }
                timeout = parsed;
            }
        }
        const supportedPropertyIDs = IndicatorCC.getSupportedPropertyIDsCached(this.applHost, this.endpoint, indicatorId);
        const objects = [];
        if (timeout) {
            const hours = timeout.hours ?? 0;
            const minutes = timeout.minutes ?? 0;
            const seconds = Math.floor(timeout.seconds ?? 0);
            const hundredths = Math.round(((timeout.seconds ?? 0) % 1) * 100);
            if (hours) {
                if (!supportedPropertyIDs?.includes(0x0a)) {
                    throw new safe_1.ZWaveError(`The indicator ${indicatorId} does not support setting the timeout in hours`, safe_1.ZWaveErrorCodes.Argument_Invalid);
                }
                objects.push({
                    indicatorId,
                    propertyId: 0x0a,
                    value: hours,
                });
            }
            if (minutes) {
                if (!supportedPropertyIDs?.includes(0x06)) {
                    throw new safe_1.ZWaveError(`The indicator ${indicatorId} does not support setting the timeout in minutes`, safe_1.ZWaveErrorCodes.Argument_Invalid);
                }
                objects.push({
                    indicatorId,
                    propertyId: 0x06,
                    value: minutes,
                });
            }
            if (seconds) {
                if (!supportedPropertyIDs?.includes(0x07)) {
                    throw new safe_1.ZWaveError(`The indicator ${indicatorId} does not support setting the timeout in seconds`, safe_1.ZWaveErrorCodes.Argument_Invalid);
                }
                objects.push({
                    indicatorId,
                    propertyId: 0x07,
                    value: seconds,
                });
            }
            if (hundredths) {
                if (!supportedPropertyIDs?.includes(0x08)) {
                    throw new safe_1.ZWaveError(`The indicator ${indicatorId} does not support setting the timeout in 1/100 seconds`, safe_1.ZWaveErrorCodes.Argument_Invalid);
                }
                objects.push({
                    indicatorId,
                    propertyId: 0x08,
                    value: hundredths,
                });
            }
        }
        if (!objects.length) {
            objects.push(...(supportedPropertyIDs ?? []).map((p) => ({
                indicatorId,
                propertyId: p,
                value: 0,
            })));
        }
        return this.set(objects);
    }
    /**
     * Returns the timeout after which the given indicator will be turned off.
     */
    async getTimeout(indicatorId) {
        __assertType("indicatorId", "number", __assertType__number.bind(void 0, indicatorId));
        const values = await this.get(indicatorId);
        if (!(0, typeguards_1.isArray)(values))
            return;
        return indicatorObjectsToTimeout(values);
    }
    async getDescription(indicatorId) {
        __assertType("indicatorId", "number", __assertType__number.bind(void 0, indicatorId));
        this.assertSupportsCommand(_Types_1.IndicatorCommand, _Types_1.IndicatorCommand.DescriptionGet);
        const cc = new IndicatorCCDescriptionGet(this.applHost, {
            nodeId: this.endpoint.nodeId,
            endpoint: this.endpoint.index,
            indicatorId,
        });
        const response = await this.applHost.sendCommand(cc, this.commandOptions);
        return response?.description;
    }
};
exports.IndicatorCCAPI = IndicatorCCAPI;
exports.IndicatorCCAPI = IndicatorCCAPI = __decorate([
    (0, CommandClassDecorators_1.API)(safe_1.CommandClasses.Indicator)
], IndicatorCCAPI);
let IndicatorCC = class IndicatorCC extends CommandClass_1.CommandClass {
    async interview(applHost) {
        const node = this.getNode(applHost);
        const endpoint = this.getEndpoint(applHost);
        const api = API_1.CCAPI.create(safe_1.CommandClasses.Indicator, applHost, endpoint).withOptions({
            priority: safe_1.MessagePriority.NodeQuery,
        });
        applHost.controllerLog.logNode(node.id, {
            endpoint: this.endpointIndex,
            message: `Interviewing ${this.ccName}...`,
            direction: "none",
        });
        if (this.version > 1) {
            applHost.controllerLog.logNode(node.id, {
                endpoint: this.endpointIndex,
                message: "scanning supported indicator IDs...",
                direction: "outbound",
            });
            // Query ID 0 to get the first supported ID
            let curId = 0x00;
            const supportedIndicatorIds = [];
            do {
                const supportedResponse = await api.getSupported(curId);
                if (!supportedResponse) {
                    applHost.controllerLog.logNode(node.id, {
                        endpoint: this.endpointIndex,
                        message: "Time out while scanning supported indicator IDs, skipping interview...",
                        level: "warn",
                    });
                    return;
                }
                supportedIndicatorIds.push(supportedResponse.indicatorId ?? curId);
                curId = supportedResponse.nextIndicatorId;
            } while (curId !== 0x00);
            // The IDs are not stored by the report CCs so store them here once we have all of them
            this.setValue(applHost, exports.IndicatorCCValues.supportedIndicatorIds, supportedIndicatorIds);
            const logMessage = `supported indicator IDs: ${supportedIndicatorIds.join(", ")}`;
            applHost.controllerLog.logNode(node.id, {
                endpoint: this.endpointIndex,
                message: logMessage,
                direction: "inbound",
            });
            if (this.version >= 4) {
                const manufacturerDefinedIndicatorIds = supportedIndicatorIds
                    .filter((id) => isManufacturerDefinedIndicator(id));
                if (manufacturerDefinedIndicatorIds.length > 0) {
                    applHost.controllerLog.logNode(node.id, {
                        endpoint: this.endpointIndex,
                        message: "retrieving description for manufacturer-defined indicator IDs...",
                        direction: "outbound",
                    });
                    for (const id of manufacturerDefinedIndicatorIds) {
                        await api.getDescription(id);
                    }
                }
            }
        }
        // Query current values
        await this.refreshValues(applHost);
        // Remember that the interview is complete
        this.setInterviewComplete(applHost, true);
    }
    async refreshValues(applHost) {
        const node = this.getNode(applHost);
        const endpoint = this.getEndpoint(applHost);
        const api = API_1.CCAPI.create(safe_1.CommandClasses.Indicator, applHost, endpoint).withOptions({
            priority: safe_1.MessagePriority.NodeQuery,
        });
        if (this.version === 1) {
            applHost.controllerLog.logNode(node.id, {
                endpoint: this.endpointIndex,
                message: "requesting current indicator value...",
                direction: "outbound",
            });
            await api.get();
        }
        else {
            const supportedIndicatorIds = this.getValue(applHost, exports.IndicatorCCValues.supportedIndicatorIds) ?? [];
            for (const indicatorId of supportedIndicatorIds) {
                applHost.controllerLog.logNode(node.id, {
                    endpoint: this.endpointIndex,
                    message: `requesting current indicator value (id = ${(0, safe_2.num2hex)(indicatorId)})...`,
                    direction: "outbound",
                });
                await api.get(indicatorId);
            }
        }
    }
    translatePropertyKey(applHost, property, propertyKey) {
        if (property === "value") {
            // CC version 1 only has a single value that doesn't need to be translated
            return undefined;
        }
        else if (typeof property === "number"
            && typeof propertyKey === "number") {
            // The indicator property is our property key
            const prop = applHost.configManager.lookupProperty(propertyKey);
            if (prop)
                return prop.label;
        }
        return super.translatePropertyKey(applHost, property, propertyKey);
    }
    translateProperty(applHost, property, propertyKey) {
        if (typeof property === "number" && typeof propertyKey === "number") {
            // The indicator corresponds to our property
            const label = applHost.configManager.lookupIndicator(property);
            if (label)
                return label;
        }
        return super.translateProperty(applHost, property, propertyKey);
    }
    supportsV2Indicators(applHost) {
        // First test if there are any indicator ids defined
        const supportedIndicatorIds = this.getValue(applHost, exports.IndicatorCCValues.supportedIndicatorIds);
        if (!supportedIndicatorIds?.length)
            return false;
        // Then test if there are any property ids defined
        return supportedIndicatorIds.some((indicatorId) => !!this.getValue(applHost, exports.IndicatorCCValues.supportedPropertyIDs(indicatorId))?.length);
    }
    static getSupportedPropertyIDsCached(applHost, endpoint, indicatorId) {
        return applHost
            .getValueDB(endpoint.nodeId)
            .getValue(exports.IndicatorCCValues.supportedPropertyIDs(indicatorId).endpoint(endpoint.index));
    }
};
exports.IndicatorCC = IndicatorCC;
exports.IndicatorCC = IndicatorCC = __decorate([
    (0, CommandClassDecorators_1.commandClass)(safe_1.CommandClasses.Indicator),
    (0, CommandClassDecorators_1.implementedVersion)(4),
    (0, CommandClassDecorators_1.ccValues)(exports.IndicatorCCValues)
], IndicatorCC);
let IndicatorCCSet = class IndicatorCCSet extends IndicatorCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, safe_1.validatePayload)(this.payload.length >= 1);
            const objCount = this.payload.length >= 2
                ? this.payload[1] & 0b11111
                : 0;
            if (objCount === 0) {
                this.indicator0Value = this.payload[0];
            }
            else {
                (0, safe_1.validatePayload)(this.payload.length >= 2 + 3 * objCount);
                this.values = [];
                for (let i = 0; i < objCount; i++) {
                    const offset = 2 + 3 * i;
                    const value = {
                        indicatorId: this.payload[offset],
                        propertyId: this.payload[offset + 1],
                        value: this.payload[offset + 2],
                    };
                    this.values.push(value);
                }
            }
        }
        else {
            if (this.version === 1) {
                if (!("value" in options)) {
                    throw new safe_1.ZWaveError(`Node ${this
                        .nodeId} only supports IndicatorCC V1 which requires a single value to be set`, safe_1.ZWaveErrorCodes.Argument_Invalid);
                }
                this.indicator0Value = options.value;
            }
            else {
                if ("value" in options) {
                    this.indicator0Value = options.value;
                }
                else {
                    if (options.values.length > MAX_INDICATOR_OBJECTS) {
                        throw new safe_1.ZWaveError(`Only ${MAX_INDICATOR_OBJECTS} indicator values can be set at a time!`, safe_1.ZWaveErrorCodes.Argument_Invalid);
                    }
                    this.values = options.values;
                }
            }
        }
    }
    indicator0Value;
    values;
    serialize() {
        if (this.values != undefined) {
            // V2+
            this.payload = Buffer.alloc(2 + 3 * this.values.length, 0);
            // Byte 0 is the legacy value
            const objCount = this.values.length & MAX_INDICATOR_OBJECTS;
            this.payload[1] = objCount;
            for (let i = 0; i < objCount; i++) {
                const offset = 2 + 3 * i;
                this.payload[offset] = this.values[i].indicatorId;
                this.payload[offset + 1] = this.values[i].propertyId;
                const value = this.values[i].value;
                this.payload[offset + 2] = value === true
                    ? 0xff
                    : value === false
                        ? 0x00
                        : value;
            }
        }
        else {
            // V1
            this.payload = Buffer.from([this.indicator0Value ?? 0]);
        }
        return super.serialize();
    }
    toLogEntry(applHost) {
        const message = {};
        if (this.indicator0Value != undefined) {
            message["indicator 0 value"] = this.indicator0Value;
        }
        if (this.values != undefined) {
            message.values = `${this.values
                .map((v) => `
· indicatorId: ${v.indicatorId}
  propertyId:  ${v.propertyId}
  value:       ${v.value}`)
                .join("")}`;
        }
        return {
            ...super.toLogEntry(applHost),
            message,
        };
    }
};
exports.IndicatorCCSet = IndicatorCCSet;
exports.IndicatorCCSet = IndicatorCCSet = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.IndicatorCommand.Set),
    (0, CommandClassDecorators_1.useSupervision)()
], IndicatorCCSet);
let IndicatorCCReport = class IndicatorCCReport extends IndicatorCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, safe_1.validatePayload)(this.payload.length >= 1);
            const objCount = this.payload.length >= 2
                ? this.payload[1] & 0b11111
                : 0;
            if (objCount === 0) {
                this.indicator0Value = this.payload[0];
            }
            else {
                (0, safe_1.validatePayload)(this.payload.length >= 2 + 3 * objCount);
                this.values = [];
                for (let i = 0; i < objCount; i++) {
                    const offset = 2 + 3 * i;
                    const value = {
                        indicatorId: this.payload[offset],
                        propertyId: this.payload[offset + 1],
                        value: this.payload[offset + 2],
                    };
                    this.values.push(value);
                }
                // TODO: Think if we want this:
                // // If not all Property IDs are included in the command for the actual Indicator ID,
                // // a controlling node MUST assume non-specified Property IDs values to be 0x00.
                // const indicatorId = this.values[0].indicatorId;
                // const supportedIndicatorProperties =
                // 	valueDB.getValue<number[]>(
                // 		getSupportedPropertyIDsValueID(
                // 			this.endpointIndex,
                // 			indicatorId,
                // 		),
                // 	) ?? [];
                // // Find out which ones are missing
                // const missingIndicatorProperties = supportedIndicatorProperties.filter(
                // 	prop =>
                // 		!this.values!.find(({ propertyId }) => prop === propertyId),
                // );
                // // And assume they are 0 (false)
                // for (const missing of missingIndicatorProperties) {
                // 	this.setIndicatorValue({
                // 		indicatorId,
                // 		propertyId: missing,
                // 		value: 0,
                // 	});
                // }
            }
        }
        else {
            if ("value" in options) {
                this.indicator0Value = options.value;
            }
            else if ("values" in options) {
                if (options.values.length > MAX_INDICATOR_OBJECTS) {
                    throw new safe_1.ZWaveError(`Only ${MAX_INDICATOR_OBJECTS} indicator values can be set at a time!`, safe_1.ZWaveErrorCodes.Argument_Invalid);
                }
                this.values = options.values;
            }
        }
    }
    persistValues(applHost) {
        if (!super.persistValues(applHost))
            return false;
        if (this.indicator0Value != undefined) {
            if (!this.supportsV2Indicators(applHost)) {
                // Publish the value
                const valueV1 = exports.IndicatorCCValues.valueV1;
                this.setMetadata(applHost, valueV1);
                this.setValue(applHost, valueV1, this.indicator0Value);
            }
            else {
                if (this.isSinglecast()) {
                    // Don't!
                    applHost.controllerLog.logNode(this.nodeId, {
                        message: `ignoring V1 indicator report because the node supports V2 indicators`,
                        direction: "none",
                        endpoint: this.endpointIndex,
                    });
                }
            }
        }
        else if (this.values) {
            // Store the simple values first
            for (const value of this.values) {
                this.setIndicatorValue(applHost, value);
            }
            // Then group values into the convenience properties
            // ... timeout
            const timeout = indicatorObjectsToTimeout(this.values);
            if (timeout) {
                let timeoutString = "";
                if (timeout?.hours)
                    timeoutString += `${timeout.hours}h`;
                if (timeout?.minutes)
                    timeoutString += `${timeout.minutes}m`;
                if (timeout?.seconds)
                    timeoutString += `${timeout.seconds}s`;
                this.setValue(applHost, exports.IndicatorCCValues.timeout, timeoutString);
            }
        }
        return true;
    }
    indicator0Value;
    values;
    setIndicatorValue(applHost, value) {
        // Manufacturer-defined indicators may need a custom label
        const overrideIndicatorLabel = isManufacturerDefinedIndicator(value.indicatorId)
            ? this.getValue(applHost, exports.IndicatorCCValues.indicatorDescription(value.indicatorId))
            : undefined;
        const metadata = getIndicatorMetadata(applHost.configManager, value.indicatorId, value.propertyId, overrideIndicatorLabel);
        // Some values need to be converted
        if (metadata.type === "boolean") {
            value.value = !!value.value;
        }
        // Publish the value
        const valueV2 = exports.IndicatorCCValues.valueV2(value.indicatorId, value.propertyId);
        this.setMetadata(applHost, valueV2, metadata);
        this.setValue(applHost, valueV2, value.value);
    }
    serialize() {
        if (this.values != undefined) {
            // V2+
            this.payload = Buffer.alloc(2 + 3 * this.values.length, 0);
            // Byte 0 is the legacy value
            const objCount = this.values.length & MAX_INDICATOR_OBJECTS;
            this.payload[1] = objCount;
            for (let i = 0; i < objCount; i++) {
                const offset = 2 + 3 * i;
                this.payload[offset] = this.values[i].indicatorId;
                this.payload[offset + 1] = this.values[i].propertyId;
                const value = this.values[i].value;
                this.payload[offset + 2] = value === true
                    ? 0xff
                    : value === false
                        ? 0x00
                        : value;
            }
        }
        else {
            // V1
            this.payload = Buffer.from([this.indicator0Value ?? 0]);
        }
        return super.serialize();
    }
    toLogEntry(applHost) {
        const message = {};
        if (this.indicator0Value != undefined) {
            message["indicator 0 value"] = this.indicator0Value;
        }
        if (this.values != undefined) {
            message.values = `${this.values
                .map((v) => `
· indicatorId: ${v.indicatorId}
  propertyId:  ${v.propertyId}
  value:       ${v.value}`)
                .join("")}`;
        }
        return {
            ...super.toLogEntry(applHost),
            message,
        };
    }
};
exports.IndicatorCCReport = IndicatorCCReport;
exports.IndicatorCCReport = IndicatorCCReport = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.IndicatorCommand.Report)
], IndicatorCCReport);
let IndicatorCCGet = class IndicatorCCGet extends IndicatorCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            if (this.payload.length > 0) {
                this.indicatorId = this.payload[0];
            }
        }
        else {
            this.indicatorId = options.indicatorId;
        }
    }
    indicatorId;
    serialize() {
        if (this.indicatorId != undefined) {
            this.payload = Buffer.from([this.indicatorId]);
        }
        return super.serialize();
    }
    toLogEntry(applHost) {
        return {
            ...super.toLogEntry(applHost),
            message: {
                indicator: getIndicatorName(applHost.configManager, this.indicatorId),
            },
        };
    }
};
exports.IndicatorCCGet = IndicatorCCGet;
exports.IndicatorCCGet = IndicatorCCGet = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.IndicatorCommand.Get),
    (0, CommandClassDecorators_1.expectedCCResponse)(IndicatorCCReport)
], IndicatorCCGet);
let IndicatorCCSupportedReport = class IndicatorCCSupportedReport extends IndicatorCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, safe_1.validatePayload)(this.payload.length >= 3);
            this.indicatorId = this.payload[0];
            this.nextIndicatorId = this.payload[1];
            const bitMaskLength = this.payload[2] & 0b11111;
            if (bitMaskLength === 0) {
                this.supportedProperties = [];
            }
            else {
                (0, safe_1.validatePayload)(this.payload.length >= 3 + bitMaskLength);
                // The bit mask starts at 0, but bit 0 is not used
                this.supportedProperties = (0, safe_1.parseBitMask)(this.payload.subarray(3, 3 + bitMaskLength), 0).filter((v) => v !== 0);
            }
        }
        else {
            this.indicatorId = options.indicatorId;
            this.nextIndicatorId = options.nextIndicatorId;
            this.supportedProperties = options.supportedProperties;
        }
    }
    persistValues(applHost) {
        if (!super.persistValues(applHost))
            return false;
        if (this.indicatorId !== 0x00) {
            // Remember which property IDs are supported
            this.setValue(applHost, exports.IndicatorCCValues.supportedPropertyIDs(this.indicatorId), this.supportedProperties);
        }
        return true;
    }
    indicatorId;
    nextIndicatorId;
    supportedProperties;
    serialize() {
        const bitmask = this.supportedProperties.length > 0
            ? (0, safe_1.encodeBitMask)(this.supportedProperties, undefined, 0)
            : Buffer.from([]);
        this.payload = Buffer.concat([
            Buffer.from([
                this.indicatorId,
                this.nextIndicatorId,
                bitmask.length,
            ]),
            bitmask,
        ]);
        return super.serialize();
    }
    toLogEntry(applHost) {
        return {
            ...super.toLogEntry(applHost),
            message: {
                indicator: getIndicatorName(applHost.configManager, this.indicatorId),
                "supported properties": `${this.supportedProperties
                    .map((id) => applHost.configManager.lookupProperty(id)?.label
                    ?? `Unknown (${(0, safe_2.num2hex)(id)})`)
                    .join(", ")}`,
                "next indicator": getIndicatorName(applHost.configManager, this.nextIndicatorId),
            },
        };
    }
};
exports.IndicatorCCSupportedReport = IndicatorCCSupportedReport;
exports.IndicatorCCSupportedReport = IndicatorCCSupportedReport = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.IndicatorCommand.SupportedReport)
], IndicatorCCSupportedReport);
function testResponseForIndicatorSupportedGet(sent, received) {
    return sent.indicatorId === 0 || received.indicatorId === sent.indicatorId;
}
let IndicatorCCSupportedGet = class IndicatorCCSupportedGet extends IndicatorCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, safe_1.validatePayload)(this.payload.length >= 1);
            this.indicatorId = this.payload[0];
        }
        else {
            this.indicatorId = options.indicatorId;
        }
    }
    indicatorId;
    serialize() {
        this.payload = Buffer.from([this.indicatorId]);
        return super.serialize();
    }
    toLogEntry(applHost) {
        return {
            ...super.toLogEntry(applHost),
            message: {
                indicator: getIndicatorName(applHost.configManager, this.indicatorId),
            },
        };
    }
};
exports.IndicatorCCSupportedGet = IndicatorCCSupportedGet;
exports.IndicatorCCSupportedGet = IndicatorCCSupportedGet = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.IndicatorCommand.SupportedGet),
    (0, CommandClassDecorators_1.expectedCCResponse)(IndicatorCCSupportedReport, testResponseForIndicatorSupportedGet)
], IndicatorCCSupportedGet);
let IndicatorCCDescriptionReport = class IndicatorCCDescriptionReport extends IndicatorCC {
    constructor(host, options) {
        super(host, options);
        (0, safe_1.validatePayload)(this.payload.length >= 2);
        this.indicatorId = this.payload[0];
        const descrptionLength = this.payload[1];
        (0, safe_1.validatePayload)(this.payload.length >= 2 + descrptionLength);
        this.description = this.payload
            .subarray(2, 2 + descrptionLength)
            .toString("utf8");
    }
    indicatorId;
    description;
    persistValues(applHost) {
        if (!super.persistValues(applHost))
            return false;
        if (this.description) {
            this.setValue(applHost, exports.IndicatorCCValues.indicatorDescription(this.indicatorId), this.description);
        }
        return true;
    }
    toLogEntry(applHost) {
        return {
            ...super.toLogEntry(applHost),
            message: {
                "indicator ID": this.indicatorId,
                description: this.description || "(none)",
            },
        };
    }
};
exports.IndicatorCCDescriptionReport = IndicatorCCDescriptionReport;
exports.IndicatorCCDescriptionReport = IndicatorCCDescriptionReport = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.IndicatorCommand.DescriptionReport)
], IndicatorCCDescriptionReport);
function testResponseForIndicatorDescriptionGet(sent, received) {
    return received.indicatorId === sent.indicatorId;
}
let IndicatorCCDescriptionGet = class IndicatorCCDescriptionGet extends IndicatorCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, safe_1.validatePayload)(this.payload.length >= 1);
            this.indicatorId = this.payload[0];
        }
        else {
            this.indicatorId = options.indicatorId;
            if (!isManufacturerDefinedIndicator(this.indicatorId)) {
                throw new safe_1.ZWaveError("The indicator ID must be between 0x80 and 0x9f", safe_1.ZWaveErrorCodes.Argument_Invalid);
            }
        }
    }
    indicatorId;
    serialize() {
        this.payload = Buffer.from([this.indicatorId]);
        return super.serialize();
    }
    toLogEntry(applHost) {
        return {
            ...super.toLogEntry(applHost),
            message: {
                "indicator ID": this.indicatorId,
            },
        };
    }
};
exports.IndicatorCCDescriptionGet = IndicatorCCDescriptionGet;
exports.IndicatorCCDescriptionGet = IndicatorCCDescriptionGet = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.IndicatorCommand.DescriptionGet),
    (0, CommandClassDecorators_1.expectedCCResponse)(IndicatorCCDescriptionReport, testResponseForIndicatorDescriptionGet)
], IndicatorCCDescriptionGet);
//# sourceMappingURL=IndicatorCC.js.map