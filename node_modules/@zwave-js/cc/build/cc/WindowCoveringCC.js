"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WindowCoveringCCStopLevelChange = exports.WindowCoveringCCStartLevelChange = exports.WindowCoveringCCSet = exports.WindowCoveringCCGet = exports.WindowCoveringCCReport = exports.WindowCoveringCCSupportedGet = exports.WindowCoveringCCSupportedReport = exports.WindowCoveringCC = exports.WindowCoveringCCAPI = exports.WindowCoveringCCValues = void 0;
function __assertType(argName, typeName, boundHasError) {
    const { ZWaveError, ZWaveErrorCodes } = require("@zwave-js/core");
    if (boundHasError()) {
        throw new ZWaveError(typeName ? `${argName} is not a ${typeName}` : `${argName} has the wrong type`, ZWaveErrorCodes.Argument_Invalid);
    }
}
const __assertType__WindowCoveringParameter = $o => {
    function su__1__2__3__4__5__6__7__8__9__10__11__12__13__14__15__16__17__18__19__20__21__22__23__24_eu($o) {
        return ![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23].includes($o) ? {} : null;
    }
    return su__1__2__3__4__5__6__7__8__9__10__11__12__13__14__15__16__17__18__19__20__21__22__23__24_eu($o);
};
const __assertType__sa__2_ea_2 = $o => {
    function su__4__5__6__7__8__9__10__11__12__13__14__15__16__17__18__19__20__21__22__23__24__25__26__27_eu($o) {
        return ![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23].includes($o) ? {} : null;
    }
    function _number($o) {
        return typeof $o !== "number" ? {} : null;
    }
    function _2($o) {
        if (typeof $o !== "object" || $o === null || Array.isArray($o))
            return {};
        if ("parameter" in $o && $o["parameter"] !== undefined) {
            const error = su__4__5__6__7__8__9__10__11__12__13__14__15__16__17__18__19__20__21__22__23__24__25__26__27_eu($o["parameter"]);
            if (error)
                return error;
        }
        else
            return {};
        if ("value" in $o && $o["value"] !== undefined) {
            const error = _number($o["value"]);
            if (error)
                return error;
        }
        else
            return {};
        return null;
    }
    function sa__2_ea_2($o) {
        if (!Array.isArray($o))
            return {};
        for (let i = 0; i < $o.length; i++) {
            const error = _2($o[i]);
            if (error)
                return error;
        }
        return null;
    }
    return sa__2_ea_2($o);
};
const __assertType__optional_su__string__2_eu = $o => {
    function _string($o) {
        return typeof $o !== "string" ? {} : null;
    }
    function _2($o) {
        return !($o instanceof require("@zwave-js/core").Duration) ? {} : null;
    }
    function su__string__2_eu($o) {
        const conditions = [_string, _2];
        for (const condition of conditions) {
            const error = condition($o);
            if (!error)
                return null;
        }
        return {};
    }
    function optional_su__string__2_eu($o) {
        if ($o !== undefined) {
            const error = su__string__2_eu($o);
            if (error)
                return error;
        }
        return null;
    }
    return optional_su__string__2_eu($o);
};
const __assertType__su__1__2_eu = $o => {
    function _1($o) {
        return $o !== "up" ? {} : null;
    }
    function _2($o) {
        return $o !== "down" ? {} : null;
    }
    function su__1__2_eu($o) {
        const conditions = [_1, _2];
        for (const condition of conditions) {
            const error = condition($o);
            if (!error)
                return null;
        }
        return {};
    }
    return su__1__2_eu($o);
};
const core_1 = require("@zwave-js/core");
const safe_1 = require("@zwave-js/shared/safe");
const API_1 = require("../lib/API");
const CommandClass_1 = require("../lib/CommandClass");
const CommandClassDecorators_1 = require("../lib/CommandClassDecorators");
const Values_1 = require("../lib/Values");
const _Types_1 = require("../lib/_Types");
function parameterToMetadataStates(parameter) {
    switch (parameter) {
        case _Types_1.WindowCoveringParameter["Vertical Slats Angle (no position)"]:
        case _Types_1.WindowCoveringParameter["Vertical Slats Angle"]:
            return {
                0: "Closed (right inside)",
                50: "Open",
                99: "Closed (left inside)",
            };
        case _Types_1.WindowCoveringParameter["Horizontal Slats Angle (no position)"]:
        case _Types_1.WindowCoveringParameter["Horizontal Slats Angle"]:
            return {
                0: "Closed (up inside)",
                50: "Open",
                99: "Closed (down inside)",
            };
    }
    return {
        0: "Closed",
        99: "Open",
    };
}
function parameterToLevelChangeLabel(parameter, direction) {
    switch (parameter) {
        // For angle control, both directions are closed, so we specify it explicitly
        case _Types_1.WindowCoveringParameter["Vertical Slats Angle (no position)"]:
        case _Types_1.WindowCoveringParameter["Vertical Slats Angle"]:
            return `Change tilt (${direction === "up" ? "left inside" : "right inside"})`;
        case _Types_1.WindowCoveringParameter["Horizontal Slats Angle (no position)"]:
        case _Types_1.WindowCoveringParameter["Horizontal Slats Angle"]:
            // Horizontal slats refer to the position of the inner side of the slats
            // where a high level (99) actually means they face down
            return `Change tilt (${direction === "up" ? "down inside" : "up inside"})`;
    }
    // For all other parameters, refer to the amount of light that is let in
    return direction === "up" ? "Open" : "Close";
}
exports.WindowCoveringCCValues = Object.freeze({
    ...Values_1.V.defineStaticCCValues(core_1.CommandClasses["Window Covering"], {
        ...Values_1.V.staticProperty("supportedParameters", undefined, // meta
        { internal: true }),
    }),
    ...Values_1.V.defineDynamicCCValues(core_1.CommandClasses["Window Covering"], {
        ...Values_1.V.dynamicPropertyAndKeyWithName("currentValue", "currentValue", (parameter) => parameter, ({ property, propertyKey }) => property === "currentValue" && typeof propertyKey === "number", (parameter) => {
            return {
                ...core_1.ValueMetadata.ReadOnlyLevel,
                label: `Current value - ${(0, safe_1.getEnumMemberName)(_Types_1.WindowCoveringParameter, parameter)}`,
                states: parameterToMetadataStates(parameter),
                ccSpecific: { parameter },
            };
        }),
        ...Values_1.V.dynamicPropertyAndKeyWithName("targetValue", "targetValue", (parameter) => parameter, ({ property, propertyKey }) => property === "targetValue" && typeof propertyKey === "number", (parameter) => {
            // Only odd-numbered parameters have position support and are writable
            const writeable = parameter % 2 === 1;
            return {
                ...core_1.ValueMetadata.Level,
                label: `Target value - ${(0, safe_1.getEnumMemberName)(_Types_1.WindowCoveringParameter, parameter)}`,
                // Only odd-numbered parameters have position support and are writable
                writeable: parameter % 2 === 1,
                states: parameterToMetadataStates(parameter),
                allowManualEntry: writeable,
                ccSpecific: { parameter },
                valueChangeOptions: ["transitionDuration"],
            };
        }),
        ...Values_1.V.dynamicPropertyAndKeyWithName("duration", "duration", (parameter) => parameter, ({ property, propertyKey }) => property === "duration" && typeof propertyKey === "number", (parameter) => ({
            ...core_1.ValueMetadata.ReadOnlyDuration,
            label: `Remaining duration - ${(0, safe_1.getEnumMemberName)(_Types_1.WindowCoveringParameter, parameter)}`,
            ccSpecific: {
                parameter,
            },
        })),
        ...Values_1.V.dynamicPropertyAndKeyWithName("levelChangeUp", 
        // The direction refers to the change in level, not the physical location
        "levelChangeUp", (parameter) => parameter, ({ property, propertyKey }) => property === "levelChangeUp" && typeof propertyKey === "number", (parameter) => {
            return {
                ...core_1.ValueMetadata.WriteOnlyBoolean,
                label: `${parameterToLevelChangeLabel(parameter, "up")} - ${(0, safe_1.getEnumMemberName)(_Types_1.WindowCoveringParameter, parameter)}`,
                valueChangeOptions: ["transitionDuration"],
                states: {
                    true: "Start",
                    false: "Stop",
                },
                ccSpecific: { parameter },
            };
        }),
        ...Values_1.V.dynamicPropertyAndKeyWithName("levelChangeDown", 
        // The direction refers to the change in level, not the physical location
        "levelChangeDown", (parameter) => parameter, ({ property, propertyKey }) => property === "levelChangeDown"
            && typeof propertyKey === "number", (parameter) => {
            return {
                ...core_1.ValueMetadata.WriteOnlyBoolean,
                label: `${parameterToLevelChangeLabel(parameter, "down")} - ${(0, safe_1.getEnumMemberName)(_Types_1.WindowCoveringParameter, parameter)}`,
                valueChangeOptions: ["transitionDuration"],
                states: {
                    true: "Start",
                    false: "Stop",
                },
                ccSpecific: { parameter },
            };
        }),
    }),
});
let WindowCoveringCCAPI = class WindowCoveringCCAPI extends API_1.CCAPI {
    supportsCommand(cmd) {
        switch (cmd) {
            case _Types_1.WindowCoveringCommand.Get:
            case _Types_1.WindowCoveringCommand.Set:
            case _Types_1.WindowCoveringCommand.SupportedGet:
            case _Types_1.WindowCoveringCommand.StartLevelChange:
            case _Types_1.WindowCoveringCommand.StopLevelChange:
                return true; // This is mandatory
        }
        return super.supportsCommand(cmd);
    }
    get [API_1.SET_VALUE]() {
        return async function ({ property, propertyKey }, value, options) {
            const valueId = {
                commandClass: this.ccId,
                property,
                propertyKey,
            };
            if (exports.WindowCoveringCCValues.targetValue.is(valueId)) {
                if (typeof propertyKey !== "number"
                    // Only odd-numbered parameters have position support and are writable
                    || propertyKey % 2 === 0) {
                    (0, API_1.throwUnsupportedPropertyKey)(this.ccId, property, propertyKey);
                }
                if (typeof value !== "number") {
                    (0, API_1.throwWrongValueType)(this.ccId, property, "number", typeof value);
                }
                const parameter = propertyKey;
                const duration = core_1.Duration.from(options?.transitionDuration);
                return this.set([{ parameter, value }], duration);
            }
            else if (exports.WindowCoveringCCValues.levelChangeUp.is(valueId)
                || exports.WindowCoveringCCValues.levelChangeDown.is(valueId)) {
                if (typeof value !== "boolean") {
                    (0, API_1.throwWrongValueType)(this.ccId, property, "boolean", typeof value);
                }
                const parameter = propertyKey;
                const direction = exports.WindowCoveringCCValues.levelChangeUp.is(valueId)
                    ? "up"
                    : "down";
                if (value) {
                    // Perform the level change
                    const duration = core_1.Duration.from(options?.transitionDuration);
                    return this.startLevelChange(parameter, direction, duration);
                }
                else {
                    return this.stopLevelChange(parameter);
                }
            }
            else {
                (0, API_1.throwUnsupportedProperty)(this.ccId, property);
            }
        };
    }
    [API_1.SET_VALUE_HOOKS] = ({ property, propertyKey }, value, options) => {
        const valueId = {
            commandClass: this.ccId,
            property,
            propertyKey,
        };
        if (exports.WindowCoveringCCValues.targetValue.is(valueId)) {
            if (typeof propertyKey !== "number")
                return;
            const parameter = propertyKey;
            const duration = core_1.Duration.from(options?.transitionDuration);
            const currentValueValueId = exports.WindowCoveringCCValues.currentValue(parameter).endpoint(this.endpoint.index);
            return {
                // Window Covering commands may take some time to be executed.
                // Therefore we try to supervise the command execution and delay the
                // optimistic update until the final result is received.
                supervisionDelayedUpdates: true,
                supervisionOnSuccess: async () => {
                    // Only update currentValue for valid target values
                    if (typeof value === "number"
                        && value >= 0
                        && value <= 99) {
                        this.tryGetValueDB()?.setValue(currentValueValueId, value);
                    }
                    else if (value === 255) {
                        // We don't know the status now, so refresh the current value
                        try {
                            await this.get(parameter);
                        }
                        catch {
                            // ignore
                        }
                    }
                },
                supervisionOnFailure: async () => {
                    // The transition failed, so now we don't know the status - refresh the current value
                    try {
                        await this.get(parameter);
                    }
                    catch {
                        // ignore
                    }
                },
                optimisticallyUpdateRelatedValues: (_supervisedAndSuccessful) => {
                    // Only update currentValue for valid target values
                    if (typeof value === "number"
                        && value >= 0
                        && value <= 99) {
                        if (this.isSinglecast()) {
                            this.tryGetValueDB()?.setValue(currentValueValueId, value);
                        }
                        else if (this.isMulticast()) {
                            // Figure out which nodes were affected by this command
                            const affectedNodes = this.endpoint.node
                                .physicalNodes.filter((node) => node
                                .getEndpoint(this.endpoint.index)
                                ?.supportsCC(this.ccId));
                            // and optimistically update the currentValue
                            for (const node of affectedNodes) {
                                this.applHost
                                    .tryGetValueDB(node.id)
                                    ?.setValue(currentValueValueId, value);
                            }
                        }
                    }
                },
                verifyChanges: () => {
                    if (this.isSinglecast()) {
                        // We query currentValue instead of targetValue to make sure that unsolicited updates cancel the scheduled poll
                        this.schedulePoll(currentValueValueId, value, {
                            duration,
                        });
                    }
                    else {
                        // For multicasts, do not schedule a refresh - this could cause a LOT of traffic
                    }
                },
            };
        }
    };
    get [API_1.POLL_VALUE]() {
        return async function ({ property, propertyKey }) {
            switch (property) {
                case "currentValue":
                case "targetValue":
                case "duration":
                    if (propertyKey == undefined) {
                        (0, API_1.throwMissingPropertyKey)(this.ccId, property);
                    }
                    else if (typeof propertyKey !== "number") {
                        (0, API_1.throwUnsupportedPropertyKey)(this.ccId, property, propertyKey);
                    }
                    return (await this.get(propertyKey))?.[property];
                default:
                    (0, API_1.throwUnsupportedProperty)(this.ccId, property);
            }
        };
    }
    async getSupported() {
        this.assertSupportsCommand(_Types_1.WindowCoveringCommand, _Types_1.WindowCoveringCommand.SupportedGet);
        const cc = new WindowCoveringCCSupportedGet(this.applHost, {
            nodeId: this.endpoint.nodeId,
            endpoint: this.endpoint.index,
        });
        const response = await this.applHost.sendCommand(cc, this.commandOptions);
        return response?.supportedParameters;
    }
    async get(parameter) {
        __assertType("parameter", "WindowCoveringParameter", __assertType__WindowCoveringParameter.bind(void 0, parameter));
        this.assertSupportsCommand(_Types_1.WindowCoveringCommand, _Types_1.WindowCoveringCommand.Get);
        const cc = new WindowCoveringCCGet(this.applHost, {
            nodeId: this.endpoint.nodeId,
            endpoint: this.endpoint.index,
            parameter,
        });
        const response = await this.applHost.sendCommand(cc, this.commandOptions);
        if (response) {
            return (0, safe_1.pick)(response, ["currentValue", "targetValue", "duration"]);
        }
    }
    async set(targetValues, duration) {
        __assertType("targetValues", undefined, __assertType__sa__2_ea_2.bind(void 0, targetValues));
        __assertType("duration", undefined, __assertType__optional_su__string__2_eu.bind(void 0, duration));
        this.assertSupportsCommand(_Types_1.WindowCoveringCommand, _Types_1.WindowCoveringCommand.StartLevelChange);
        const cc = new WindowCoveringCCSet(this.applHost, {
            nodeId: this.endpoint.nodeId,
            endpoint: this.endpoint.index,
            targetValues,
            duration,
        });
        return this.applHost.sendCommand(cc, this.commandOptions);
    }
    async startLevelChange(parameter, direction, duration) {
        __assertType("parameter", "WindowCoveringParameter", __assertType__WindowCoveringParameter.bind(void 0, parameter));
        __assertType("direction", undefined, __assertType__su__1__2_eu.bind(void 0, direction));
        __assertType("duration", undefined, __assertType__optional_su__string__2_eu.bind(void 0, duration));
        this.assertSupportsCommand(_Types_1.WindowCoveringCommand, _Types_1.WindowCoveringCommand.StartLevelChange);
        const cc = new WindowCoveringCCStartLevelChange(this.applHost, {
            nodeId: this.endpoint.nodeId,
            endpoint: this.endpoint.index,
            parameter,
            direction,
            duration,
        });
        return this.applHost.sendCommand(cc, this.commandOptions);
    }
    async stopLevelChange(parameter) {
        __assertType("parameter", "WindowCoveringParameter", __assertType__WindowCoveringParameter.bind(void 0, parameter));
        this.assertSupportsCommand(_Types_1.WindowCoveringCommand, _Types_1.WindowCoveringCommand.StopLevelChange);
        const cc = new WindowCoveringCCStopLevelChange(this.applHost, {
            nodeId: this.endpoint.nodeId,
            endpoint: this.endpoint.index,
            parameter,
        });
        return this.applHost.sendCommand(cc, this.commandOptions);
    }
};
exports.WindowCoveringCCAPI = WindowCoveringCCAPI;
exports.WindowCoveringCCAPI = WindowCoveringCCAPI = __decorate([
    (0, CommandClassDecorators_1.API)(core_1.CommandClasses["Window Covering"])
], WindowCoveringCCAPI);
let WindowCoveringCC = class WindowCoveringCC extends CommandClass_1.CommandClass {
    async interview(applHost) {
        const node = this.getNode(applHost);
        const endpoint = this.getEndpoint(applHost);
        const api = API_1.CCAPI.create(core_1.CommandClasses["Window Covering"], applHost, endpoint).withOptions({
            priority: core_1.MessagePriority.NodeQuery,
        });
        applHost.controllerLog.logNode(node.id, {
            endpoint: this.endpointIndex,
            message: `Interviewing ${this.ccName}...`,
            direction: "none",
        });
        applHost.controllerLog.logNode(node.id, {
            endpoint: this.endpointIndex,
            message: "querying supported window covering parameters...",
            direction: "outbound",
        });
        const supported = await api.getSupported();
        if (supported?.length) {
            const logMessage = `supported window covering parameters:
${supported
                .map((p) => `· ${(0, safe_1.getEnumMemberName)(_Types_1.WindowCoveringParameter, p)}`)
                .join("\n")}`;
            applHost.controllerLog.logNode(node.id, {
                endpoint: this.endpointIndex,
                message: logMessage,
                direction: "inbound",
            });
            // Create metadata for all supported parameters
            for (const param of supported) {
                // Default values
                this.setMetadata(applHost, exports.WindowCoveringCCValues.currentValue(param));
                this.setMetadata(applHost, exports.WindowCoveringCCValues.targetValue(param));
                this.setMetadata(applHost, exports.WindowCoveringCCValues.duration(param));
                // Level change values
                this.setMetadata(applHost, exports.WindowCoveringCCValues.levelChangeUp(param));
                this.setMetadata(applHost, exports.WindowCoveringCCValues.levelChangeDown(param));
                // And for the odd parameters (with position support), query the position
                if (param % 2 === 1) {
                    applHost.controllerLog.logNode(node.id, {
                        endpoint: this.endpointIndex,
                        message: `querying position for parameter ${(0, safe_1.getEnumMemberName)(_Types_1.WindowCoveringParameter, param)}...`,
                        direction: "outbound",
                    });
                    await api.get(param);
                }
            }
        }
        // Remember that the interview is complete
        this.setInterviewComplete(applHost, true);
    }
    translatePropertyKey(_applHost, _property, propertyKey) {
        if (typeof propertyKey === "number") {
            return (0, safe_1.getEnumMemberName)(_Types_1.WindowCoveringParameter, propertyKey);
        }
        return super.translatePropertyKey(_applHost, _property, propertyKey);
    }
};
exports.WindowCoveringCC = WindowCoveringCC;
exports.WindowCoveringCC = WindowCoveringCC = __decorate([
    (0, CommandClassDecorators_1.commandClass)(core_1.CommandClasses["Window Covering"]),
    (0, CommandClassDecorators_1.implementedVersion)(1),
    (0, CommandClassDecorators_1.ccValues)(exports.WindowCoveringCCValues)
], WindowCoveringCC);
let WindowCoveringCCSupportedReport = class WindowCoveringCCSupportedReport extends WindowCoveringCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 1);
            const numBitmaskBytes = this.payload[0] & 0b1111;
            (0, core_1.validatePayload)(this.payload.length >= 1 + numBitmaskBytes);
            const bitmask = this.payload.subarray(1, 1 + numBitmaskBytes);
            this.supportedParameters = (0, core_1.parseBitMask)(bitmask, _Types_1.WindowCoveringParameter["Outbound Left (no position)"]);
        }
        else {
            this.supportedParameters = options.supportedParameters;
        }
    }
    supportedParameters;
    serialize() {
        const bitmask = (0, core_1.encodeBitMask)(this.supportedParameters, undefined, _Types_1.WindowCoveringParameter["Outbound Left (no position)"]).subarray(0, 15);
        const numBitmaskBytes = bitmask.length & 0b1111;
        this.payload = Buffer.concat([
            Buffer.from([numBitmaskBytes]),
            bitmask.subarray(0, numBitmaskBytes),
        ]);
        return super.serialize();
    }
    toLogEntry(applHost) {
        return {
            ...super.toLogEntry(applHost),
            message: {
                "supported parameters": this.supportedParameters
                    .map((p) => `\n· ${(0, safe_1.getEnumMemberName)(_Types_1.WindowCoveringParameter, p)}`)
                    .join(""),
            },
        };
    }
};
exports.WindowCoveringCCSupportedReport = WindowCoveringCCSupportedReport;
__decorate([
    (0, CommandClassDecorators_1.ccValue)(exports.WindowCoveringCCValues.supportedParameters)
], WindowCoveringCCSupportedReport.prototype, "supportedParameters", void 0);
exports.WindowCoveringCCSupportedReport = WindowCoveringCCSupportedReport = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.WindowCoveringCommand.SupportedReport)
], WindowCoveringCCSupportedReport);
let WindowCoveringCCSupportedGet = class WindowCoveringCCSupportedGet extends WindowCoveringCC {
};
exports.WindowCoveringCCSupportedGet = WindowCoveringCCSupportedGet;
exports.WindowCoveringCCSupportedGet = WindowCoveringCCSupportedGet = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.WindowCoveringCommand.SupportedGet),
    (0, CommandClassDecorators_1.expectedCCResponse)(WindowCoveringCCSupportedReport)
], WindowCoveringCCSupportedGet);
let WindowCoveringCCReport = class WindowCoveringCCReport extends WindowCoveringCC {
    constructor(host, options) {
        super(host, options);
        (0, core_1.validatePayload)(this.payload.length >= 4);
        this.parameter = this.payload[0];
        this.currentValue = this.payload[1];
        this.targetValue = this.payload[2];
        this.duration = core_1.Duration.parseReport(this.payload[3])
            ?? core_1.Duration.unknown();
    }
    parameter;
    currentValue;
    targetValue;
    duration;
    toLogEntry(applHost) {
        return {
            ...super.toLogEntry(applHost),
            message: {
                parameter: (0, safe_1.getEnumMemberName)(_Types_1.WindowCoveringParameter, this.parameter),
                "current value": this.currentValue,
                "target value": this.targetValue,
                duration: this.duration.toString(),
            },
        };
    }
};
exports.WindowCoveringCCReport = WindowCoveringCCReport;
__decorate([
    (0, CommandClassDecorators_1.ccValue)(exports.WindowCoveringCCValues.currentValue, (self) => [self.parameter])
], WindowCoveringCCReport.prototype, "currentValue", void 0);
__decorate([
    (0, CommandClassDecorators_1.ccValue)(exports.WindowCoveringCCValues.targetValue, (self) => [self.parameter])
], WindowCoveringCCReport.prototype, "targetValue", void 0);
__decorate([
    (0, CommandClassDecorators_1.ccValue)(exports.WindowCoveringCCValues.duration, (self) => [self.parameter])
], WindowCoveringCCReport.prototype, "duration", void 0);
exports.WindowCoveringCCReport = WindowCoveringCCReport = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.WindowCoveringCommand.Report)
], WindowCoveringCCReport);
function testResponseForWindowCoveringGet(sent, received) {
    return received.parameter === sent.parameter;
}
let WindowCoveringCCGet = class WindowCoveringCCGet extends WindowCoveringCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 1);
            this.parameter = this.payload[0];
        }
        else {
            this.parameter = options.parameter;
        }
    }
    parameter;
    serialize() {
        this.payload = Buffer.from([this.parameter]);
        return super.serialize();
    }
    toLogEntry(applHost) {
        return {
            ...super.toLogEntry(applHost),
            message: {
                parameter: (0, safe_1.getEnumMemberName)(_Types_1.WindowCoveringParameter, this.parameter),
            },
        };
    }
};
exports.WindowCoveringCCGet = WindowCoveringCCGet;
exports.WindowCoveringCCGet = WindowCoveringCCGet = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.WindowCoveringCommand.Get),
    (0, CommandClassDecorators_1.expectedCCResponse)(WindowCoveringCCReport, testResponseForWindowCoveringGet)
], WindowCoveringCCGet);
let WindowCoveringCCSet = class WindowCoveringCCSet extends WindowCoveringCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            // TODO: Deserialize payload
            throw new core_1.ZWaveError(`${this.constructor.name}: deserialization not implemented`, core_1.ZWaveErrorCodes.Deserialization_NotImplemented);
        }
        else {
            this.targetValues = options.targetValues;
            this.duration = core_1.Duration.from(options.duration);
        }
    }
    targetValues;
    duration;
    serialize() {
        const numEntries = this.targetValues.length & 0b11111;
        this.payload = Buffer.allocUnsafe(2 + numEntries * 2);
        this.payload[0] = numEntries;
        for (let i = 0; i < numEntries; i++) {
            const offset = 1 + i * 2;
            this.payload[offset] = this.targetValues[i].parameter;
            this.payload[offset + 1] = this.targetValues[i].value;
        }
        this.payload[this.payload.length - 1] = (this.duration ?? core_1.Duration.default()).serializeSet();
        return super.serialize();
    }
    toLogEntry(applHost) {
        const message = {};
        for (const { parameter, value } of this.targetValues) {
            message[(0, safe_1.getEnumMemberName)(_Types_1.WindowCoveringParameter, parameter)] =
                value;
        }
        if (this.duration) {
            message.duration = this.duration.toString();
        }
        return {
            ...super.toLogEntry(applHost),
            message,
        };
    }
};
exports.WindowCoveringCCSet = WindowCoveringCCSet;
exports.WindowCoveringCCSet = WindowCoveringCCSet = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.WindowCoveringCommand.Set),
    (0, CommandClassDecorators_1.useSupervision)()
], WindowCoveringCCSet);
let WindowCoveringCCStartLevelChange = class WindowCoveringCCStartLevelChange extends WindowCoveringCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            // TODO: Deserialize payload
            throw new core_1.ZWaveError(`${this.constructor.name}: deserialization not implemented`, core_1.ZWaveErrorCodes.Deserialization_NotImplemented);
        }
        else {
            this.parameter = options.parameter;
            this.direction = options.direction;
            this.duration = core_1.Duration.from(options.duration);
        }
    }
    parameter;
    direction;
    duration;
    serialize() {
        this.payload = Buffer.from([
            this.direction === "up" ? 64 : 0,
            this.parameter,
            (this.duration ?? core_1.Duration.default()).serializeSet(),
        ]);
        return super.serialize();
    }
    toLogEntry(applHost) {
        const message = {
            parameter: (0, safe_1.getEnumMemberName)(_Types_1.WindowCoveringParameter, this.parameter),
            direction: this.direction,
        };
        if (this.duration) {
            message.duration = this.duration.toString();
        }
        return {
            ...super.toLogEntry(applHost),
            message,
        };
    }
};
exports.WindowCoveringCCStartLevelChange = WindowCoveringCCStartLevelChange;
exports.WindowCoveringCCStartLevelChange = WindowCoveringCCStartLevelChange = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.WindowCoveringCommand.StartLevelChange),
    (0, CommandClassDecorators_1.useSupervision)()
], WindowCoveringCCStartLevelChange);
let WindowCoveringCCStopLevelChange = class WindowCoveringCCStopLevelChange extends WindowCoveringCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            // TODO: Deserialize payload
            throw new core_1.ZWaveError(`${this.constructor.name}: deserialization not implemented`, core_1.ZWaveErrorCodes.Deserialization_NotImplemented);
        }
        else {
            this.parameter = options.parameter;
        }
    }
    parameter;
    serialize() {
        this.payload = Buffer.from([this.parameter]);
        return super.serialize();
    }
    toLogEntry(applHost) {
        return {
            ...super.toLogEntry(applHost),
            message: {
                parameter: (0, safe_1.getEnumMemberName)(_Types_1.WindowCoveringParameter, this.parameter),
            },
        };
    }
};
exports.WindowCoveringCCStopLevelChange = WindowCoveringCCStopLevelChange;
exports.WindowCoveringCCStopLevelChange = WindowCoveringCCStopLevelChange = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.WindowCoveringCommand.StopLevelChange),
    (0, CommandClassDecorators_1.useSupervision)()
], WindowCoveringCCStopLevelChange);
//# sourceMappingURL=WindowCoveringCC.js.map