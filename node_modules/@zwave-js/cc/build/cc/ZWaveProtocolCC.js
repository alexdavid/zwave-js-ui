"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZWaveProtocolCCSmartStartInclusionRequest = exports.ZWaveProtocolCCSmartStartPrime = exports.ZWaveProtocolCCSmartStartIncludedNodeInformation = exports.ZWaveProtocolCCAssignSUCReturnRoutePriority = exports.ZWaveProtocolCCAssignReturnRoutePriority = exports.ZWaveProtocolCCExcludeRequest = exports.ZWaveProtocolCCSetNWIMode = exports.ZWaveProtocolCCNodesExist = exports.ZWaveProtocolCCNodesExistReply = exports.ZWaveProtocolCCReserveNodeIDs = exports.ZWaveProtocolCCReservedIDs = exports.ZWaveProtocolCCNOPPower = exports.ZWaveProtocolCCAcceptLost = exports.ZWaveProtocolCCLost = exports.ZWaveProtocolCCStaticRouteRequest = exports.ZWaveProtocolCCAssignSUCReturnRoute = exports.ZWaveProtocolCCSetSUCAck = exports.ZWaveProtocolCCSetSUC = exports.ZWaveProtocolCCSUCNodeID = exports.ZWaveProtocolCCAutomaticControllerUpdateStart = exports.ZWaveProtocolCCTransferNewPrimaryControllerComplete = exports.ZWaveProtocolCCNewRangeRegistered = exports.ZWaveProtocolCCNewNodeRegistered = exports.ZWaveProtocolCCAssignReturnRoute = exports.ZWaveProtocolCCTransferEnd = exports.ZWaveProtocolCCTransferRangeInformation = exports.ZWaveProtocolCCTransferNodeInformation = exports.ZWaveProtocolCCTransferPresentation = exports.ZWaveProtocolCCCommandComplete = exports.ZWaveProtocolCCGetNodesInRange = exports.ZWaveProtocolCCRangeInfo = exports.ZWaveProtocolCCFindNodesInRange = exports.ZWaveProtocolCCAssignIDs = exports.ZWaveProtocolCCRequestNodeInformationFrame = exports.ZWaveProtocolCCNodeInformationFrame = exports.ZWaveProtocolCC = void 0;
const core_1 = require("@zwave-js/core");
const CommandClass_1 = require("../lib/CommandClass");
const CommandClassDecorators_1 = require("../lib/CommandClassDecorators");
const _Types_1 = require("../lib/_Types");
var DataRateBitmask;
(function (DataRateBitmask) {
    DataRateBitmask[DataRateBitmask["9k6"] = 1] = "9k6";
    DataRateBitmask[DataRateBitmask["40k"] = 2] = "40k";
    DataRateBitmask[DataRateBitmask["100k"] = 4] = "100k";
})(DataRateBitmask || (DataRateBitmask = {}));
function dataRate2Bitmask(dataRate) {
    return dataRate === core_1.ZWaveDataRate["100k"]
        ? DataRateBitmask["100k"]
        : dataRate === core_1.ZWaveDataRate["40k"]
            ? DataRateBitmask["40k"]
            : DataRateBitmask["9k6"];
}
function bitmask2DataRate(mask) {
    return mask === DataRateBitmask["100k"]
        ? core_1.ZWaveDataRate["100k"]
        : mask === DataRateBitmask["40k"]
            ? core_1.ZWaveDataRate["40k"]
            : core_1.ZWaveDataRate["9k6"];
}
let ZWaveProtocolCC = class ZWaveProtocolCC extends CommandClass_1.CommandClass {
};
exports.ZWaveProtocolCC = ZWaveProtocolCC;
exports.ZWaveProtocolCC = ZWaveProtocolCC = __decorate([
    (0, CommandClassDecorators_1.commandClass)(core_1.CommandClasses["Z-Wave Protocol"]),
    (0, CommandClassDecorators_1.implementedVersion)(1)
], ZWaveProtocolCC);
let ZWaveProtocolCCNodeInformationFrame = class ZWaveProtocolCCNodeInformationFrame extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        let nif;
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            nif = (0, core_1.parseNodeInformationFrame)(this.payload);
        }
        else {
            nif = options;
        }
        this.basicDeviceClass = nif.basicDeviceClass;
        this.genericDeviceClass = nif.genericDeviceClass;
        this.specificDeviceClass = nif.specificDeviceClass;
        this.isListening = nif.isListening;
        this.isFrequentListening = nif.isFrequentListening;
        this.isRouting = nif.isRouting;
        this.supportedDataRates = nif.supportedDataRates;
        this.protocolVersion = nif.protocolVersion;
        this.optionalFunctionality = nif.optionalFunctionality;
        this.nodeType = nif.nodeType;
        this.supportsSecurity = nif.supportsSecurity;
        this.supportsBeaming = nif.supportsBeaming;
        this.supportedCCs = nif.supportedCCs;
    }
    basicDeviceClass;
    genericDeviceClass;
    specificDeviceClass;
    isListening;
    isFrequentListening;
    isRouting;
    supportedDataRates;
    protocolVersion;
    optionalFunctionality;
    nodeType;
    supportsSecurity;
    supportsBeaming;
    supportedCCs;
    serialize() {
        this.payload = (0, core_1.encodeNodeInformationFrame)(this);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCNodeInformationFrame = ZWaveProtocolCCNodeInformationFrame;
exports.ZWaveProtocolCCNodeInformationFrame = ZWaveProtocolCCNodeInformationFrame = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.NodeInformationFrame)
], ZWaveProtocolCCNodeInformationFrame);
let ZWaveProtocolCCRequestNodeInformationFrame = class ZWaveProtocolCCRequestNodeInformationFrame extends ZWaveProtocolCC {
};
exports.ZWaveProtocolCCRequestNodeInformationFrame = ZWaveProtocolCCRequestNodeInformationFrame;
exports.ZWaveProtocolCCRequestNodeInformationFrame = ZWaveProtocolCCRequestNodeInformationFrame = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.RequestNodeInformationFrame),
    (0, CommandClassDecorators_1.expectedCCResponse)(ZWaveProtocolCCNodeInformationFrame)
], ZWaveProtocolCCRequestNodeInformationFrame);
let ZWaveProtocolCCAssignIDs = class ZWaveProtocolCCAssignIDs extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 5);
            this.assignedNodeId = this.payload[0];
            this.homeId = this.payload.readUInt32BE(1);
        }
        else {
            this.assignedNodeId = options.assignedNodeId;
            this.homeId = options.homeId;
        }
    }
    assignedNodeId;
    homeId;
    serialize() {
        this.payload = Buffer.allocUnsafe(5);
        this.payload[0] = this.assignedNodeId;
        this.payload.writeUInt32BE(this.homeId, 1);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCAssignIDs = ZWaveProtocolCCAssignIDs;
exports.ZWaveProtocolCCAssignIDs = ZWaveProtocolCCAssignIDs = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.AssignIDs)
], ZWaveProtocolCCAssignIDs);
let ZWaveProtocolCCFindNodesInRange = class ZWaveProtocolCCFindNodesInRange extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 1);
            const speedPresent = this.payload[0] & 128;
            const bitmaskLength = this.payload[0] & 31;
            (0, core_1.validatePayload)(this.payload.length >= 1 + bitmaskLength);
            this.candidateNodeIds = (0, core_1.parseBitMask)(this.payload.subarray(1, 1 + bitmaskLength));
            const rest = this.payload.subarray(1 + bitmaskLength);
            if (speedPresent) {
                (0, core_1.validatePayload)(rest.length >= 1);
                if (rest.length === 1) {
                    this.dataRate = rest[0] & 0b111;
                    this.wakeUpTime = _Types_1.WakeUpTime.None;
                }
                else if (rest.length === 2) {
                    this.wakeUpTime = (0, _Types_1.parseWakeUpTime)(rest[0]);
                    this.dataRate = rest[1] & 0b111;
                }
                else {
                    throw core_1.validatePayload.fail("Invalid payload length");
                }
            }
            else if (rest.length >= 1) {
                this.wakeUpTime = (0, _Types_1.parseWakeUpTime)(rest[0]);
                this.dataRate = core_1.ZWaveDataRate["9k6"];
            }
            else {
                this.wakeUpTime = _Types_1.WakeUpTime.None;
                this.dataRate = core_1.ZWaveDataRate["9k6"];
            }
        }
        else {
            this.candidateNodeIds = options.candidateNodeIds;
            this.wakeUpTime = options.wakeUpTime;
            this.dataRate = options.dataRate ?? core_1.ZWaveDataRate["9k6"];
        }
    }
    candidateNodeIds;
    wakeUpTime;
    dataRate;
    serialize() {
        const nodesBitmask = (0, core_1.encodeBitMask)(this.candidateNodeIds, core_1.MAX_NODES);
        const speedAndLength = 128 | nodesBitmask.length;
        this.payload = Buffer.concat([
            Buffer.from([speedAndLength]),
            nodesBitmask,
            Buffer.from([this.wakeUpTime, this.dataRate]),
        ]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCFindNodesInRange = ZWaveProtocolCCFindNodesInRange;
exports.ZWaveProtocolCCFindNodesInRange = ZWaveProtocolCCFindNodesInRange = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.FindNodesInRange)
], ZWaveProtocolCCFindNodesInRange);
let ZWaveProtocolCCRangeInfo = class ZWaveProtocolCCRangeInfo extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 1);
            const bitmaskLength = this.payload[0] & 31;
            (0, core_1.validatePayload)(this.payload.length >= 1 + bitmaskLength);
            this.neighborNodeIds = (0, core_1.parseBitMask)(this.payload.subarray(1, 1 + bitmaskLength));
            if (this.payload.length >= 2 + bitmaskLength) {
                this.wakeUpTime = (0, _Types_1.parseWakeUpTime)(this.payload[1 + bitmaskLength]);
            }
        }
        else {
            this.neighborNodeIds = options.neighborNodeIds;
            this.wakeUpTime = options.wakeUpTime;
        }
    }
    neighborNodeIds;
    wakeUpTime;
    serialize() {
        const nodesBitmask = (0, core_1.encodeBitMask)(this.neighborNodeIds, core_1.MAX_NODES);
        this.payload = Buffer.concat([
            Buffer.from([nodesBitmask.length]),
            nodesBitmask,
            this.wakeUpTime != undefined
                ? Buffer.from([this.wakeUpTime])
                : Buffer.alloc(0),
        ]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCRangeInfo = ZWaveProtocolCCRangeInfo;
exports.ZWaveProtocolCCRangeInfo = ZWaveProtocolCCRangeInfo = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.RangeInfo)
], ZWaveProtocolCCRangeInfo);
let ZWaveProtocolCCGetNodesInRange = class ZWaveProtocolCCGetNodesInRange extends ZWaveProtocolCC {
};
exports.ZWaveProtocolCCGetNodesInRange = ZWaveProtocolCCGetNodesInRange;
exports.ZWaveProtocolCCGetNodesInRange = ZWaveProtocolCCGetNodesInRange = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.GetNodesInRange),
    (0, CommandClassDecorators_1.expectedCCResponse)(ZWaveProtocolCCRangeInfo)
], ZWaveProtocolCCGetNodesInRange);
let ZWaveProtocolCCCommandComplete = class ZWaveProtocolCCCommandComplete extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 1);
            this.sequenceNumber = this.payload[0];
        }
        else {
            this.sequenceNumber = options.sequenceNumber;
        }
    }
    sequenceNumber;
    serialize() {
        this.payload = Buffer.from([this.sequenceNumber]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCCommandComplete = ZWaveProtocolCCCommandComplete;
exports.ZWaveProtocolCCCommandComplete = ZWaveProtocolCCCommandComplete = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.CommandComplete)
], ZWaveProtocolCCCommandComplete);
let ZWaveProtocolCCTransferPresentation = class ZWaveProtocolCCTransferPresentation extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 1);
            const option = this.payload[0];
            this.supportsNWI = !!(option & 0b0001);
            this.excludeNode = !!(option & 0b0010);
            this.includeNode = !!(option & 0b0100);
        }
        else {
            if (options.includeNode && options.excludeNode) {
                throw new core_1.ZWaveError(`${this.constructor.name}: the includeNode and excludeNode options cannot both be true`, core_1.ZWaveErrorCodes.Argument_Invalid);
            }
            this.supportsNWI = options.supportsNWI;
            this.includeNode = options.includeNode;
            this.excludeNode = options.excludeNode;
        }
    }
    supportsNWI;
    includeNode;
    excludeNode;
    serialize() {
        this.payload = Buffer.from([
            (this.supportsNWI ? 0b0001 : 0)
                | (this.excludeNode ? 0b0010 : 0)
                | (this.includeNode ? 0b0100 : 0),
        ]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCTransferPresentation = ZWaveProtocolCCTransferPresentation;
exports.ZWaveProtocolCCTransferPresentation = ZWaveProtocolCCTransferPresentation = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.TransferPresentation)
], ZWaveProtocolCCTransferPresentation);
let ZWaveProtocolCCTransferNodeInformation = class ZWaveProtocolCCTransferNodeInformation extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        let info;
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 2);
            this.sequenceNumber = this.payload[0];
            this.sourceNodeId = this.payload[1];
            info = (0, core_1.parseNodeProtocolInfoAndDeviceClass)(this.payload.subarray(2)).info;
        }
        else {
            this.sequenceNumber = options.sequenceNumber;
            this.sourceNodeId = options.sourceNodeId;
            info = options;
        }
        this.basicDeviceClass = info.basicDeviceClass;
        this.genericDeviceClass = info.genericDeviceClass;
        this.specificDeviceClass = info.specificDeviceClass;
        this.isListening = info.isListening;
        this.isFrequentListening = info.isFrequentListening;
        this.isRouting = info.isRouting;
        this.supportedDataRates = info.supportedDataRates;
        this.protocolVersion = info.protocolVersion;
        this.optionalFunctionality = info.optionalFunctionality;
        this.nodeType = info.nodeType;
        this.supportsSecurity = info.supportsSecurity;
        this.supportsBeaming = info.supportsBeaming;
    }
    sequenceNumber;
    sourceNodeId;
    basicDeviceClass;
    genericDeviceClass;
    specificDeviceClass;
    isListening;
    isFrequentListening;
    isRouting;
    supportedDataRates;
    protocolVersion;
    optionalFunctionality;
    nodeType;
    supportsSecurity;
    supportsBeaming;
    serialize() {
        this.payload = Buffer.concat([
            Buffer.from([this.sequenceNumber, this.sourceNodeId]),
            (0, core_1.encodeNodeProtocolInfoAndDeviceClass)(this),
        ]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCTransferNodeInformation = ZWaveProtocolCCTransferNodeInformation;
exports.ZWaveProtocolCCTransferNodeInformation = ZWaveProtocolCCTransferNodeInformation = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.TransferNodeInformation)
], ZWaveProtocolCCTransferNodeInformation);
let ZWaveProtocolCCTransferRangeInformation = class ZWaveProtocolCCTransferRangeInformation extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 3);
            this.sequenceNumber = this.payload[0];
            this.testedNodeId = this.payload[1];
            const bitmaskLength = this.payload[2];
            (0, core_1.validatePayload)(this.payload.length >= 3 + bitmaskLength);
            this.neighborNodeIds = (0, core_1.parseBitMask)(this.payload.subarray(3, 3 + bitmaskLength));
        }
        else {
            this.sequenceNumber = options.sequenceNumber;
            this.testedNodeId = options.testedNodeId;
            this.neighborNodeIds = options.neighborNodeIds;
        }
    }
    sequenceNumber;
    testedNodeId;
    neighborNodeIds;
    serialize() {
        const nodesBitmask = (0, core_1.encodeBitMask)(this.neighborNodeIds, core_1.MAX_NODES);
        this.payload = Buffer.concat([
            Buffer.from([
                this.sequenceNumber,
                this.testedNodeId,
                nodesBitmask.length,
            ]),
            nodesBitmask,
        ]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCTransferRangeInformation = ZWaveProtocolCCTransferRangeInformation;
exports.ZWaveProtocolCCTransferRangeInformation = ZWaveProtocolCCTransferRangeInformation = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.TransferRangeInformation)
], ZWaveProtocolCCTransferRangeInformation);
let ZWaveProtocolCCTransferEnd = class ZWaveProtocolCCTransferEnd extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 1);
            this.status = this.payload[0];
        }
        else {
            this.status = options.status;
        }
    }
    status;
    serialize() {
        this.payload = Buffer.from([this.status]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCTransferEnd = ZWaveProtocolCCTransferEnd;
exports.ZWaveProtocolCCTransferEnd = ZWaveProtocolCCTransferEnd = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.TransferEnd)
], ZWaveProtocolCCTransferEnd);
let ZWaveProtocolCCAssignReturnRoute = class ZWaveProtocolCCAssignReturnRoute extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 7);
            this.destinationNodeId = this.payload[0];
            this.routeIndex = this.payload[1] >>> 4;
            const numRepeaters = this.payload[1] & 0b1111;
            this.repeaters = [...this.payload.subarray(2, 2 + numRepeaters)];
            const speedAndWakeup = this.payload[2 + numRepeaters];
            this.destinationSpeed = bitmask2DataRate((speedAndWakeup >>> 3) & 0b111);
            this.destinationWakeUp = (speedAndWakeup >>> 1) & 0b11;
        }
        else {
            if (options.repeaters.length > core_1.MAX_REPEATERS) {
                throw new core_1.ZWaveError(`${this.constructor.name}: too many repeaters`, core_1.ZWaveErrorCodes.Argument_Invalid);
            }
            this.destinationNodeId = options.destinationNodeId;
            this.routeIndex = options.routeIndex;
            this.repeaters = options.repeaters;
            this.destinationWakeUp = options.destinationWakeUp;
            this.destinationSpeed = options.destinationSpeed;
        }
    }
    destinationNodeId;
    routeIndex;
    repeaters;
    destinationWakeUp;
    destinationSpeed;
    serialize() {
        const routeByte = (this.routeIndex << 4) | this.repeaters.length;
        const speedMask = dataRate2Bitmask(this.destinationSpeed);
        const speedByte = (speedMask << 3) | (this.destinationWakeUp << 1);
        this.payload = Buffer.from([
            this.destinationNodeId,
            routeByte,
            ...this.repeaters,
            speedByte,
        ]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCAssignReturnRoute = ZWaveProtocolCCAssignReturnRoute;
exports.ZWaveProtocolCCAssignReturnRoute = ZWaveProtocolCCAssignReturnRoute = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.AssignReturnRoute)
], ZWaveProtocolCCAssignReturnRoute);
let ZWaveProtocolCCNewNodeRegistered = class ZWaveProtocolCCNewNodeRegistered extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        let nif;
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 1);
            this.newNodeId = this.payload[0];
            nif = (0, core_1.parseNodeInformationFrame)(this.payload.subarray(1));
        }
        else {
            this.newNodeId = options.newNodeId;
            nif = options;
        }
        this.basicDeviceClass = nif.basicDeviceClass;
        this.genericDeviceClass = nif.genericDeviceClass;
        this.specificDeviceClass = nif.specificDeviceClass;
        this.isListening = nif.isListening;
        this.isFrequentListening = nif.isFrequentListening;
        this.isRouting = nif.isRouting;
        this.supportedDataRates = nif.supportedDataRates;
        this.protocolVersion = nif.protocolVersion;
        this.optionalFunctionality = nif.optionalFunctionality;
        this.nodeType = nif.nodeType;
        this.supportsSecurity = nif.supportsSecurity;
        this.supportsBeaming = nif.supportsBeaming;
        this.supportedCCs = nif.supportedCCs;
    }
    newNodeId;
    basicDeviceClass;
    genericDeviceClass;
    specificDeviceClass;
    isListening;
    isFrequentListening;
    isRouting;
    supportedDataRates;
    protocolVersion;
    optionalFunctionality;
    nodeType;
    supportsSecurity;
    supportsBeaming;
    supportedCCs;
    serialize() {
        this.payload = Buffer.concat([
            Buffer.from([this.newNodeId]),
            (0, core_1.encodeNodeInformationFrame)(this),
        ]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCNewNodeRegistered = ZWaveProtocolCCNewNodeRegistered;
exports.ZWaveProtocolCCNewNodeRegistered = ZWaveProtocolCCNewNodeRegistered = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.NewNodeRegistered)
], ZWaveProtocolCCNewNodeRegistered);
let ZWaveProtocolCCNewRangeRegistered = class ZWaveProtocolCCNewRangeRegistered extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 2);
            this.testedNodeId = this.payload[0];
            const numNeighbors = this.payload[1];
            this.neighborNodeIds = [
                ...this.payload.subarray(2, 2 + numNeighbors),
            ];
        }
        else {
            this.testedNodeId = options.testedNodeId;
            this.neighborNodeIds = options.neighborNodeIds;
        }
    }
    testedNodeId;
    neighborNodeIds;
    serialize() {
        const nodesBitmask = (0, core_1.encodeBitMask)(this.neighborNodeIds, core_1.MAX_NODES);
        this.payload = Buffer.concat([
            Buffer.from([this.testedNodeId, nodesBitmask.length]),
            nodesBitmask,
        ]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCNewRangeRegistered = ZWaveProtocolCCNewRangeRegistered;
exports.ZWaveProtocolCCNewRangeRegistered = ZWaveProtocolCCNewRangeRegistered = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.NewRangeRegistered)
], ZWaveProtocolCCNewRangeRegistered);
let ZWaveProtocolCCTransferNewPrimaryControllerComplete = class ZWaveProtocolCCTransferNewPrimaryControllerComplete extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 1);
            this.genericDeviceClass = this.payload[0];
        }
        else {
            this.genericDeviceClass = options.genericDeviceClass;
        }
    }
    genericDeviceClass;
    serialize() {
        this.payload = Buffer.from([this.genericDeviceClass]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCTransferNewPrimaryControllerComplete = ZWaveProtocolCCTransferNewPrimaryControllerComplete;
exports.ZWaveProtocolCCTransferNewPrimaryControllerComplete = ZWaveProtocolCCTransferNewPrimaryControllerComplete = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.TransferNewPrimaryControllerComplete)
], ZWaveProtocolCCTransferNewPrimaryControllerComplete);
let ZWaveProtocolCCAutomaticControllerUpdateStart = class ZWaveProtocolCCAutomaticControllerUpdateStart extends ZWaveProtocolCC {
};
exports.ZWaveProtocolCCAutomaticControllerUpdateStart = ZWaveProtocolCCAutomaticControllerUpdateStart;
exports.ZWaveProtocolCCAutomaticControllerUpdateStart = ZWaveProtocolCCAutomaticControllerUpdateStart = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.AutomaticControllerUpdateStart)
], ZWaveProtocolCCAutomaticControllerUpdateStart);
let ZWaveProtocolCCSUCNodeID = class ZWaveProtocolCCSUCNodeID extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 1);
            this.sucNodeId = this.payload[0];
            const capabilities = this.payload[1] ?? 0;
            this.isSIS = !!(capabilities & 0b1);
        }
        else {
            this.sucNodeId = options.sucNodeId;
            this.isSIS = options.isSIS;
        }
    }
    sucNodeId;
    isSIS;
    serialize() {
        this.payload = Buffer.from([this.sucNodeId, this.isSIS ? 0b1 : 0]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCSUCNodeID = ZWaveProtocolCCSUCNodeID;
exports.ZWaveProtocolCCSUCNodeID = ZWaveProtocolCCSUCNodeID = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.SUCNodeID)
], ZWaveProtocolCCSUCNodeID);
let ZWaveProtocolCCSetSUC = class ZWaveProtocolCCSetSUC extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 2);
            // Byte 0 must be 0x01 or ignored
            const capabilities = this.payload[1] ?? 0;
            this.enableSIS = !!(capabilities & 0b1);
        }
        else {
            this.enableSIS = options.enableSIS;
        }
    }
    enableSIS;
    serialize() {
        this.payload = Buffer.from([0x01, this.enableSIS ? 0b1 : 0]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCSetSUC = ZWaveProtocolCCSetSUC;
exports.ZWaveProtocolCCSetSUC = ZWaveProtocolCCSetSUC = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.SetSUC)
], ZWaveProtocolCCSetSUC);
let ZWaveProtocolCCSetSUCAck = class ZWaveProtocolCCSetSUCAck extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 2);
            this.accepted = this.payload[0] === 0x01;
            const capabilities = this.payload[1] ?? 0;
            this.isSIS = !!(capabilities & 0b1);
        }
        else {
            this.accepted = options.accepted;
            this.isSIS = options.isSIS;
        }
    }
    accepted;
    isSIS;
    serialize() {
        this.payload = Buffer.from([
            this.accepted ? 0x01 : 0x00,
            this.isSIS ? 0b1 : 0,
        ]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCSetSUCAck = ZWaveProtocolCCSetSUCAck;
exports.ZWaveProtocolCCSetSUCAck = ZWaveProtocolCCSetSUCAck = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.SetSUCAck)
], ZWaveProtocolCCSetSUCAck);
let ZWaveProtocolCCAssignSUCReturnRoute = class ZWaveProtocolCCAssignSUCReturnRoute extends ZWaveProtocolCCAssignReturnRoute {
};
exports.ZWaveProtocolCCAssignSUCReturnRoute = ZWaveProtocolCCAssignSUCReturnRoute;
exports.ZWaveProtocolCCAssignSUCReturnRoute = ZWaveProtocolCCAssignSUCReturnRoute = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.AssignSUCReturnRoute)
], ZWaveProtocolCCAssignSUCReturnRoute);
let ZWaveProtocolCCStaticRouteRequest = class ZWaveProtocolCCStaticRouteRequest extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 5);
            this.nodeIds = [...this.payload.subarray(0, 5)].filter((id) => id > 0 && id <= core_1.MAX_NODES);
        }
        else {
            if (options.nodeIds.some((n) => n < 1 || n > core_1.MAX_NODES)) {
                throw new core_1.ZWaveError(`All node IDs must be between 1 and ${core_1.MAX_NODES}!`, core_1.ZWaveErrorCodes.Argument_Invalid);
            }
            this.nodeIds = options.nodeIds;
        }
    }
    nodeIds;
    serialize() {
        this.payload = Buffer.alloc(5, 0);
        for (let i = 0; i < this.nodeIds.length && i < 5; i++) {
            this.payload[i] = this.nodeIds[i];
        }
        return super.serialize();
    }
};
exports.ZWaveProtocolCCStaticRouteRequest = ZWaveProtocolCCStaticRouteRequest;
exports.ZWaveProtocolCCStaticRouteRequest = ZWaveProtocolCCStaticRouteRequest = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.StaticRouteRequest)
], ZWaveProtocolCCStaticRouteRequest);
let ZWaveProtocolCCLost = class ZWaveProtocolCCLost extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 1);
            this.lostNodeId = this.payload[0];
        }
        else {
            this.lostNodeId = options.lostNodeId;
        }
    }
    lostNodeId;
    serialize() {
        this.payload = Buffer.from([this.lostNodeId]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCLost = ZWaveProtocolCCLost;
exports.ZWaveProtocolCCLost = ZWaveProtocolCCLost = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.Lost)
], ZWaveProtocolCCLost);
let ZWaveProtocolCCAcceptLost = class ZWaveProtocolCCAcceptLost extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 1);
            (0, core_1.validatePayload)(this.payload[0] === 0x04 || this.payload[0] === 0x05);
            this.accepted = this.payload[0] === 0x05;
        }
        else {
            this.accepted = options.accepted;
        }
    }
    accepted;
    serialize() {
        this.payload = Buffer.from([this.accepted ? 0x05 : 0x04]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCAcceptLost = ZWaveProtocolCCAcceptLost;
exports.ZWaveProtocolCCAcceptLost = ZWaveProtocolCCAcceptLost = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.AcceptLost)
], ZWaveProtocolCCAcceptLost);
let ZWaveProtocolCCNOPPower = class ZWaveProtocolCCNOPPower extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            if (this.payload.length >= 2) {
                // Ignore byte 0
                this.powerDampening = this.payload[1];
            }
            else if (this.payload.length === 1) {
                this.powerDampening = [
                    0xf0,
                    0xc8,
                    0xa7,
                    0x91,
                    0x77,
                    0x67,
                    0x60,
                    0x46,
                    0x38,
                    0x35,
                    0x32,
                    0x30,
                    0x24,
                    0x22,
                    0x20,
                ].indexOf(this.payload[0]);
                if (this.powerDampening === -1)
                    this.powerDampening = 0;
            }
            else {
                throw core_1.validatePayload.fail("Invalid payload length!");
            }
        }
        else {
            if (options.powerDampening < 0 || options.powerDampening > 14) {
                throw new core_1.ZWaveError(`${this.constructor.name}: power dampening must be between 0 and 14 dBm!`, core_1.ZWaveErrorCodes.Argument_Invalid);
            }
            this.powerDampening = options.powerDampening;
        }
    }
    // Power dampening in (negative) dBm. A value of 2 means -2 dBm.
    powerDampening;
    serialize() {
        this.payload = Buffer.from([0, this.powerDampening]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCNOPPower = ZWaveProtocolCCNOPPower;
exports.ZWaveProtocolCCNOPPower = ZWaveProtocolCCNOPPower = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.NOPPower)
], ZWaveProtocolCCNOPPower);
let ZWaveProtocolCCReservedIDs = class ZWaveProtocolCCReservedIDs extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 1);
            const numNodeIDs = this.payload[0];
            (0, core_1.validatePayload)(this.payload.length >= 1 + numNodeIDs);
            this.reservedNodeIDs = [
                ...this.payload.subarray(1, 1 + numNodeIDs),
            ];
        }
        else {
            this.reservedNodeIDs = options.reservedNodeIDs;
        }
    }
    reservedNodeIDs;
    serialize() {
        this.payload = Buffer.from([
            this.reservedNodeIDs.length,
            ...this.reservedNodeIDs,
        ]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCReservedIDs = ZWaveProtocolCCReservedIDs;
exports.ZWaveProtocolCCReservedIDs = ZWaveProtocolCCReservedIDs = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.ReservedIDs)
], ZWaveProtocolCCReservedIDs);
let ZWaveProtocolCCReserveNodeIDs = class ZWaveProtocolCCReserveNodeIDs extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 1);
            this.numNodeIDs = this.payload[0];
        }
        else {
            this.numNodeIDs = options.numNodeIDs;
        }
    }
    numNodeIDs;
    serialize() {
        this.payload = Buffer.from([this.numNodeIDs]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCReserveNodeIDs = ZWaveProtocolCCReserveNodeIDs;
exports.ZWaveProtocolCCReserveNodeIDs = ZWaveProtocolCCReserveNodeIDs = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.ReserveNodeIDs),
    (0, CommandClassDecorators_1.expectedCCResponse)(ZWaveProtocolCCReservedIDs)
], ZWaveProtocolCCReserveNodeIDs);
let ZWaveProtocolCCNodesExistReply = class ZWaveProtocolCCNodesExistReply extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 2);
            this.nodeMaskType = this.payload[0];
            this.nodeListUpdated = this.payload[1] === 0x01;
        }
        else {
            this.nodeMaskType = options.nodeMaskType;
            this.nodeListUpdated = options.nodeListUpdated;
        }
    }
    nodeMaskType;
    nodeListUpdated;
    serialize() {
        this.payload = Buffer.from([
            this.nodeMaskType,
            this.nodeListUpdated ? 0x01 : 0x00,
        ]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCNodesExistReply = ZWaveProtocolCCNodesExistReply;
exports.ZWaveProtocolCCNodesExistReply = ZWaveProtocolCCNodesExistReply = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.NodesExistReply)
], ZWaveProtocolCCNodesExistReply);
function testResponseForZWaveProtocolNodesExist(sent, received) {
    return received.nodeMaskType === sent.nodeMaskType;
}
let ZWaveProtocolCCNodesExist = class ZWaveProtocolCCNodesExist extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 2);
            this.nodeMaskType = this.payload[0];
            const numNodeIDs = this.payload[1];
            (0, core_1.validatePayload)(this.payload.length >= 2 + numNodeIDs);
            this.nodeIDs = [...this.payload.subarray(2, 2 + numNodeIDs)];
        }
        else {
            this.nodeMaskType = options.nodeMaskType;
            this.nodeIDs = options.nodeIDs;
        }
    }
    nodeMaskType;
    nodeIDs;
    serialize() {
        this.payload = Buffer.from([
            this.nodeMaskType,
            this.nodeIDs.length,
            ...this.nodeIDs,
        ]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCNodesExist = ZWaveProtocolCCNodesExist;
exports.ZWaveProtocolCCNodesExist = ZWaveProtocolCCNodesExist = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.NodesExist),
    (0, CommandClassDecorators_1.expectedCCResponse)(ZWaveProtocolCCNodesExistReply, testResponseForZWaveProtocolNodesExist)
], ZWaveProtocolCCNodesExist);
let ZWaveProtocolCCSetNWIMode = class ZWaveProtocolCCSetNWIMode extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 2);
            this.enabled = this.payload[0] === 0x01;
            this.timeoutMinutes = this.payload[1] || undefined;
        }
        else {
            this.enabled = options.enabled;
            this.timeoutMinutes = options.timeoutMinutes;
        }
    }
    enabled;
    timeoutMinutes;
    serialize() {
        this.payload = Buffer.from([
            this.enabled ? 0x01 : 0x00,
            this.timeoutMinutes ?? 0x00,
        ]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCSetNWIMode = ZWaveProtocolCCSetNWIMode;
exports.ZWaveProtocolCCSetNWIMode = ZWaveProtocolCCSetNWIMode = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.SetNWIMode)
], ZWaveProtocolCCSetNWIMode);
let ZWaveProtocolCCExcludeRequest = class ZWaveProtocolCCExcludeRequest extends ZWaveProtocolCCNodeInformationFrame {
};
exports.ZWaveProtocolCCExcludeRequest = ZWaveProtocolCCExcludeRequest;
exports.ZWaveProtocolCCExcludeRequest = ZWaveProtocolCCExcludeRequest = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.ExcludeRequest)
], ZWaveProtocolCCExcludeRequest);
let ZWaveProtocolCCAssignReturnRoutePriority = class ZWaveProtocolCCAssignReturnRoutePriority extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 2);
            this.targetNodeId = this.payload[0];
            this.routeNumber = this.payload[1];
        }
        else {
            this.targetNodeId = options.targetNodeId;
            this.routeNumber = options.routeNumber;
        }
    }
    targetNodeId;
    routeNumber;
    serialize() {
        this.payload = Buffer.from([this.targetNodeId, this.routeNumber]);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCAssignReturnRoutePriority = ZWaveProtocolCCAssignReturnRoutePriority;
exports.ZWaveProtocolCCAssignReturnRoutePriority = ZWaveProtocolCCAssignReturnRoutePriority = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.AssignReturnRoutePriority)
], ZWaveProtocolCCAssignReturnRoutePriority);
let ZWaveProtocolCCAssignSUCReturnRoutePriority = class ZWaveProtocolCCAssignSUCReturnRoutePriority extends ZWaveProtocolCCAssignReturnRoutePriority {
};
exports.ZWaveProtocolCCAssignSUCReturnRoutePriority = ZWaveProtocolCCAssignSUCReturnRoutePriority;
exports.ZWaveProtocolCCAssignSUCReturnRoutePriority = ZWaveProtocolCCAssignSUCReturnRoutePriority = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.AssignSUCReturnRoutePriority)
], ZWaveProtocolCCAssignSUCReturnRoutePriority);
let ZWaveProtocolCCSmartStartIncludedNodeInformation = class ZWaveProtocolCCSmartStartIncludedNodeInformation extends ZWaveProtocolCC {
    constructor(host, options) {
        super(host, options);
        if ((0, CommandClass_1.gotDeserializationOptions)(options)) {
            (0, core_1.validatePayload)(this.payload.length >= 4);
            this.nwiHomeId = this.payload.subarray(0, 4);
        }
        else {
            if (options.nwiHomeId.length !== 4) {
                throw new core_1.ZWaveError(`nwiHomeId must have length 4`, core_1.ZWaveErrorCodes.Argument_Invalid);
            }
            this.nwiHomeId = options.nwiHomeId;
        }
    }
    nwiHomeId;
    serialize() {
        this.payload = Buffer.from(this.nwiHomeId);
        return super.serialize();
    }
};
exports.ZWaveProtocolCCSmartStartIncludedNodeInformation = ZWaveProtocolCCSmartStartIncludedNodeInformation;
exports.ZWaveProtocolCCSmartStartIncludedNodeInformation = ZWaveProtocolCCSmartStartIncludedNodeInformation = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.SmartStartIncludedNodeInformation)
], ZWaveProtocolCCSmartStartIncludedNodeInformation);
let ZWaveProtocolCCSmartStartPrime = class ZWaveProtocolCCSmartStartPrime extends ZWaveProtocolCCNodeInformationFrame {
};
exports.ZWaveProtocolCCSmartStartPrime = ZWaveProtocolCCSmartStartPrime;
exports.ZWaveProtocolCCSmartStartPrime = ZWaveProtocolCCSmartStartPrime = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.SmartStartPrime)
], ZWaveProtocolCCSmartStartPrime);
let ZWaveProtocolCCSmartStartInclusionRequest = class ZWaveProtocolCCSmartStartInclusionRequest extends ZWaveProtocolCCNodeInformationFrame {
};
exports.ZWaveProtocolCCSmartStartInclusionRequest = ZWaveProtocolCCSmartStartInclusionRequest;
exports.ZWaveProtocolCCSmartStartInclusionRequest = ZWaveProtocolCCSmartStartInclusionRequest = __decorate([
    (0, CommandClassDecorators_1.CCCommand)(_Types_1.ZWaveProtocolCommand.SmartStartInclusionRequest)
], ZWaveProtocolCCSmartStartInclusionRequest);
//# sourceMappingURL=ZWaveProtocolCC.js.map