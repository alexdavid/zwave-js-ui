"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionState = exports.mergeSupervisionResults = exports.isUnsupervisedOrSucceeded = exports.supervisedCommandFailed = exports.supervisedCommandSucceeded = exports.isSupervisionResult = exports.SupervisionStatus = exports.EncapsulationFlags = exports.routingSchemeToString = exports.RoutingScheme = exports.rssiToString = exports.averageRSSI = exports.isRssiError = exports.RssiError = exports.TransmitStatus = exports.TransmitOptions = exports.isMessagePriority = exports.MessagePriority = void 0;
const safe_1 = require("@zwave-js/shared/safe");
const typeguards_1 = require("alcalzone-shared/typeguards");
const Duration_1 = require("../values/Duration");
/** The priority of messages, sorted from high (0) to low (>0) */
var MessagePriority;
(function (MessagePriority) {
    // High-priority controller commands that must be handled before all other commands.
    // We use this priority to decide which messages go onto the immediate queue.
    MessagePriority[MessagePriority["ControllerImmediate"] = 0] = "ControllerImmediate";
    // Controller commands finish quickly and should be preferred over node queries
    MessagePriority[MessagePriority["Controller"] = 1] = "Controller";
    // Some node commands like nonces, responses to Supervision and Transport Service
    // need to be handled before all node commands.
    // We use this priority to decide which messages go onto the immediate queue.
    MessagePriority[MessagePriority["Immediate"] = 2] = "Immediate";
    // To avoid S2 collisions, some commands that normally have Immediate priority
    // have to go onto the normal queue, but still before all other messages
    MessagePriority[MessagePriority["ImmediateLow"] = 3] = "ImmediateLow";
    // Pings (NoOP) are used for device probing at startup and for network diagnostics
    MessagePriority[MessagePriority["Ping"] = 4] = "Ping";
    // Whenever sleeping devices wake up, their queued messages must be handled quickly
    // because they want to go to sleep soon. So prioritize them over non-sleeping devices
    MessagePriority[MessagePriority["WakeUp"] = 5] = "WakeUp";
    // Normal operation and node data exchange
    MessagePriority[MessagePriority["Normal"] = 6] = "Normal";
    // Node querying is expensive and happens whenever a new node is discovered.
    // In order to keep the system responsive, give them a lower priority
    MessagePriority[MessagePriority["NodeQuery"] = 7] = "NodeQuery";
    // Some devices need their state to be polled at regular intervals. Only do that when
    // nothing else needs to be done
    MessagePriority[MessagePriority["Poll"] = 8] = "Poll";
})(MessagePriority || (exports.MessagePriority = MessagePriority = {}));
function isMessagePriority(val) {
    return typeof val === "number" && val in MessagePriority;
}
exports.isMessagePriority = isMessagePriority;
var TransmitOptions;
(function (TransmitOptions) {
    TransmitOptions[TransmitOptions["NotSet"] = 0] = "NotSet";
    TransmitOptions[TransmitOptions["ACK"] = 1] = "ACK";
    TransmitOptions[TransmitOptions["LowPower"] = 2] = "LowPower";
    TransmitOptions[TransmitOptions["AutoRoute"] = 4] = "AutoRoute";
    TransmitOptions[TransmitOptions["NoRoute"] = 16] = "NoRoute";
    TransmitOptions[TransmitOptions["Explore"] = 32] = "Explore";
    TransmitOptions[TransmitOptions["DEFAULT"] = 37] = "DEFAULT";
    TransmitOptions[TransmitOptions["DEFAULT_NOACK"] = 36] = "DEFAULT_NOACK";
})(TransmitOptions || (exports.TransmitOptions = TransmitOptions = {}));
var TransmitStatus;
(function (TransmitStatus) {
    TransmitStatus[TransmitStatus["OK"] = 0] = "OK";
    TransmitStatus[TransmitStatus["NoAck"] = 1] = "NoAck";
    TransmitStatus[TransmitStatus["Fail"] = 2] = "Fail";
    TransmitStatus[TransmitStatus["NotIdle"] = 3] = "NotIdle";
    TransmitStatus[TransmitStatus["NoRoute"] = 4] = "NoRoute";
})(TransmitStatus || (exports.TransmitStatus = TransmitStatus = {}));
var RssiError;
(function (RssiError) {
    RssiError[RssiError["NotAvailable"] = 127] = "NotAvailable";
    RssiError[RssiError["ReceiverSaturated"] = 126] = "ReceiverSaturated";
    RssiError[RssiError["NoSignalDetected"] = 125] = "NoSignalDetected";
})(RssiError || (exports.RssiError = RssiError = {}));
function isRssiError(rssi) {
    return rssi >= RssiError.NoSignalDetected;
}
exports.isRssiError = isRssiError;
/** Averages RSSI measurements using an exponential moving average with the given weight for the accumulator */
function averageRSSI(acc, rssi, weight) {
    if (isRssiError(rssi)) {
        switch (rssi) {
            case RssiError.NotAvailable:
                // If we don't have a value yet, return 0
                return acc ?? 0;
            case RssiError.ReceiverSaturated:
                // Assume rssi is 0 dBm
                rssi = 0;
                break;
            case RssiError.NoSignalDetected:
                // Assume rssi is -128 dBm
                rssi = -128;
                break;
        }
    }
    if (acc == undefined)
        return rssi;
    return Math.round(acc * weight + rssi * (1 - weight));
}
exports.averageRSSI = averageRSSI;
/**
 * Converts an RSSI value to a human readable format, i.e. the measurement including the unit or the corresponding error message.
 */
function rssiToString(rssi) {
    switch (rssi) {
        case RssiError.NotAvailable:
            return "N/A";
        case RssiError.ReceiverSaturated:
            return "Receiver saturated";
        case RssiError.NoSignalDetected:
            return "No signal detected";
        default:
            return `${rssi} dBm`;
    }
}
exports.rssiToString = rssiToString;
/**
 * How the controller transmitted a frame to a node.
 */
var RoutingScheme;
(function (RoutingScheme) {
    RoutingScheme[RoutingScheme["Idle"] = 0] = "Idle";
    RoutingScheme[RoutingScheme["Direct"] = 1] = "Direct";
    RoutingScheme[RoutingScheme["Priority"] = 2] = "Priority";
    RoutingScheme[RoutingScheme["LWR"] = 3] = "LWR";
    RoutingScheme[RoutingScheme["NLWR"] = 4] = "NLWR";
    RoutingScheme[RoutingScheme["Auto"] = 5] = "Auto";
    RoutingScheme[RoutingScheme["ResortDirect"] = 6] = "ResortDirect";
    RoutingScheme[RoutingScheme["Explore"] = 7] = "Explore";
})(RoutingScheme || (exports.RoutingScheme = RoutingScheme = {}));
/**
 * Converts a routing scheme value to a human readable format.
 */
function routingSchemeToString(scheme) {
    switch (scheme) {
        case RoutingScheme.Idle:
            return "Idle";
        case RoutingScheme.Direct:
            return "Direct";
        case RoutingScheme.Priority:
            return "Priority Route";
        case RoutingScheme.LWR:
            return "LWR";
        case RoutingScheme.NLWR:
            return "NLWR";
        case RoutingScheme.Auto:
            return "Auto Route";
        case RoutingScheme.ResortDirect:
            return "Resort to Direct";
        case RoutingScheme.Explore:
            return "Explorer Frame";
        default:
            return `Unknown (${(0, safe_1.num2hex)(scheme)})`;
    }
}
exports.routingSchemeToString = routingSchemeToString;
var EncapsulationFlags;
(function (EncapsulationFlags) {
    EncapsulationFlags[EncapsulationFlags["None"] = 0] = "None";
    EncapsulationFlags[EncapsulationFlags["Supervision"] = 1] = "Supervision";
    // Multi Channel is tracked through the endpoint index
    EncapsulationFlags[EncapsulationFlags["Security"] = 2] = "Security";
    EncapsulationFlags[EncapsulationFlags["CRC16"] = 4] = "CRC16";
})(EncapsulationFlags || (exports.EncapsulationFlags = EncapsulationFlags = {}));
var SupervisionStatus;
(function (SupervisionStatus) {
    SupervisionStatus[SupervisionStatus["NoSupport"] = 0] = "NoSupport";
    SupervisionStatus[SupervisionStatus["Working"] = 1] = "Working";
    SupervisionStatus[SupervisionStatus["Fail"] = 2] = "Fail";
    SupervisionStatus[SupervisionStatus["Success"] = 255] = "Success";
})(SupervisionStatus || (exports.SupervisionStatus = SupervisionStatus = {}));
function isSupervisionResult(obj) {
    return ((0, typeguards_1.isObject)(obj)
        && "status" in obj
        && typeof SupervisionStatus[obj.status] === "string");
}
exports.isSupervisionResult = isSupervisionResult;
function supervisedCommandSucceeded(result) {
    return (isSupervisionResult(result)
        && (result.status === SupervisionStatus.Success
            || result.status === SupervisionStatus.Working));
}
exports.supervisedCommandSucceeded = supervisedCommandSucceeded;
function supervisedCommandFailed(result) {
    return (isSupervisionResult(result)
        && (result.status === SupervisionStatus.Fail
            || result.status === SupervisionStatus.NoSupport));
}
exports.supervisedCommandFailed = supervisedCommandFailed;
function isUnsupervisedOrSucceeded(result) {
    return !result || supervisedCommandSucceeded(result);
}
exports.isUnsupervisedOrSucceeded = isUnsupervisedOrSucceeded;
/** Figures out the final supervision result from an array of things that may be supervision results */
function mergeSupervisionResults(results) {
    const supervisionResults = results.filter(isSupervisionResult);
    if (!supervisionResults.length)
        return undefined;
    if (supervisionResults.some((r) => r.status === SupervisionStatus.Fail)) {
        return {
            status: SupervisionStatus.Fail,
        };
    }
    else if (supervisionResults.some((r) => r.status === SupervisionStatus.NoSupport)) {
        return {
            status: SupervisionStatus.NoSupport,
        };
    }
    const working = supervisionResults.filter((r) => r.status === SupervisionStatus.Working);
    if (working.length > 0) {
        const durations = working.map((r) => r.remainingDuration.serializeSet());
        const maxDuration = (durations.length > 0
            && Duration_1.Duration.parseReport(Math.max(...durations)))
            || Duration_1.Duration.unknown();
        return {
            status: SupervisionStatus.Working,
            remainingDuration: maxDuration,
        };
    }
    return {
        status: SupervisionStatus.Success,
    };
}
exports.mergeSupervisionResults = mergeSupervisionResults;
/**
 * The state a transaction is in.
 */
var TransactionState;
(function (TransactionState) {
    /** The transaction is currently queued */
    TransactionState[TransactionState["Queued"] = 0] = "Queued";
    /** The transaction is currently being handled */
    TransactionState[TransactionState["Active"] = 1] = "Active";
    /** The transaction was completed */
    TransactionState[TransactionState["Completed"] = 2] = "Completed";
    /** The transaction failed */
    TransactionState[TransactionState["Failed"] = 3] = "Failed";
})(TransactionState || (exports.TransactionState = TransactionState = {}));
//# sourceMappingURL=Transmission.js.map