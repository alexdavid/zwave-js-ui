"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockServer = void 0;
const mock_1 = require("@zwave-js/serial/mock");
const testing_1 = require("@zwave-js/testing");
const deferred_promise_1 = require("alcalzone-shared/deferred-promise");
const node_net_1 = require("node:net");
const Utils_1 = require("./Utils");
class MockServer {
    options;
    constructor(options = {}) {
        this.options = options;
    }
    serialport;
    binding;
    server;
    mockController;
    mockNodes;
    async start() {
        const { port: serialport, binding } = await (0, mock_1.createAndOpenMockedZWaveSerialPort)("/tty/FAKE");
        this.serialport = serialport;
        this.binding = binding;
        console.log("Mock serial port opened");
        // Hook up a fake controller and nodes
        ({ mockController: this.mockController, mockNodes: this.mockNodes } =
            prepareMocks(binding, this.options.config?.controller, this.options.config?.nodes));
        // Call the init hook if it is defined
        if (typeof this.options.config?.onInit === "function") {
            this.options.config.onInit(this.mockController, this.mockNodes);
        }
        // Start a TCP server, listen for connections, and forward them to the serial port
        this.server = (0, node_net_1.createServer)((socket) => {
            if (!this.serialport) {
                console.error("Serial port not initialized");
                socket.destroy();
                return;
            }
            console.log("Client connected");
            socket.pipe(this.serialport);
            this.serialport.on("data", (chunk) => {
                if (typeof chunk === "number") {
                    socket.write(Buffer.from([chunk]));
                }
                else {
                    socket.write(chunk);
                }
            });
            // when the connection is closed, unpipe the streams
            socket.on("close", () => {
                console.log("Client disconnected");
                socket.unpipe(this.serialport);
                this.serialport?.removeAllListeners("data");
            });
        });
        // Do not allow more than one client to connect
        this.server.maxConnections = 1;
        const promise = (0, deferred_promise_1.createDeferredPromise)();
        this.server.on("error", (err) => {
            if (err.code === "EADDRINUSE") {
                promise.reject(err);
            }
        });
        this.server.listen({
            host: this.options.interface,
            port: this.options.port ?? 5555,
        }, () => {
            const address = this.server.address();
            console.log(`Server listening on tcp://${address.address}:${address.port}`);
            promise.resolve();
        });
    }
    async stop() {
        console.log("Shutting down mock server...");
        this.mockController?.destroy();
        this.server?.close();
        await this.serialport?.close();
        if (this.binding?.isOpen)
            await this.binding?.close();
        console.log("Mock server shut down");
    }
}
exports.MockServer = MockServer;
function prepareMocks(mockPort, controller = {}, nodes = []) {
    const mockController = new testing_1.MockController({
        homeId: 0x7e570001,
        ownNodeId: 1,
        ...controller,
        serial: mockPort,
    });
    // Apply default behaviors that are required for interacting with the driver correctly
    mockController.defineBehavior(...(0, Utils_1.createDefaultMockControllerBehaviors)());
    // Apply custom behaviors
    if (controller.behaviors) {
        mockController.defineBehavior(...controller.behaviors);
    }
    const mockNodes = [];
    for (const node of nodes) {
        const mockNode = new testing_1.MockNode({
            ...node,
            controller: mockController,
        });
        mockController.addNode(mockNode);
        mockNodes.push(mockNode);
        // Apply default behaviors that are required for interacting with the driver correctly
        mockNode.defineBehavior(...(0, Utils_1.createDefaultMockNodeBehaviors)());
        // Apply custom behaviors
        if (node.behaviors) {
            mockNode.defineBehavior(...node.behaviors);
        }
    }
    return {
        mockController,
        mockNodes,
    };
}
//# sourceMappingURL=mockServer.js.map