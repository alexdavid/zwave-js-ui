"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThermostatSetpointCCBehaviors = void 0;
const cc_1 = require("@zwave-js/cc");
const ThermostatSetpointCC_1 = require("@zwave-js/cc/ThermostatSetpointCC");
const safe_1 = require("@zwave-js/core/safe");
const testing_1 = require("@zwave-js/testing");
const defaultCapabilities = {
    setpoints: {
        [cc_1.ThermostatSetpointType.Heating]: {
            minValue: 0,
            maxValue: 100,
            scale: "째C",
        },
    },
};
const STATE_KEY_PREFIX = "ThermostatSetpoint_";
const StateKeys = {
    setpoint: (type) => `${STATE_KEY_PREFIX}setpoint_${type}`,
    scale: (type) => `${STATE_KEY_PREFIX}scale_${type}`,
};
const respondToThermostatSetpointSet = {
    onControllerFrame(controller, self, frame) {
        if (frame.type === testing_1.MockZWaveFrameType.Request
            && frame.payload instanceof ThermostatSetpointCC_1.ThermostatSetpointCCSet) {
            const capabilities = {
                ...defaultCapabilities,
                ...self.getCCCapabilities(safe_1.CommandClasses["Thermostat Setpoint"], frame.payload.endpointIndex),
            };
            const setpointCaps = capabilities.setpoints[frame.payload.setpointType];
            if (!setpointCaps)
                return true;
            const value = frame.payload.value;
            if (value > setpointCaps.minValue
                || value > setpointCaps.maxValue) {
                return true;
            }
            self.state.set(StateKeys.setpoint(frame.payload.setpointType), value);
            self.state.set(StateKeys.scale(frame.payload.setpointType), frame.payload.scale);
            return true;
        }
        return false;
    },
};
const respondToThermostatSetpointGet = {
    async onControllerFrame(controller, self, frame) {
        if (frame.type === testing_1.MockZWaveFrameType.Request
            && frame.payload instanceof ThermostatSetpointCC_1.ThermostatSetpointCCGet) {
            const capabilities = {
                ...defaultCapabilities,
                ...self.getCCCapabilities(safe_1.CommandClasses["Thermostat Setpoint"], frame.payload.endpointIndex),
            };
            const setpointType = frame.payload.setpointType;
            const setpointCaps = capabilities.setpoints[setpointType];
            let value = self.state.get(StateKeys.setpoint(setpointType));
            let scale = self.state.get(StateKeys.scale(setpointType));
            if (setpointCaps) {
                if (value === undefined) {
                    value = setpointCaps.defaultValue ?? setpointCaps.minValue;
                }
                if (scale === undefined) {
                    scale = setpointCaps.scale === "째F" ? 1 : 0;
                }
            }
            let cc;
            if (value !== undefined) {
                cc = new ThermostatSetpointCC_1.ThermostatSetpointCCReport(self.host, {
                    nodeId: controller.host.ownNodeId,
                    type: setpointType,
                    value,
                    scale: scale ?? 0,
                });
            }
            else {
                cc = new ThermostatSetpointCC_1.ThermostatSetpointCCReport(self.host, {
                    nodeId: controller.host.ownNodeId,
                    type: cc_1.ThermostatSetpointType["N/A"],
                    scale: 0,
                    value: 0,
                });
            }
            await self.sendToController((0, testing_1.createMockZWaveRequestFrame)(cc, {
                ackRequested: false,
            }));
            return true;
        }
        return false;
    },
};
const respondToThermostatSetpointSupportedGet = {
    async onControllerFrame(controller, self, frame) {
        if (frame.type === testing_1.MockZWaveFrameType.Request
            && frame.payload instanceof ThermostatSetpointCC_1.ThermostatSetpointCCSupportedGet) {
            const capabilities = {
                ...defaultCapabilities,
                ...self.getCCCapabilities(safe_1.CommandClasses["Thermostat Setpoint"], frame.payload.endpointIndex),
            };
            const cc = new ThermostatSetpointCC_1.ThermostatSetpointCCSupportedReport(self.host, {
                nodeId: controller.host.ownNodeId,
                supportedSetpointTypes: Object.keys(capabilities.setpoints).map((k) => parseInt(k)),
            });
            await self.sendToController((0, testing_1.createMockZWaveRequestFrame)(cc, {
                ackRequested: false,
            }));
            return true;
        }
        return false;
    },
};
const respondToThermostatSetpointCapabilitiesGet = {
    async onControllerFrame(controller, self, frame) {
        if (frame.type === testing_1.MockZWaveFrameType.Request
            && frame.payload instanceof ThermostatSetpointCC_1.ThermostatSetpointCCCapabilitiesGet) {
            const capabilities = {
                ...defaultCapabilities,
                ...self.getCCCapabilities(safe_1.CommandClasses["Thermostat Setpoint"], frame.payload.endpointIndex),
            };
            const setpointType = frame.payload.setpointType;
            const setpointCaps = capabilities.setpoints[setpointType];
            let cc;
            if (setpointCaps) {
                cc = new ThermostatSetpointCC_1.ThermostatSetpointCCCapabilitiesReport(self.host, {
                    nodeId: controller.host.ownNodeId,
                    type: setpointType,
                    minValue: setpointCaps.minValue,
                    maxValue: setpointCaps.maxValue,
                    minValueScale: setpointCaps.scale === "째C" ? 0 : 1,
                    maxValueScale: setpointCaps.scale === "째C" ? 0 : 1,
                });
            }
            else {
                cc = new ThermostatSetpointCC_1.ThermostatSetpointCCCapabilitiesReport(self.host, {
                    nodeId: controller.host.ownNodeId,
                    type: cc_1.ThermostatSetpointType["N/A"],
                    minValue: 0,
                    maxValue: 0,
                    minValueScale: 0,
                    maxValueScale: 0,
                });
            }
            await self.sendToController((0, testing_1.createMockZWaveRequestFrame)(cc, {
                ackRequested: false,
            }));
            return true;
        }
        return false;
    },
};
exports.ThermostatSetpointCCBehaviors = [
    respondToThermostatSetpointGet,
    respondToThermostatSetpointSet,
    respondToThermostatSetpointSupportedGet,
    respondToThermostatSetpointCapabilitiesGet,
];
//# sourceMappingURL=ThermostatSetpoint.js.map