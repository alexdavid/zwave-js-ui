"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScheduleEntryLockCCBehaviors = void 0;
const cc_1 = require("@zwave-js/cc");
const ScheduleEntryLockCC_1 = require("@zwave-js/cc/ScheduleEntryLockCC");
const safe_1 = require("@zwave-js/core/safe");
const testing_1 = require("@zwave-js/testing");
const UserCode_1 = require("./UserCode");
const defaultCapabilities = {
    numWeekDaySlots: 1,
    numYearDaySlots: 0,
    numDailyRepeatingSlots: 0,
};
const STATE_KEY_PREFIX = "ScheduleEntryLock_";
const StateKeys = {
    standardOffset: `${STATE_KEY_PREFIX}standardOffset`,
    dstOffset: `${STATE_KEY_PREFIX}dstOffset`,
    schedule: (userId, slotId, kind) => `${STATE_KEY_PREFIX}schedule_${userId}_${slotId}_${kind}`,
};
const respondToScheduleEntryLockSupportedGet = {
    async onControllerFrame(controller, self, frame) {
        if (frame.type === testing_1.MockZWaveFrameType.Request
            && frame.payload instanceof ScheduleEntryLockCC_1.ScheduleEntryLockCCSupportedGet) {
            const capabilities = {
                ...defaultCapabilities,
                ...self.getCCCapabilities(safe_1.CommandClasses["Schedule Entry Lock"], frame.payload.endpointIndex),
            };
            const cc = new ScheduleEntryLockCC_1.ScheduleEntryLockCCSupportedReport(self.host, {
                nodeId: controller.host.ownNodeId,
                ...capabilities,
            });
            await self.sendToController((0, testing_1.createMockZWaveRequestFrame)(cc, {
                ackRequested: false,
            }));
            return true;
        }
        return false;
    },
};
const respondToScheduleEntryLockTimeOffsetSet = {
    onControllerFrame(controller, self, frame) {
        if (frame.type === testing_1.MockZWaveFrameType.Request
            && frame.payload instanceof ScheduleEntryLockCC_1.ScheduleEntryLockCCTimeOffsetSet) {
            self.state.set(StateKeys.standardOffset, frame.payload.standardOffset);
            self.state.set(StateKeys.dstOffset, frame.payload.dstOffset);
            return true;
        }
        return false;
    },
};
const respondToScheduleEntryLockTimeOffsetGet = {
    async onControllerFrame(controller, self, frame) {
        if (frame.type === testing_1.MockZWaveFrameType.Request
            && frame.payload instanceof ScheduleEntryLockCC_1.ScheduleEntryLockCCTimeOffsetGet) {
            const cc = new ScheduleEntryLockCC_1.ScheduleEntryLockCCTimeOffsetReport(self.host, {
                nodeId: controller.host.ownNodeId,
                standardOffset: (self.state.get(StateKeys.standardOffset)
                    ?? 0),
                dstOffset: (self.state.get(StateKeys.dstOffset) ?? 0),
            });
            await self.sendToController((0, testing_1.createMockZWaveRequestFrame)(cc, {
                ackRequested: false,
            }));
            return true;
        }
        return false;
    },
};
const respondToScheduleEntryLockEnableSet = {
    onControllerFrame(controller, self, frame) {
        if (frame.type === testing_1.MockZWaveFrameType.Request
            && frame.payload instanceof ScheduleEntryLockCC_1.ScheduleEntryLockCCEnableSet) {
            // No need to do anything, this cannot be queried
            return true;
        }
        return false;
    },
};
const respondToScheduleEntryLockEnableAllSet = {
    onControllerFrame(controller, self, frame) {
        if (frame.type === testing_1.MockZWaveFrameType.Request
            && frame.payload instanceof ScheduleEntryLockCC_1.ScheduleEntryLockCCEnableAllSet) {
            // No need to do anything, this cannot be queried
            return true;
        }
        return false;
    },
};
const respondToScheduleEntryLockWeekDayScheduleSet = {
    onControllerFrame(controller, self, frame) {
        if (frame.type === testing_1.MockZWaveFrameType.Request
            && frame.payload instanceof ScheduleEntryLockCC_1.ScheduleEntryLockCCWeekDayScheduleSet) {
            const userCodeCapabilities = {
                ...UserCode_1.defaultCapabilities,
                ...self.getCCCapabilities(safe_1.CommandClasses["User Code"], frame.payload.endpointIndex),
            };
            // If the user identifier is out of range, the command will be ignored
            const userId = frame.payload.userId;
            if (userId > userCodeCapabilities.numUsers)
                return true;
            const capabilities = {
                ...defaultCapabilities,
                ...self.getCCCapabilities(safe_1.CommandClasses["Schedule Entry Lock"], frame.payload.endpointIndex),
            };
            const slotId = frame.payload.slotId;
            // Ignore out of range slot queries
            if (slotId > capabilities.numWeekDaySlots)
                return true;
            const kind = cc_1.ScheduleEntryLockScheduleKind.WeekDay;
            const schedule = frame.payload.action === cc_1.ScheduleEntryLockSetAction.Set
                ? {
                    weekday: frame.payload.weekday,
                    startHour: frame.payload.startHour,
                    startMinute: frame.payload.startMinute,
                    stopHour: frame.payload.stopHour,
                    stopMinute: frame.payload.stopMinute,
                }
                : undefined;
            self.state.set(StateKeys.schedule(userId, slotId, kind), schedule);
            return true;
        }
        return false;
    },
};
const respondToScheduleEntryLockWeekDayScheduleGet = {
    async onControllerFrame(controller, self, frame) {
        if (frame.type === testing_1.MockZWaveFrameType.Request
            && frame.payload instanceof ScheduleEntryLockCC_1.ScheduleEntryLockCCWeekDayScheduleGet) {
            const userCodeCapabilities = {
                ...UserCode_1.defaultCapabilities,
                ...self.getCCCapabilities(safe_1.CommandClasses["User Code"], frame.payload.endpointIndex),
            };
            // If the user identifier is out of range, the command will be ignored
            const userId = frame.payload.userId;
            if (userId > userCodeCapabilities.numUsers)
                return true;
            const capabilities = {
                ...defaultCapabilities,
                ...self.getCCCapabilities(safe_1.CommandClasses["Schedule Entry Lock"], frame.payload.endpointIndex),
            };
            const slotId = frame.payload.slotId;
            // Ignore out of range slot queries
            if (slotId > capabilities.numWeekDaySlots)
                return true;
            const kind = cc_1.ScheduleEntryLockScheduleKind.WeekDay;
            const schedule = (self.state.get(StateKeys.schedule(userId, slotId, kind)) ?? {});
            const cc = new ScheduleEntryLockCC_1.ScheduleEntryLockCCWeekDayScheduleReport(self.host, {
                nodeId: controller.host.ownNodeId,
                userId,
                slotId,
                ...schedule,
            });
            await self.sendToController((0, testing_1.createMockZWaveRequestFrame)(cc, {
                ackRequested: false,
            }));
            return true;
        }
        return false;
    },
};
const respondToScheduleEntryLockYearDayScheduleSet = {
    onControllerFrame(controller, self, frame) {
        if (frame.type === testing_1.MockZWaveFrameType.Request
            && frame.payload instanceof ScheduleEntryLockCC_1.ScheduleEntryLockCCYearDayScheduleSet) {
            const userCodeCapabilities = {
                ...UserCode_1.defaultCapabilities,
                ...self.getCCCapabilities(safe_1.CommandClasses["User Code"], frame.payload.endpointIndex),
            };
            // If the user identifier is out of range, the command will be ignored
            const userId = frame.payload.userId;
            if (userId > userCodeCapabilities.numUsers)
                return true;
            const capabilities = {
                ...defaultCapabilities,
                ...self.getCCCapabilities(safe_1.CommandClasses["Schedule Entry Lock"], frame.payload.endpointIndex),
            };
            const slotId = frame.payload.slotId;
            // Ignore out of range slot queries
            if (slotId > capabilities.numYearDaySlots)
                return true;
            const kind = cc_1.ScheduleEntryLockScheduleKind.YearDay;
            const schedule = frame.payload.action === cc_1.ScheduleEntryLockSetAction.Set
                ? {
                    startYear: frame.payload.startYear,
                    startMonth: frame.payload.startMonth,
                    startDay: frame.payload.startDay,
                    startHour: frame.payload.startHour,
                    startMinute: frame.payload.startMinute,
                    stopYear: frame.payload.stopYear,
                    stopMonth: frame.payload.stopMonth,
                    stopDay: frame.payload.stopDay,
                    stopHour: frame.payload.stopHour,
                    stopMinute: frame.payload.stopMinute,
                }
                : undefined;
            self.state.set(StateKeys.schedule(userId, slotId, kind), schedule);
            return true;
        }
        return false;
    },
};
const respondToScheduleEntryLockYearDayScheduleGet = {
    async onControllerFrame(controller, self, frame) {
        if (frame.type === testing_1.MockZWaveFrameType.Request
            && frame.payload instanceof ScheduleEntryLockCC_1.ScheduleEntryLockCCYearDayScheduleGet) {
            const userCodeCapabilities = {
                ...UserCode_1.defaultCapabilities,
                ...self.getCCCapabilities(safe_1.CommandClasses["User Code"], frame.payload.endpointIndex),
            };
            // If the user identifier is out of range, the command will be ignored
            const userId = frame.payload.userId;
            if (userId > userCodeCapabilities.numUsers)
                return true;
            const capabilities = {
                ...defaultCapabilities,
                ...self.getCCCapabilities(safe_1.CommandClasses["Schedule Entry Lock"], frame.payload.endpointIndex),
            };
            const slotId = frame.payload.slotId;
            // Ignore out of range slot queries
            if (slotId > capabilities.numYearDaySlots)
                return true;
            const kind = cc_1.ScheduleEntryLockScheduleKind.YearDay;
            const schedule = (self.state.get(StateKeys.schedule(userId, slotId, kind)) ?? {});
            const cc = new ScheduleEntryLockCC_1.ScheduleEntryLockCCYearDayScheduleReport(self.host, {
                nodeId: controller.host.ownNodeId,
                userId,
                slotId,
                ...schedule,
            });
            await self.sendToController((0, testing_1.createMockZWaveRequestFrame)(cc, {
                ackRequested: false,
            }));
            return true;
        }
        return false;
    },
};
const respondToScheduleEntryLockDailyRepeatingScheduleSet = {
    onControllerFrame(controller, self, frame) {
        if (frame.type === testing_1.MockZWaveFrameType.Request
            && frame.payload
                instanceof ScheduleEntryLockCC_1.ScheduleEntryLockCCDailyRepeatingScheduleSet) {
            const userCodeCapabilities = {
                ...UserCode_1.defaultCapabilities,
                ...self.getCCCapabilities(safe_1.CommandClasses["User Code"], frame.payload.endpointIndex),
            };
            // If the user identifier is out of range, the command will be ignored
            const userId = frame.payload.userId;
            if (userId > userCodeCapabilities.numUsers)
                return true;
            const capabilities = {
                ...defaultCapabilities,
                ...self.getCCCapabilities(safe_1.CommandClasses["Schedule Entry Lock"], frame.payload.endpointIndex),
            };
            const slotId = frame.payload.slotId;
            // Ignore out of range slot queries
            if (slotId > capabilities.numDailyRepeatingSlots)
                return true;
            const kind = cc_1.ScheduleEntryLockScheduleKind.DailyRepeating;
            const schedule = frame.payload.action === cc_1.ScheduleEntryLockSetAction.Set
                ? {
                    weekdays: frame.payload.weekdays,
                    startHour: frame.payload.startHour,
                    startMinute: frame.payload.startMinute,
                    durationHour: frame.payload.durationHour,
                    durationMinute: frame.payload.durationMinute,
                }
                : undefined;
            self.state.set(StateKeys.schedule(userId, slotId, kind), schedule);
            return true;
        }
        return false;
    },
};
const respondToScheduleEntryLockDailyRepeatingScheduleGet = {
    async onControllerFrame(controller, self, frame) {
        if (frame.type === testing_1.MockZWaveFrameType.Request
            && frame.payload
                instanceof ScheduleEntryLockCC_1.ScheduleEntryLockCCDailyRepeatingScheduleGet) {
            const userCodeCapabilities = {
                ...UserCode_1.defaultCapabilities,
                ...self.getCCCapabilities(safe_1.CommandClasses["User Code"], frame.payload.endpointIndex),
            };
            // If the user identifier is out of range, the command will be ignored
            const userId = frame.payload.userId;
            if (userId > userCodeCapabilities.numUsers)
                return true;
            const capabilities = {
                ...defaultCapabilities,
                ...self.getCCCapabilities(safe_1.CommandClasses["Schedule Entry Lock"], frame.payload.endpointIndex),
            };
            const slotId = frame.payload.slotId;
            // Ignore out of range slot queries
            if (slotId > capabilities.numDailyRepeatingSlots)
                return true;
            const kind = cc_1.ScheduleEntryLockScheduleKind.DailyRepeating;
            const schedule = (self.state.get(StateKeys.schedule(userId, slotId, kind)) ?? {});
            const cc = new ScheduleEntryLockCC_1.ScheduleEntryLockCCDailyRepeatingScheduleReport(self.host, {
                nodeId: controller.host.ownNodeId,
                userId,
                slotId,
                ...schedule,
            });
            await self.sendToController((0, testing_1.createMockZWaveRequestFrame)(cc, {
                ackRequested: false,
            }));
            return true;
        }
        return false;
    },
};
exports.ScheduleEntryLockCCBehaviors = [
    respondToScheduleEntryLockSupportedGet,
    respondToScheduleEntryLockTimeOffsetSet,
    respondToScheduleEntryLockTimeOffsetGet,
    respondToScheduleEntryLockEnableSet,
    respondToScheduleEntryLockEnableAllSet,
    respondToScheduleEntryLockWeekDayScheduleSet,
    respondToScheduleEntryLockWeekDayScheduleGet,
    respondToScheduleEntryLockYearDayScheduleSet,
    respondToScheduleEntryLockYearDayScheduleGet,
    respondToScheduleEntryLockDailyRepeatingScheduleSet,
    respondToScheduleEntryLockDailyRepeatingScheduleGet,
];
//# sourceMappingURL=ScheduleEntryLock.js.map