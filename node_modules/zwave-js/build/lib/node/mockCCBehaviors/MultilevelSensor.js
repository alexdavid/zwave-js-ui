"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultilevelSensorCCBehaviors = void 0;
const cc_1 = require("@zwave-js/cc");
const core_1 = require("@zwave-js/core");
const testing_1 = require("@zwave-js/testing");
const defaultCapabilities = {
    sensors: {}, // none
};
const respondToMultilevelSensorGetSupportedSensor = {
    async onControllerFrame(controller, self, frame) {
        if (frame.type === testing_1.MockZWaveFrameType.Request
            && frame.payload instanceof cc_1.MultilevelSensorCCGetSupportedSensor) {
            const capabilities = {
                ...defaultCapabilities,
                ...self.getCCCapabilities(core_1.CommandClasses["Multilevel Sensor"], frame.payload.endpointIndex),
            };
            const cc = new cc_1.MultilevelSensorCCSupportedSensorReport(self.host, {
                nodeId: controller.host.ownNodeId,
                supportedSensorTypes: Object.keys(capabilities.sensors).map((t) => parseInt(t)),
            });
            await self.sendToController((0, testing_1.createMockZWaveRequestFrame)(cc, {
                ackRequested: false,
            }));
            return true;
        }
        return false;
    },
};
const respondToMultilevelSensorGetSupportedScale = {
    async onControllerFrame(controller, self, frame) {
        if (frame.type === testing_1.MockZWaveFrameType.Request
            && frame.payload instanceof cc_1.MultilevelSensorCCGetSupportedScale) {
            const capabilities = {
                ...defaultCapabilities,
                ...self.getCCCapabilities(core_1.CommandClasses["Multilevel Sensor"], frame.payload.endpointIndex),
            };
            const sensorType = frame.payload.sensorType;
            const supportedScales = capabilities.sensors[sensorType]?.supportedScales ?? [];
            const cc = new cc_1.MultilevelSensorCCSupportedScaleReport(self.host, {
                nodeId: controller.host.ownNodeId,
                sensorType,
                supportedScales,
            });
            await self.sendToController((0, testing_1.createMockZWaveRequestFrame)(cc, {
                ackRequested: false,
            }));
            return true;
        }
        return false;
    },
};
const respondToMultilevelSensorGet = {
    async onControllerFrame(controller, self, frame) {
        if (frame.type === testing_1.MockZWaveFrameType.Request
            && frame.payload instanceof cc_1.MultilevelSensorCCGet) {
            const capabilities = {
                ...defaultCapabilities,
                ...self.getCCCapabilities(core_1.CommandClasses["Multilevel Sensor"], frame.payload.endpointIndex),
            };
            const firstSupportedSensorType = Object.keys(capabilities.sensors).length > 0
                ? parseInt(Object.keys(capabilities.sensors)[0])
                : undefined;
            const sensorType = frame.payload.sensorType
                ?? firstSupportedSensorType
                ?? 1;
            const scale = frame.payload.scale
                ?? capabilities.sensors[sensorType].supportedScales[0]
                ?? 0;
            const value = capabilities.getValue?.(sensorType, scale) ?? 0;
            const cc = new cc_1.MultilevelSensorCCReport(self.host, {
                nodeId: controller.host.ownNodeId,
                type: sensorType,
                scale,
                value,
            });
            await self.sendToController((0, testing_1.createMockZWaveRequestFrame)(cc, {
                ackRequested: false,
            }));
            return true;
        }
        return false;
    },
};
exports.MultilevelSensorCCBehaviors = [
    respondToMultilevelSensorGetSupportedSensor,
    respondToMultilevelSensorGetSupportedScale,
    respondToMultilevelSensorGet,
];
//# sourceMappingURL=MultilevelSensor.js.map