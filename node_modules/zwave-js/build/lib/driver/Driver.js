"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Driver = exports.libName = exports.libVersion = void 0;
const jsonl_db_1 = require("@alcalzone/jsonl-db");
const cc_1 = require("@zwave-js/cc");
const config_1 = require("@zwave-js/config");
const core_1 = require("@zwave-js/core");
const serial_1 = require("@zwave-js/serial");
const shared_1 = require("@zwave-js/shared");
const arrays_1 = require("alcalzone-shared/arrays");
const async_1 = require("alcalzone-shared/async");
const deferred_promise_1 = require("alcalzone-shared/deferred-promise");
const typeguards_1 = require("alcalzone-shared/typeguards");
const fs_extra_1 = __importDefault(require("fs-extra"));
const node_crypto_1 = require("node:crypto");
const node_os_1 = __importDefault(require("node:os"));
const node_path_1 = __importDefault(require("node:path"));
const node_url_1 = require("node:url");
const util = __importStar(require("node:util"));
const serialport_1 = require("serialport");
const xstate_1 = require("xstate");
const Controller_1 = require("../controller/Controller");
const Inclusion_1 = require("../controller/Inclusion");
const Driver_1 = require("../log/Driver");
const _Types_1 = require("../node/_Types");
const ApplicationCommandRequest_1 = require("../serialapi/application/ApplicationCommandRequest");
const ApplicationUpdateRequest_1 = require("../serialapi/application/ApplicationUpdateRequest");
const BridgeApplicationCommandRequest_1 = require("../serialapi/application/BridgeApplicationCommandRequest");
const GetControllerVersionMessages_1 = require("../serialapi/capability/GetControllerVersionMessages");
const SoftResetRequest_1 = require("../serialapi/misc/SoftResetRequest");
const SendDataBridgeMessages_1 = require("../serialapi/transport/SendDataBridgeMessages");
const SendDataMessages_1 = require("../serialapi/transport/SendDataMessages");
const SendDataShared_1 = require("../serialapi/transport/SendDataShared");
const deviceConfig_1 = require("../telemetry/deviceConfig");
const statistics_1 = require("../telemetry/statistics");
const Bootloader_1 = require("./Bootloader");
const MessageGenerators_1 = require("./MessageGenerators");
const NetworkCache_1 = require("./NetworkCache");
const Queue_1 = require("./Queue");
const SerialAPICommandMachine_1 = require("./SerialAPICommandMachine");
const StateMachineShared_1 = require("./StateMachineShared");
const ThrottlePresets_1 = require("./ThrottlePresets");
const Transaction_1 = require("./Transaction");
const TransportServiceMachine_1 = require("./TransportServiceMachine");
const UpdateConfig_1 = require("./UpdateConfig");
const UserAgent_1 = require("./UserAgent");
const mDNSDiscovery_1 = require("./mDNSDiscovery");
const packageJsonPath = require.resolve("zwave-js/package.json");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const packageJson = require(packageJsonPath);
const libraryRootDir = node_path_1.default.dirname(packageJsonPath);
exports.libVersion = packageJson.version;
exports.libName = packageJson.name;
// This is made with cfonts:
const libNameString = `
███████╗        ██╗    ██╗  █████╗  ██╗   ██╗ ███████╗          ██╗ ███████╗
╚══███╔╝        ██║    ██║ ██╔══██╗ ██║   ██║ ██╔════╝          ██║ ██╔════╝
  ███╔╝  █████╗ ██║ █╗ ██║ ███████║ ██║   ██║ █████╗            ██║ ███████╗
 ███╔╝   ╚════╝ ██║███╗██║ ██╔══██║ ╚██╗ ██╔╝ ██╔══╝       ██   ██║ ╚════██║
███████╗        ╚███╔███╔╝ ██║  ██║  ╚████╔╝  ███████╗     ╚█████╔╝ ███████║
╚══════╝         ╚══╝╚══╝  ╚═╝  ╚═╝   ╚═══╝   ╚══════╝      ╚════╝  ╚══════╝
`;
const defaultOptions = {
    timeouts: {
        ack: 1000,
        byte: 150,
        // Ideally we'd want to have this as low as possible, but some
        // 500 series controllers can take several seconds to respond sometimes.
        response: 10000,
        report: 1000,
        nonce: 5000,
        sendDataAbort: 20000,
        sendDataCallback: 30000,
        sendToSleep: 250,
        retryJammed: 1000,
        refreshValue: 5000,
        refreshValueAfterTransition: 1000,
        serialAPIStarted: 5000,
    },
    attempts: {
        openSerialPort: 10,
        controller: 3,
        sendData: 3,
        sendDataJammed: 5,
        nodeInterview: 5,
    },
    disableOptimisticValueUpdate: false,
    features: {
        // By default enable soft reset unless the env variable is set
        softReset: !process.env.ZWAVEJS_DISABLE_SOFT_RESET,
        // By default enable the unresponsive controller recovery unless the env variable is set
        unresponsiveControllerRecovery: !process.env
            .ZWAVEJS_DISABLE_UNRESPONSIVE_CONTROLLER_RECOVERY,
    },
    interview: {
        queryAllUserCodes: false,
    },
    storage: {
        driver: fs_extra_1.default,
        cacheDir: node_path_1.default.resolve(libraryRootDir, "cache"),
        lockDir: process.env.ZWAVEJS_LOCK_DIRECTORY,
        throttle: "normal",
    },
    preferences: {
        scales: {},
    },
};
/** Ensures that the options are valid */
function checkOptions(options) {
    if (options.timeouts.ack < 1) {
        throw new core_1.ZWaveError(`The ACK timeout must be positive!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
    }
    if (options.timeouts.byte < 1) {
        throw new core_1.ZWaveError(`The BYTE timeout must be positive!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
    }
    if (options.timeouts.response < 500 || options.timeouts.response > 60000) {
        throw new core_1.ZWaveError(`The Response timeout must be between 500 and 60000 milliseconds!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
    }
    if (options.timeouts.report < 500 || options.timeouts.report > 10000) {
        throw new core_1.ZWaveError(`The Report timeout must be between 500 and 10000 milliseconds!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
    }
    if (options.timeouts.nonce < 3000 || options.timeouts.nonce > 20000) {
        throw new core_1.ZWaveError(`The Nonce timeout must be between 3000 and 20000 milliseconds!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
    }
    if (options.timeouts.retryJammed < 10 || options.timeouts.retryJammed > 5000) {
        throw new core_1.ZWaveError(`The timeout for retrying while jammed must be between 10 and 5000 milliseconds!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
    }
    if (options.timeouts.sendToSleep < 10 || options.timeouts.sendToSleep > 5000) {
        throw new core_1.ZWaveError(`The Send To Sleep timeout must be between 10 and 5000 milliseconds!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
    }
    if (options.timeouts.sendDataCallback < 10000) {
        throw new core_1.ZWaveError(`The Send Data Callback timeout must be at least 10000 milliseconds!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
    }
    if (options.timeouts.sendDataAbort < 5000
        || options.timeouts.sendDataAbort
            > options.timeouts.sendDataCallback - 5000) {
        throw new core_1.ZWaveError(`The Send Data Abort Callback timeout must be between 5000 and ${options.timeouts.sendDataCallback - 5000} milliseconds!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
    }
    if (options.timeouts.serialAPIStarted < 1000
        || options.timeouts.serialAPIStarted > 30000) {
        throw new core_1.ZWaveError(`The Serial API started timeout must be between 1000 and 30000 milliseconds!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
    }
    if (options.securityKeys != undefined) {
        const keys = Object.entries(options.securityKeys);
        for (let i = 0; i < keys.length; i++) {
            const [secClass, key] = keys[i];
            if (key.length !== 16) {
                throw new core_1.ZWaveError(`The security key for class ${secClass} must be a buffer with length 16!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
            }
            if (keys.findIndex(([, k]) => k.equals(key)) !== i) {
                throw new core_1.ZWaveError(`The security key for class ${secClass} was used multiple times!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
            }
        }
    }
    if (options.attempts.controller < 1 || options.attempts.controller > 3) {
        throw new core_1.ZWaveError(`The Controller attempts must be between 1 and 3!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
    }
    if (options.attempts.sendData < 1
        || options.attempts.sendData > SendDataMessages_1.MAX_SEND_ATTEMPTS) {
        throw new core_1.ZWaveError(`The SendData attempts must be between 1 and ${SendDataMessages_1.MAX_SEND_ATTEMPTS}!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
    }
    if (options.attempts.sendDataJammed < 1
        || options.attempts.sendDataJammed > 10) {
        throw new core_1.ZWaveError(`The SendData attempts while jammed must be between 1 and 10!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
    }
    if (options.attempts.nodeInterview < 1
        || options.attempts.nodeInterview > 10) {
        throw new core_1.ZWaveError(`The Node interview attempts must be between 1 and 10!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
    }
    if (options.inclusionUserCallbacks) {
        if (!(0, typeguards_1.isObject)(options.inclusionUserCallbacks)) {
            throw new core_1.ZWaveError(`The inclusionUserCallbacks must be an object!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
        }
        else if (typeof options.inclusionUserCallbacks.grantSecurityClasses
            !== "function"
            || typeof options.inclusionUserCallbacks.validateDSKAndEnterPIN
                !== "function"
            || typeof options.inclusionUserCallbacks.abort !== "function") {
            throw new core_1.ZWaveError(`The inclusionUserCallbacks must contain the following functions: grantSecurityClasses, validateDSKAndEnterPIN, abort!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
        }
    }
    if (options.rf != undefined) {
        if (options.rf.region != undefined) {
            if (typeof options.rf.region !== "number"
                || !(options.rf.region in core_1.RFRegion)
                || options.rf.region === core_1.RFRegion.Unknown) {
                throw new core_1.ZWaveError(`${options.rf.region} is not a valid RF region!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
            }
        }
        if (options.rf.txPower != undefined) {
            if (!(0, typeguards_1.isObject)(options.rf.txPower)) {
                throw new core_1.ZWaveError(`rf.txPower must be an object!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
            }
            else if (typeof options.rf.txPower.powerlevel !== "number"
                || typeof options.rf.txPower.measured0dBm !== "number") {
                throw new core_1.ZWaveError(`rf.txPower must contain the following numeric properties: powerlevel, measured0dBm!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
            }
        }
    }
}
/**
 * The driver is the core of this library. It controls the serial interface,
 * handles transmission and receipt of messages and manages the network cache.
 * Any action you want to perform on the Z-Wave network must go through a driver
 * instance or its associated nodes.
 */
class Driver extends shared_1.TypedEventEmitter {
    port;
    constructor(port, ...optionsAndPresets) {
        super();
        this.port = port;
        // Ensure the given serial port is valid
        if (typeof port !== "string"
            && !(0, serial_1.isZWaveSerialPortImplementation)(port)) {
            throw new core_1.ZWaveError(`The port must be a string or a valid custom serial port implementation!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
        }
        // Deep-Merge all given options/presets
        const definedOptionsAndPresets = optionsAndPresets.filter((o) => !!o);
        let mergedOptions = {};
        for (const preset of definedOptionsAndPresets) {
            mergedOptions = (0, shared_1.mergeDeep)(mergedOptions, preset, true);
        }
        // Finally apply the defaults, without overwriting any existing settings
        this._options = (0, shared_1.mergeDeep)(mergedOptions, (0, shared_1.cloneDeep)(defaultOptions));
        // Normalize deprecated options
        // TODO: Remove test in packages/zwave-js/src/lib/test/driver/sendDataMissingCallbackAbort.test.ts
        // when the deprecated option is removed
        if (
        // eslint-disable-next-line deprecation/deprecation
        this._options.enableSoftReset === false
            && this._options.features.softReset) {
            this._options.features.softReset = false;
        }
        // And make sure they contain valid values
        checkOptions(this._options);
        if (this._options.userAgent) {
            if (!(0, typeguards_1.isObject)(this._options.userAgent)) {
                throw new core_1.ZWaveError(`The userAgent property must be an object!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
            }
            this.updateUserAgent(this._options.userAgent);
        }
        // Initialize logging
        this._logContainer = new core_1.ZWaveLogContainer(this._options.logConfig);
        this._driverLog = new Driver_1.DriverLogger(this, this._logContainer);
        this._controllerLog = new core_1.ControllerLogger(this._logContainer);
        // Initialize the cache
        this.cacheDir = this._options.storage.cacheDir;
        // Initialize config manager
        this.configManager = new config_1.ConfigManager({
            logContainer: this._logContainer,
            deviceConfigPriorityDir: this._options.storage.deviceConfigPriorityDir,
        });
        this.immediateQueue = new Queue_1.TransactionQueue({
            name: "immediate",
            mayStartNextTransaction: (t) => {
                // While the controller is unresponsive, only soft resetting is allowed.
                // Since we use GetControllerVersionRequest to check if the controller responds after soft-reset,
                // allow that too.
                if (this.controller.status === core_1.ControllerStatus.Unresponsive) {
                    return t.message instanceof SoftResetRequest_1.SoftResetRequest
                        || t.message instanceof GetControllerVersionMessages_1.GetControllerVersionRequest;
                }
                // All other messages on the immediate queue may always be sent as long as the controller is ready to send
                return !this.queuePaused
                    && this.controller.status === core_1.ControllerStatus.Ready;
            },
        });
        this.queue = new Queue_1.TransactionQueue({
            name: "normal",
            mayStartNextTransaction: (t) => this.mayStartTransaction(t),
        });
        this.serialAPIQueue = new shared_1.AsyncQueue();
        this._queueIdle = false;
    }
    /** The serial port instance */
    serial;
    // We have multiple queues to achieve multiple "layers" of communication priority:
    // The default queue for most messages
    queue;
    // An immediate queue for handling queries that need to be handled ASAP, e.g. Nonce Get
    immediateQueue;
    // And all of them feed into the serial API queue, which contains commands that will be sent ASAP
    serialAPIQueue;
    /** Gives access to the transaction queues, ordered by priority */
    get queues() {
        return [this.immediateQueue, this.queue];
    }
    queuePaused = false;
    /** The interpreter for the currently active Serial API command */
    serialAPIInterpreter;
    // Keep track of which queues are currently busy
    _queuesBusyFlags = 0;
    _queueIdle;
    /** Whether the queue is currently idle */
    get queueIdle() {
        return this._queueIdle;
    }
    set queueIdle(value) {
        if (this._queueIdle !== value) {
            this.driverLog.print(`all queues ${value ? "idle" : "busy"}`);
            this._queueIdle = value;
            this.handleQueueIdleChange(value);
        }
    }
    /** A map of handlers for all sorts of requests */
    requestHandlers = new Map();
    /** A list of awaited message headers */
    awaitedMessageHeaders = [];
    /** A list of awaited messages */
    awaitedMessages = [];
    /** A list of awaited commands */
    awaitedCommands = [];
    /** A list of awaited chunks from the bootloader */
    awaitedBootloaderChunks = [];
    /** A map of Node ID -> ongoing sessions */
    nodeSessions = new Map();
    ensureNodeSessions(nodeId) {
        if (!this.nodeSessions.has(nodeId)) {
            this.nodeSessions.set(nodeId, {
                transportService: new Map(),
                supervision: new Map(),
            });
        }
        return this.nodeSessions.get(nodeId);
    }
    cacheDir;
    _valueDB;
    /** @internal */
    get valueDB() {
        return this._valueDB;
    }
    _metadataDB;
    /** @internal */
    get metadataDB() {
        return this._metadataDB;
    }
    _networkCache;
    /** @internal */
    get networkCache() {
        if (this._networkCache == undefined) {
            throw new core_1.ZWaveError("The network cache was not yet initialized!", core_1.ZWaveErrorCodes.Driver_NotReady);
        }
        return this._networkCache;
    }
    configManager;
    get configVersion() {
        return (this.configManager?.configVersion
            ?? packageJson?.dependencies?.["@zwave-js/config"]
            ?? exports.libVersion);
    }
    _logContainer;
    _driverLog;
    /** @internal */
    get driverLog() {
        return this._driverLog;
    }
    _controllerLog;
    /**
     * **!!! INTERNAL !!!**
     *
     * Not intended to be used by applications
     */
    get controllerLog() {
        return this._controllerLog;
    }
    _controller;
    /** Encapsulates information about the Z-Wave controller and provides access to its nodes */
    get controller() {
        if (this._controller == undefined) {
            throw new core_1.ZWaveError("The controller is not yet ready!", core_1.ZWaveErrorCodes.Driver_NotReady);
        }
        return this._controller;
    }
    /** While in bootloader mode, this encapsulates information about the bootloader and its state */
    _bootloader;
    /** @internal */
    get bootloader() {
        if (this._bootloader == undefined) {
            throw new core_1.ZWaveError("The controller is not in bootloader mode!", core_1.ZWaveErrorCodes.Driver_NotReady);
        }
        return this._bootloader;
    }
    isInBootloader() {
        return this._bootloader != undefined;
    }
    _recoveryPhase = 0 /* ControllerRecoveryPhase.None */;
    _securityManager;
    /**
     * **!!! INTERNAL !!!**
     *
     * Not intended to be used by applications
     */
    get securityManager() {
        return this._securityManager;
    }
    _securityManager2;
    /**
     * **!!! INTERNAL !!!**
     *
     * Not intended to be used by applications
     */
    get securityManager2() {
        return this._securityManager2;
    }
    /**
     * **!!! INTERNAL !!!**
     *
     * Not intended to be used by applications. Use `controller.homeId` instead!
     */
    get homeId() {
        // This is needed for the ZWaveHost interface
        return this.controller.homeId;
    }
    /**
     * **!!! INTERNAL !!!**
     *
     * Not intended to be used by applications. Use `controller.ownNodeId` instead!
     */
    get ownNodeId() {
        // This is needed for the ZWaveHost interface
        return this.controller.ownNodeId;
    }
    get nodeIdType() {
        return this._controller?.nodeIdType ?? core_1.NodeIDType.Short;
    }
    /**
     * **!!! INTERNAL !!!**
     *
     * Not intended to be used by applications. Use `controller.nodes` instead!
     */
    get nodes() {
        // This is needed for the ZWaveHost interface
        return this.controller.nodes;
    }
    getNodeUnsafe(msg) {
        const nodeId = msg.getNodeId();
        if (nodeId != undefined)
            return this.controller.nodes.get(nodeId);
    }
    tryGetEndpoint(cc) {
        if (cc.isSinglecast()) {
            return this.controller.nodes
                .get(cc.nodeId)
                ?.getEndpoint(cc.endpointIndex);
        }
    }
    /**
     * **!!! INTERNAL !!!**
     *
     * Not intended to be used by applications
     */
    getValueDB(nodeId) {
        // This is needed for the ZWaveHost interface
        const node = this.controller.nodes.getOrThrow(nodeId);
        return node.valueDB;
    }
    /**
     * **!!! INTERNAL !!!**
     *
     * Not intended to be used by applications
     */
    tryGetValueDB(nodeId) {
        // This is needed for the ZWaveHost interface
        const node = this.controller.nodes.get(nodeId);
        return node?.valueDB;
    }
    getDeviceConfig(nodeId) {
        // This is needed for the ZWaveHost interface
        return this.controller.nodes.get(nodeId)?.deviceConfig;
    }
    getHighestSecurityClass(nodeId) {
        // This is needed for the ZWaveHost interface
        const node = this.controller.nodes.getOrThrow(nodeId);
        return node.getHighestSecurityClass();
    }
    hasSecurityClass(nodeId, securityClass) {
        // This is needed for the ZWaveHost interface
        const node = this.controller.nodes.getOrThrow(nodeId);
        return node.hasSecurityClass(securityClass);
    }
    /**
     * **!!! INTERNAL !!!**
     *
     * Not intended to be used by applications
     */
    setSecurityClass(nodeId, securityClass, granted) {
        // This is needed for the ZWaveHost interface
        const node = this.controller.nodes.getOrThrow(nodeId);
        node.setSecurityClass(securityClass, granted);
    }
    /**
     * **!!! INTERNAL !!!**
     *
     * Not intended to be used by applications. Use `node.isControllerNode` instead!
     */
    isControllerNode(nodeId) {
        // This is needed for the ZWaveHost interface
        return nodeId === this.ownNodeId;
    }
    /** Updates the logging configuration without having to restart the driver. */
    updateLogConfig(config) {
        this._logContainer.updateConfiguration(config);
    }
    /** Returns the current logging configuration. */
    getLogConfig() {
        return this._logContainer.getConfiguration();
    }
    /** Updates the preferred sensor scales to use for node queries */
    setPreferredScales(scales) {
        this._options.preferences.scales = (0, shared_1.mergeDeep)(defaultOptions.preferences.scales, scales);
    }
    /**
     * Enumerates all existing serial ports.
     * @param local Whether to include local serial ports
     * @param remote Whether to discover remote serial ports using an mDNS query for the `_zwave._tcp` domain
     */
    static async enumerateSerialPorts({ local = true, remote = true, } = {}) {
        const symlinkedPorts = [];
        const localPorts = [];
        const remotePorts = [];
        if (local) {
            // Put symlinks to the serial ports first if possible
            if (node_os_1.default.platform() === "linux") {
                const dir = "/dev/serial/by-id";
                const symlinks = await fs_extra_1.default.readdir(dir).catch(() => []);
                for (const l of symlinks) {
                    try {
                        const fullPath = node_path_1.default.join(dir, l);
                        const target = node_path_1.default.join(dir, await fs_extra_1.default.readlink(fullPath));
                        if (!target.startsWith("/dev/tty"))
                            continue;
                        symlinkedPorts.push(fullPath);
                    }
                    catch {
                        // Ignore. The target might not exist or we might not have access.
                    }
                }
            }
            // Then the actual serial ports
            const ports = await serialport_1.SerialPort.list();
            localPorts.push(...ports.map((port) => port.path));
        }
        if (remote) {
            const ports = await (0, mDNSDiscovery_1.discoverRemoteSerialPorts)();
            if (ports) {
                remotePorts.push(...ports.map((p) => p.port));
            }
        }
        return (0, arrays_1.distinct)([...symlinkedPorts, ...remotePorts, ...localPorts]);
    }
    /** Updates a subset of the driver options on the fly */
    updateOptions(options) {
        // This code is called from user code, so we need to make sure no options were passed
        // which we are not able to update on the fly
        const safeOptions = (0, shared_1.pick)(options, [
            "disableOptimisticValueUpdate",
            "emitValueUpdateAfterSetValue",
            "inclusionUserCallbacks",
            "interview",
            "preferences",
        ]);
        // Create a new deep-merged copy of the options so we can check them for validity
        // without affecting our own options
        const newOptions = (0, shared_1.mergeDeep)((0, shared_1.cloneDeep)(this._options), safeOptions, true);
        checkOptions(newOptions);
        if (options.userAgent && !(0, typeguards_1.isObject)(options.userAgent)) {
            throw new core_1.ZWaveError(`The userAgent property must be an object!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
        }
        // All good, update the options
        this._options = newOptions;
        if (options.logConfig) {
            this.updateLogConfig(options.logConfig);
        }
        if (options.userAgent) {
            this.updateUserAgent(options.userAgent);
        }
    }
    _options;
    get options() {
        return this._options;
    }
    _wasStarted = false;
    _isOpen = false;
    /** Start the driver */
    async start() {
        // avoid starting twice
        if (this.wasDestroyed) {
            throw new core_1.ZWaveError("The driver was destroyed. Create a new instance and start that one.", core_1.ZWaveErrorCodes.Driver_Destroyed);
        }
        if (this._wasStarted)
            return Promise.resolve();
        this._wasStarted = true;
        // Enforce that an error handler is attached, except for testing with a mocked serialport
        if (!this._options.testingHooks
            && this.listenerCount("error") === 0) {
            throw new core_1.ZWaveError(`Before starting the driver, a handler for the "error" event must be attached.`, core_1.ZWaveErrorCodes.Driver_NoErrorHandler);
        }
        const spOpenPromise = (0, deferred_promise_1.createDeferredPromise)();
        // Log which version is running
        this.driverLog.print(libNameString, "info");
        this.driverLog.print(`version ${exports.libVersion}`, "info");
        this.driverLog.print("", "info");
        this.driverLog.print("starting driver...");
        // Open the serial port
        if (typeof this.port === "string") {
            if (this.port.startsWith("tcp://")) {
                const url = new node_url_1.URL(this.port);
                this.driverLog.print(`opening serial port ${this.port}`);
                this.serial = new serial_1.ZWaveSocket({
                    host: url.hostname,
                    port: parseInt(url.port),
                }, this._logContainer);
            }
            else {
                this.driverLog.print(`opening serial port ${this.port}`);
                this.serial = new serial_1.ZWaveSerialPort(this.port, this._logContainer, this._options.testingHooks?.serialPortBinding);
            }
        }
        else {
            this.driverLog.print("opening serial port using the provided custom implementation");
            this.serial = new serial_1.ZWaveSerialPortBase(this.port, this._logContainer);
        }
        this.serial
            .on("data", this.serialport_onData.bind(this))
            .on("bootloaderData", this.serialport_onBootloaderData.bind(this))
            .on("error", (err) => {
            if (this.isSoftResetting && !this.serial?.isOpen) {
                // A disconnection while soft resetting is to be expected
                return;
            }
            else if (!this._isOpen) {
                // tryOpenSerialport takes care of error handling
                return;
            }
            void this.destroyWithMessage(`Serial port errored: ${err.message}`);
        });
        // If the port is already open, close it first
        if (this.serial.isOpen)
            await this.serial.close();
        // IMPORTANT: Test code expects the open promise to be created and returned synchronously
        // Everything async (including opening the serial port) must happen in the setImmediate callback
        // asynchronously open the serial port
        setImmediate(async () => {
            try {
                await this.openSerialport();
            }
            catch (e) {
                spOpenPromise.reject(e);
                void this.destroy();
                return;
            }
            this.driverLog.print("serial port opened");
            this._isOpen = true;
            spOpenPromise.resolve();
            // Start draining the queues
            for (const queue of this.queues) {
                void this.drainTransactionQueue(queue);
            }
            // Start the serial API queue
            void this.drainSerialAPIQueue();
            if (typeof this._options.testingHooks?.onSerialPortOpen
                === "function") {
                await this._options.testingHooks.onSerialPortOpen(this.serial);
            }
            // Perform initialization sequence
            await this.writeHeader(serial_1.MessageHeaders.NAK);
            // Per the specs, this should be followed by a soft-reset but we need to be able
            // to handle sticks that don't support the soft reset command. Therefore we do it
            // after opening the value DBs
            if (!this._options.testingHooks?.skipBootloaderCheck) {
                // After an incomplete firmware upgrade, we might be stuck in the bootloader
                // Therefore wait a short amount of time to see if the serialport detects bootloader mode.
                // If we are, the bootloader will reply with its menu.
                await (0, async_1.wait)(1000);
                if (this._bootloader) {
                    this.driverLog.print("Controller is in bootloader, attempting to recover...", "warn");
                    await this.leaveBootloaderInternal();
                    // Wait a short time again. If we're in bootloader mode again, we're stuck
                    await (0, async_1.wait)(1000);
                    if (this._bootloader) {
                        if (this._options.allowBootloaderOnly) {
                            this.driverLog.print("Failed to recover from bootloader. Staying in bootloader mode as requested.", "warn");
                            // Needed for the OTW feature to be available
                            this._controller = new Controller_1.ZWaveController(this, true);
                            this.emit("bootloader ready");
                        }
                        else {
                            void this.destroyWithMessage("Failed to recover from bootloader. Please flash a new firmware to continue...");
                        }
                        return;
                    }
                }
            }
            // Try to create the cache directory. This can fail, in which case we should expose a good error message
            try {
                await this._options.storage.driver.ensureDir(this.cacheDir);
            }
            catch (e) {
                let message;
                if (/\.yarn[/\\]cache[/\\]zwave-js/i.test((0, shared_1.getErrorMessage)(e, true))) {
                    message =
                        `Failed to create the cache directory. When using Yarn PnP, you need to change the location with the "storage.cacheDir" driver option.`;
                }
                else {
                    message =
                        `Failed to create the cache directory. Please make sure that it is writable or change the location with the "storage.cacheDir" driver option.`;
                }
                void this.destroyWithMessage(message);
                return;
            }
            // Load the necessary configuration
            if (this._options.testingHooks?.loadConfiguration !== false) {
                this.driverLog.print("loading configuration...");
                try {
                    await this.configManager.loadAll();
                }
                catch (e) {
                    const message = `Failed to load the configuration: ${(0, shared_1.getErrorMessage)(e)}`;
                    void this.destroyWithMessage(message);
                    return;
                }
            }
            this.driverLog.print("beginning interview...");
            try {
                await this.initializeControllerAndNodes();
            }
            catch (e) {
                let message;
                if ((0, core_1.isZWaveError)(e)
                    && e.code === core_1.ZWaveErrorCodes.Controller_MessageDropped) {
                    message =
                        `Failed to initialize the driver, no response from the controller. Are you sure this is a Z-Wave controller?`;
                }
                else {
                    message = `Failed to initialize the driver: ${(0, shared_1.getErrorMessage)(e, true)}`;
                }
                this.driverLog.print(message, "error");
                this.emit("error", new core_1.ZWaveError(message, core_1.ZWaveErrorCodes.Driver_Failed));
                void this.destroy();
                return;
            }
        });
        return spOpenPromise;
    }
    _controllerInterviewed = false;
    _nodesReady = new Set();
    _nodesReadyEventEmitted = false;
    async openSerialport() {
        let lastError;
        // After a reset, the serial port may need a few seconds until we can open it - try a few times
        for (let attempt = 1; attempt <= this._options.attempts.openSerialPort; attempt++) {
            try {
                await this.serial.open();
                return;
            }
            catch (e) {
                lastError = e;
            }
            if (attempt < this._options.attempts.openSerialPort) {
                await (0, async_1.wait)(1000);
            }
        }
        const message = `Failed to open the serial port: ${(0, shared_1.getErrorMessage)(lastError)}`;
        this.driverLog.print(message, "error");
        throw new core_1.ZWaveError(message, core_1.ZWaveErrorCodes.Driver_Failed);
    }
    /** Indicates whether all nodes are ready, i.e. the "all nodes ready" event has been emitted */
    get allNodesReady() {
        return this._nodesReadyEventEmitted;
    }
    getJsonlDBOptions() {
        const options = {
            ignoreReadErrors: true,
            ...ThrottlePresets_1.throttlePresets[this._options.storage.throttle],
        };
        if (this._options.storage.lockDir) {
            options.lockfile = {
                directory: this._options.storage.lockDir,
            };
        }
        return options;
    }
    async initNetworkCache(homeId) {
        const options = this.getJsonlDBOptions();
        const networkCacheFile = node_path_1.default.join(this.cacheDir, `${homeId.toString(16)}.jsonl`);
        this._networkCache = new jsonl_db_1.JsonlDB(networkCacheFile, {
            ...options,
            serializer: (key, value) => (0, NetworkCache_1.serializeNetworkCacheValue)(this, key, value),
            reviver: (key, value) => (0, NetworkCache_1.deserializeNetworkCacheValue)(this, key, value),
        });
        await this._networkCache.open();
        if (process.env.NO_CACHE === "true") {
            // Since the network cache is append-only, we need to
            // clear it if the cache should be ignored
            this._networkCache.clear();
        }
    }
    async initValueDBs(homeId) {
        const options = this.getJsonlDBOptions();
        const valueDBFile = node_path_1.default.join(this.cacheDir, `${homeId.toString(16)}.values.jsonl`);
        this._valueDB = new jsonl_db_1.JsonlDB(valueDBFile, {
            ...options,
            enableTimestamps: true,
            reviver: (key, value) => (0, core_1.deserializeCacheValue)(value),
            serializer: (key, value) => (0, core_1.serializeCacheValue)(value),
        });
        await this._valueDB.open();
        const metadataDBFile = node_path_1.default.join(this.cacheDir, `${homeId.toString(16)}.metadata.jsonl`);
        this._metadataDB = new jsonl_db_1.JsonlDB(metadataDBFile, options);
        await this._metadataDB.open();
        if (process.env.NO_CACHE === "true") {
            // Since value/metadata DBs are append-only, we need to
            // clear them if the cache should be ignored
            this._valueDB.clear();
            this._metadataDB.clear();
        }
    }
    async performCacheMigration() {
        if (!this._controller
            || !this.controller.homeId
            || !this._networkCache
            || !this._valueDB) {
            return;
        }
        // In v9, the network cache was switched from a json file to use a Jsonl-DB
        // Therefore the legacy cache file must be migrated to the new format
        if (this._networkCache.size === 0) {
            // version the cache format, so migrations in the future are easier
            this._networkCache.set("cacheFormat", 1);
            try {
                await (0, NetworkCache_1.migrateLegacyNetworkCache)(this, this.controller.homeId, this._networkCache, this._valueDB, this._options.storage.driver, this.cacheDir);
                // Go through the value DB and remove all keys referencing commandClass -1, which used to be a
                // hacky way to store non-CC specific values
                for (const key of this._valueDB.keys()) {
                    if (-1 === key.indexOf(`,"commandClass":-1,`)) {
                        continue;
                    }
                    this._valueDB.delete(key);
                }
            }
            catch (e) {
                const message = `Migrating the legacy cache file to jsonl failed: ${(0, shared_1.getErrorMessage)(e, true)}`;
                this.driverLog.print(message, "error");
            }
        }
    }
    /**
     * Initializes the variables for controller and nodes,
     * adds event handlers and starts the interview process.
     */
    async initializeControllerAndNodes() {
        if (this._controller == undefined) {
            this._controller = new Controller_1.ZWaveController(this);
            this._controller
                .on("node added", this.onNodeAdded.bind(this))
                .on("node removed", this.onNodeRemoved.bind(this))
                .on("status changed", this.onControllerStatusChanged.bind(this));
        }
        if (!this._options.testingHooks?.skipControllerIdentification) {
            // Determine controller IDs to open the Value DBs
            // We need to do this first because some older controllers, especially the UZB1 and
            // some 500-series sticks in virtualized environments don't respond after a soft reset
            // No need to initialize databases if skipInterview is true, because it is only used in some
            // Driver unit tests that don't need access to them
            // Identify the controller and determine if it supports soft reset
            await this.controller.identify();
            await this.initNetworkCache(this.controller.homeId);
            const maySoftReset = this.maySoftReset();
            if (this._options.features.softReset && !maySoftReset) {
                this.driverLog.print(`Soft reset is enabled through config, but this stick does not support it.`, "warn");
                this._options.features.softReset = false;
            }
            if (maySoftReset) {
                await this.softResetInternal(false);
            }
            // There are situations where a controller claims it has the ID 0,
            // which isn't valid. In this case try again after having soft-reset the stick
            // TODO: Check if this is still necessary now that we support 16-bit node IDs
            if (this.controller.ownNodeId === 0 && maySoftReset) {
                this.driverLog.print(`Controller identification returned invalid node ID 0 - trying again...`, "warn");
                // We might end up with a different home ID, so close the cache before re-identifying the controller
                await this._networkCache?.close();
                await this.controller.identify();
                await this.initNetworkCache(this.controller.homeId);
            }
            if (this.controller.ownNodeId === 0) {
                this.driverLog.print(`Controller identification returned invalid node ID 0`, "error");
                await this.destroy();
                return;
            }
            // now that we know the home ID, we can open the databases
            await this.initValueDBs(this.controller.homeId);
            await this.performCacheMigration();
            // Interview the controller.
            await this._controller.interview(async () => {
                // Try to restore the network information from the cache
                if (process.env.NO_CACHE !== "true") {
                    await this.restoreNetworkStructureFromCache();
                }
            });
            // Auto-enable smart start inclusion
            this._controller.autoProvisionSmartStart();
        }
        // Set up the S0 security manager. We can only do that after the controller
        // interview because we need to know the controller node id.
        const S0Key = this._options.securityKeys?.S0_Legacy;
        if (S0Key) {
            this.driverLog.print("Network key for S0 configured, enabling S0 security manager...");
            this._securityManager = new core_1.SecurityManager({
                networkKey: S0Key,
                ownNodeId: this._controller.ownNodeId,
                nonceTimeout: this._options.timeouts.nonce,
            });
        }
        else {
            this.driverLog.print("No network key for S0 configured, communication with secure (S0) devices won't work!", "warn");
        }
        // The S2 security manager could be initialized earlier, but we do it here for consistency
        if (this._options.securityKeys
            // Only set it up if we have security keys for at least one S2 security class
            && Object.keys(this._options.securityKeys).some((key) => key.startsWith("S2_")
                && key in core_1.SecurityClass
                && (0, core_1.securityClassIsS2)(core_1.SecurityClass[key]))) {
            this.driverLog.print("At least one network key for S2 configured, enabling S2 security manager...");
            this._securityManager2 = new core_1.SecurityManager2();
            // Set up all keys
            for (const secClass of [
                "S2_Unauthenticated",
                "S2_Authenticated",
                "S2_AccessControl",
                "S0_Legacy",
            ]) {
                const key = this._options.securityKeys[secClass];
                if (key) {
                    this._securityManager2.setKey(core_1.SecurityClass[secClass], key);
                }
            }
        }
        else {
            this.driverLog.print("No network key for S2 configured, communication with secure (S2) devices won't work!", "warn");
        }
        // in any case we need to emit the driver ready event here
        this._controllerInterviewed = true;
        this.driverLog.print("driver ready");
        this.emit("driver ready");
        // Add event handlers for the nodes
        for (const node of this._controller.nodes.values()) {
            this.addNodeEventHandlers(node);
        }
        // Before interviewing nodes reset our knowledge about their ready state
        this._nodesReady.clear();
        this._nodesReadyEventEmitted = false;
        if (!this._options.testingHooks?.skipNodeInterview) {
            // Now interview all nodes
            // First complete the controller interview
            const controllerNode = this._controller.nodes.get(this._controller.ownNodeId);
            await this.interviewNodeInternal(controllerNode);
            // The controller node is always alive
            controllerNode.markAsAlive();
            // Then do all the nodes in parallel, but prioritize nodes that are more likely to be ready
            const nodeInterviewOrder = [...this._controller.nodes.values()]
                .filter((n) => n.id !== this._controller.ownNodeId)
                .sort((a, b) => 
            // Fully-interviewed devices first (need the least amount of communication now)
            (b.interviewStage - a.interviewStage)
                // Always listening -> FLiRS -> sleeping
                || ((b.isListening ? 2 : b.isFrequentListening ? 1 : 0)
                    - (a.isListening ? 2 : a.isFrequentListening ? 1 : 0))
                // Then by last seen, more recently first
                || ((b.lastSeen?.getTime() ?? 0)
                    - (a.lastSeen?.getTime() ?? 0))
                // Lastly ascending by node ID
                || (a.id - b.id));
            this.controllerLog.print(`Interviewing nodes and/or determining their status: ${nodeInterviewOrder.map((n) => n.id).join(", ")}`);
            for (const node of nodeInterviewOrder) {
                if (node.id === this._controller.ownNodeId) {
                    continue;
                }
                else if (node.canSleep) {
                    // A node that can sleep should be assumed to be sleeping after resuming from cache
                    node.markAsAsleep();
                }
                void (async () => {
                    // Continue the interview if necessary. If that is not necessary, at least
                    // determine the node's status
                    if (node.interviewStage < _Types_1.InterviewStage.Complete) {
                        await this.interviewNodeInternal(node);
                    }
                    else if (node.isListening || node.isFrequentListening) {
                        // Ping non-sleeping nodes to determine their status
                        await node.ping();
                    }
                    // Previous versions of zwave-js didn't configure the SUC return route. Make sure each node has one
                    // and remember that we did. If the node is not responsive - tough luck, try again next time
                    if (!node.hasSUCReturnRoute
                        && node.status !== _Types_1.NodeStatus.Dead) {
                        node.hasSUCReturnRoute = await this.controller
                            .assignSUCReturnRoutes(node.id);
                    }
                })();
            }
            // If we only have sleeping nodes or a controller-only network, the send
            // thread is idle before the driver gets marked ready, the idle tasks won't be triggered.
            // So do it manually.
            this.handleQueueIdleChange(this.queueIdle);
        }
    }
    autoRefreshNodeValueTimers = new Map();
    retryNodeInterviewTimeouts = new Map();
    /**
     * @internal
     * Starts or resumes the interview of a Z-Wave node. It is advised to NOT
     * await this method as it can take a very long time (minutes to hours)!
     *
     * WARNING: Do not call this method from application code. To refresh the information
     * for a specific node, use `node.refreshInfo()` instead
     */
    async interviewNodeInternal(node) {
        if (node.interviewStage === _Types_1.InterviewStage.Complete) {
            return;
        }
        // Avoid having multiple restart timeouts active
        if (this.retryNodeInterviewTimeouts.has(node.id)) {
            clearTimeout(this.retryNodeInterviewTimeouts.get(node.id));
            this.retryNodeInterviewTimeouts.delete(node.id);
        }
        // Drop all pending messages that come from a previous interview attempt
        this.rejectTransactions((t) => t.message.getNodeId() === node.id
            && (t.priority === core_1.MessagePriority.NodeQuery
                || t.tag === "interview"), "The interview was restarted", core_1.ZWaveErrorCodes.Controller_InterviewRestarted);
        const maxInterviewAttempts = this._options.attempts.nodeInterview;
        try {
            if (!(await node.interviewInternal())) {
                // Find out if we may retry the interview
                if (node.status === _Types_1.NodeStatus.Dead) {
                    this.controllerLog.logNode(node.id, `Interview attempt (${node.interviewAttempts}/${maxInterviewAttempts}) failed, node is dead.`, "warn");
                    node.emit("interview failed", node, {
                        errorMessage: "The node is dead",
                        isFinal: true,
                    });
                }
                else if (node.interviewAttempts < maxInterviewAttempts) {
                    // This is most likely because the node is unable to handle our load of requests now. Give it some time
                    const retryTimeout = Math.min(30000, node.interviewAttempts * 5000);
                    this.controllerLog.logNode(node.id, `Interview attempt ${node.interviewAttempts}/${maxInterviewAttempts} failed, retrying in ${retryTimeout} ms...`, "warn");
                    node.emit("interview failed", node, {
                        errorMessage: `Attempt ${node.interviewAttempts}/${maxInterviewAttempts} failed`,
                        isFinal: false,
                        attempt: node.interviewAttempts,
                        maxAttempts: maxInterviewAttempts,
                    });
                    // Schedule the retry and remember the timeout instance
                    this.retryNodeInterviewTimeouts.set(node.id, setTimeout(() => {
                        this.retryNodeInterviewTimeouts.delete(node.id);
                        void this.interviewNodeInternal(node);
                    }, retryTimeout).unref());
                }
                else {
                    this.controllerLog.logNode(node.id, `Failed all interview attempts, giving up.`, "warn");
                    node.emit("interview failed", node, {
                        errorMessage: `Maximum interview attempts reached`,
                        isFinal: true,
                        attempt: maxInterviewAttempts,
                        maxAttempts: maxInterviewAttempts,
                    });
                }
            }
            else if (node.manufacturerId != undefined
                && node.productType != undefined
                && node.productId != undefined
                && node.firmwareVersion != undefined
                && !node.deviceConfig
                && process.env.NODE_ENV !== "test") {
                // The interview succeeded, but we don't have a device config for this node.
                // Report it, so we can add a config file
                void (0, deviceConfig_1.reportMissingDeviceConfig)(this, node).catch(shared_1.noop);
            }
        }
        catch (e) {
            if ((0, core_1.isZWaveError)(e)) {
                if (e.code === core_1.ZWaveErrorCodes.Driver_NotReady
                    || e.code === core_1.ZWaveErrorCodes.Controller_NodeRemoved) {
                    // This only happens when a node is removed during the interview - we don't log this
                    return;
                }
                else if (e.code === core_1.ZWaveErrorCodes.Controller_InterviewRestarted) {
                    // The interview was restarted by a user - we don't log this
                    return;
                }
                this.controllerLog.logNode(node.id, `Error during node interview: ${e.message}`, "error");
            }
            else {
                throw e;
            }
        }
    }
    /** Adds the necessary event handlers for a node instance */
    addNodeEventHandlers(node) {
        node.on("wake up", this.onNodeWakeUp.bind(this))
            .on("sleep", this.onNodeSleep.bind(this))
            .on("alive", this.onNodeAlive.bind(this))
            .on("dead", this.onNodeDead.bind(this))
            .on("interview completed", this.onNodeInterviewCompleted.bind(this))
            .on("ready", this.onNodeReady.bind(this))
            .on("firmware update finished", this.onNodeFirmwareUpdated.bind(this))
            .on("notification", this.onNodeNotification.bind(this));
        // Add forwarders for all node events
        for (const event of _Types_1.zWaveNodeEvents) {
            node.on(event, (...args) => {
                // @ts-expect-error We made sure that args matches
                this.emit(`node ${event}`, ...args);
            });
        }
    }
    /** Removes a node's event handlers that were added with addNodeEventHandlers */
    removeNodeEventHandlers(node) {
        node.removeAllListeners();
    }
    /** Is called when a node wakes up */
    onNodeWakeUp(node, oldStatus) {
        this.controllerLog.logNode(node.id, `The node is ${oldStatus === _Types_1.NodeStatus.Unknown ? "" : "now "}awake.`);
        // Make sure to handle the pending messages as quickly as possible
        if (oldStatus === _Types_1.NodeStatus.Asleep) {
            this.reduceQueues(({ message }) => {
                // Ignore messages that are not for this node
                if (message.getNodeId() !== node.id)
                    return { type: "keep" };
                // Resolve pings, so we don't need to send them (we know the node is awake)
                if ((0, cc_1.messageIsPing)(message)) {
                    return { type: "resolve", message: undefined };
                }
                // Re-queue all other transactions for this node, so they get added in front of the others
                return { type: "requeue" };
            });
        }
    }
    /** Is called when a node goes to sleep */
    onNodeSleep(node, oldStatus) {
        this.controllerLog.logNode(node.id, `The node is ${oldStatus === _Types_1.NodeStatus.Unknown ? "" : "now "}asleep.`);
        // Move all its pending messages to the WakeupQueue
        // This clears the current transaction and continues sending the next messages
        this.moveMessagesToWakeupQueue(node.id);
    }
    /** Is called when a previously dead node starts communicating again */
    onNodeAlive(node, oldStatus) {
        this.controllerLog.logNode(node.id, `The node is ${oldStatus === _Types_1.NodeStatus.Unknown ? "" : "now "}alive.`);
        if (oldStatus === _Types_1.NodeStatus.Dead
            && node.interviewStage !== _Types_1.InterviewStage.Complete
            && !this._options.testingHooks?.skipNodeInterview) {
            void this.interviewNodeInternal(node);
        }
    }
    /** Is called when a node is marked as dead */
    onNodeDead(node, oldStatus) {
        this.controllerLog.logNode(node.id, `The node is ${oldStatus === _Types_1.NodeStatus.Unknown ? "" : "now "}dead.`);
        // This could mean that we need to ignore it in the all nodes ready check,
        // so perform the check again
        this.checkAllNodesReady();
    }
    /** Is called when a node is ready to be used */
    onNodeReady(node) {
        this._nodesReady.add(node.id);
        this.controllerLog.logNode(node.id, "The node is ready to be used");
        // Regularly check if values of non-sleeping nodes need to be refreshed per the specs
        // For sleeping nodes this is done on wakeup
        if (this.autoRefreshNodeValueTimers.has(node.id)) {
            clearInterval(this.autoRefreshNodeValueTimers.get(node.id));
            this.autoRefreshNodeValueTimers.delete(node.id);
        }
        if (!node.canSleep) {
            // Randomize the interval so we don't get a flood of queries for all listening nodes
            const intervalMinutes = 50 + Math.random() * 20;
            this.autoRefreshNodeValueTimers.set(node.id, setInterval(() => {
                void node.autoRefreshValues().catch(() => {
                    // ignore errors
                });
            }, core_1.timespan.minutes(intervalMinutes)).unref());
        }
        this.checkAllNodesReady();
    }
    /** Checks if all nodes are ready and emits the "all nodes ready" event if they are */
    checkAllNodesReady() {
        // Only emit "all nodes ready" once
        if (this._nodesReadyEventEmitted)
            return;
        for (const [id, node] of this.controller.nodes) {
            // Ignore dead nodes or the all nodes ready event will never be emitted without physical user interaction
            if (node.status === _Types_1.NodeStatus.Dead)
                continue;
            if (!this._nodesReady.has(id))
                return;
        }
        // All nodes are ready
        this.controllerLog.print("All nodes are ready to be used");
        this.emit("all nodes ready");
        this._nodesReadyEventEmitted = true;
        // We know we have all data, this is the time to send statistics (when enabled)
        void this.compileAndSendStatistics().catch(() => {
            /* ignore */
        });
    }
    _statisticsEnabled = false;
    /** Whether reporting usage statistics is currently enabled */
    get statisticsEnabled() {
        return this._statisticsEnabled;
    }
    statisticsAppInfo;
    userAgentComponents = new Map();
    /**
     * Updates individual components of the user agent. Versions for individual applications can be added or removed.
     * @param components An object with application/module/component names and their versions. Set a version to `null` or `undefined` explicitly to remove it from the user agent.
     */
    updateUserAgent(components) {
        this.userAgentComponents = (0, UserAgent_1.mergeUserAgent)(this.userAgentComponents, components);
        this._userAgent = this.getEffectiveUserAgentString(this.userAgentComponents);
    }
    /**
     * Returns the effective user agent string for the given components.
     * The driver name and version is automatically prepended and the statisticsAppInfo data is automatically appended if no components were given.
     */
    getEffectiveUserAgentString(components) {
        const effectiveComponents = new Map([
            [exports.libName, exports.libVersion],
            ...components,
        ]);
        if (effectiveComponents.size === 1
            && this.statisticsAppInfo
            && this.statisticsAppInfo.applicationName !== "node-zwave-js") {
            effectiveComponents.set(this.statisticsAppInfo.applicationName, this.statisticsAppInfo.applicationVersion);
        }
        return (0, UserAgent_1.userAgentComponentsToString)(effectiveComponents);
    }
    _userAgent = `node-zwave-js/${exports.libVersion}`;
    /** Returns the user agent string used for service requests */
    get userAgent() {
        return this._userAgent;
    }
    /** Returns the user agent string combined with the additional components (if given) */
    getUserAgentStringWithComponents(components) {
        if (!components || Object.keys(components).length === 0) {
            return this._userAgent;
        }
        const merged = (0, UserAgent_1.mergeUserAgent)(this.userAgentComponents, components, false);
        return this.getEffectiveUserAgentString(merged);
    }
    /**
     * Enable sending usage statistics. Although this does not include any sensitive information, we expect that you
     * inform your users before enabling statistics.
     */
    enableStatistics(appInfo) {
        if (this._statisticsEnabled)
            return;
        if (!(0, typeguards_1.isObject)(appInfo)
            || typeof appInfo.applicationName !== "string"
            || typeof appInfo.applicationVersion !== "string") {
            throw new core_1.ZWaveError(`The application statistics must be an object with two string properties "applicationName" and "applicationVersion"!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
        }
        else if (appInfo.applicationName.length > 100) {
            throw new core_1.ZWaveError(`The applicationName for statistics must be maximum 100 characters long!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
        }
        else if (appInfo.applicationVersion.length > 100) {
            throw new core_1.ZWaveError(`The applicationVersion for statistics must be maximum 100 characters long!`, core_1.ZWaveErrorCodes.Driver_InvalidOptions);
        }
        this._statisticsEnabled = true;
        this.statisticsAppInfo = appInfo;
        // If we're already ready, send statistics
        if (this._nodesReadyEventEmitted) {
            void this.compileAndSendStatistics().catch(() => {
                /* ignore */
            });
        }
    }
    /**
     * Disable sending usage statistics
     */
    disableStatistics() {
        this._statisticsEnabled = false;
        this.statisticsAppInfo = undefined;
        if (this.statisticsTimeout) {
            clearTimeout(this.statisticsTimeout);
            this.statisticsTimeout = undefined;
        }
    }
    /** @internal */
    // eslint-disable-next-line @typescript-eslint/require-await
    async getUUID() {
        // To anonymously identify a network, we create a unique ID and use it to salt the Home ID
        if (!this._valueDB.has("uuid")) {
            this._valueDB.set("uuid", (0, node_crypto_1.randomBytes)(32).toString("hex"));
        }
        const ret = this._valueDB.get("uuid");
        return ret;
    }
    statisticsTimeout;
    async compileAndSendStatistics() {
        // Don't send anything if statistics are not enabled
        if (!this.statisticsEnabled || !this.statisticsAppInfo)
            return;
        if (this.statisticsTimeout) {
            clearTimeout(this.statisticsTimeout);
            this.statisticsTimeout = undefined;
        }
        let success = false;
        try {
            const statistics = await (0, statistics_1.compileStatistics)(this, {
                driverVersion: exports.libVersion,
                ...this.statisticsAppInfo,
                nodeVersion: process.versions.node,
                os: process.platform,
                arch: process.arch,
            });
            success = await (0, statistics_1.sendStatistics)(statistics);
        }
        catch {
            // Didn't work - try again in a few hours
            success = false;
        }
        finally {
            if (typeof success === "number") {
                this.driverLog.print(`Sending usage statistics was rate limited - next attempt scheduled in ${success} seconds.`, "verbose");
                // Wait at most 6 hours to try again
                const retryMs = Math.max(core_1.timespan.minutes(1), Math.min(success * 1000, core_1.timespan.hours(6)));
                this.statisticsTimeout = setTimeout(() => {
                    void this.compileAndSendStatistics();
                }, retryMs).unref();
            }
            else {
                this.driverLog.print(success
                    ? `Usage statistics sent - next transmission scheduled in 23 hours.`
                    : `Failed to send usage statistics - next transmission scheduled in 6 hours.`, "verbose");
                this.statisticsTimeout = setTimeout(() => {
                    void this.compileAndSendStatistics();
                }, core_1.timespan.hours(success ? 23 : 6)).unref();
            }
        }
    }
    /** Is called when a node interview is completed */
    onNodeInterviewCompleted(node) {
        this.debounceSendNodeToSleep(node);
    }
    /** This is called when a new node has been added to the network */
    onNodeAdded(node) {
        this.addNodeEventHandlers(node);
        if (this._options.interview?.disableOnNodeAdded)
            return;
        if (this._options.testingHooks?.skipNodeInterview)
            return;
        // Interview the node
        // don't await the interview, because it may take a very long time
        // if a node is asleep
        void this.interviewNodeInternal(node);
    }
    /** This is called when a node was removed from the network */
    onNodeRemoved(node, reason) {
        // Remove all listeners and timers
        this.removeNodeEventHandlers(node);
        if (this.sendNodeToSleepTimers.has(node.id)) {
            clearTimeout(this.sendNodeToSleepTimers.get(node.id));
            this.sendNodeToSleepTimers.delete(node.id);
        }
        if (this.retryNodeInterviewTimeouts.has(node.id)) {
            clearTimeout(this.retryNodeInterviewTimeouts.get(node.id));
            this.retryNodeInterviewTimeouts.delete(node.id);
        }
        if (this.autoRefreshNodeValueTimers.has(node.id)) {
            clearTimeout(this.autoRefreshNodeValueTimers.get(node.id));
            this.autoRefreshNodeValueTimers.delete(node.id);
        }
        // purge node values from the DB
        node.valueDB.clear();
        this.cachePurge(NetworkCache_1.cacheKeys.node(node.id)._baseKey);
        // Remove the node from all security manager instances
        this.securityManager?.deleteAllNoncesForReceiver(node.id);
        this.securityManager2?.deleteNonce(node.id);
        this.rejectAllTransactionsForNode(node.id, "The node was removed from the network", core_1.ZWaveErrorCodes.Controller_NodeRemoved);
        const replaced = reason === Inclusion_1.RemoveNodeReason.Replaced
            || reason === Inclusion_1.RemoveNodeReason.ProxyReplaced;
        if (!replaced) {
            // Asynchronously remove the node from all possible associations, ignore potential errors
            // but only if the node is not getting replaced, because the removal will interfere with
            // bootstrapping the new node
            this.controller
                .removeNodeFromAllAssociations(node.id)
                .catch((err) => {
                this.driverLog.print(`Failed to remove node ${node.id} from all associations: ${err.message}`, "error");
            });
        }
        // And clean up all remaining resources used by the node
        node.destroy();
        // If this was a failed node it could mean that all nodes are now ready
        this.checkAllNodesReady();
    }
    onControllerStatusChanged(_status) {
        this.triggerQueues();
    }
    /**
     * Returns the time in seconds to actually wait after a firmware upgrade, depending on what the device said.
     * This number will always be a bit greater than the advertised duration, because devices have been found to take longer to actually reboot.
     */
    getConservativeWaitTimeAfterFirmwareUpdate(advertisedWaitTime) {
        // Wait the specified time plus a bit, so the device is actually ready to use
        if (!advertisedWaitTime) {
            // Wait at least 5 seconds
            return 5;
        }
        else if (advertisedWaitTime < 20) {
            return advertisedWaitTime + 5;
        }
        else if (advertisedWaitTime < 60) {
            return advertisedWaitTime + 10;
        }
        else {
            return advertisedWaitTime + 30;
        }
    }
    /** This is called when the firmware on one of a node's firmware targets was updated */
    async onNodeFirmwareUpdated(node, result) {
        const { success, reInterview } = result;
        // Nothing to do for non-successful updates
        if (!success)
            return;
        // TODO: Add support for delayed activation
        // Reset nonces etc. to prevent false-positive duplicates after the update
        this.securityManager?.deleteAllNoncesForReceiver(node.id);
        this.securityManager2?.deleteNonce(node.id);
        // waitTime should always be defined, but just to be sure
        const waitTime = result.waitTime ?? 5;
        if (reInterview) {
            this.controllerLog.logNode(node.id, `Firmware updated, scheduling interview in ${waitTime} seconds...`);
            // We reuse the retryNodeInterviewTimeouts here because they serve a similar purpose
            this.retryNodeInterviewTimeouts.set(node.id, setTimeout(() => {
                this.retryNodeInterviewTimeouts.delete(node.id);
                void node.refreshInfo({
                    // After a firmware update, we need to refresh the node info
                    waitForWakeup: false,
                });
            }, waitTime * 1000).unref());
        }
        else {
            this.controllerLog.logNode(node.id, `Firmware updated. No restart or re-interview required. Refreshing version information in ${waitTime} seconds...`);
            await (0, async_1.wait)(waitTime * 1000, true);
            try {
                const versionAPI = node.commandClasses.Version;
                await versionAPI.get();
                if (versionAPI.supportsCommand(cc_1.VersionCommand.CapabilitiesGet)) {
                    await versionAPI.getCapabilities();
                }
                if (versionAPI.supportsCommand(cc_1.VersionCommand.ZWaveSoftwareGet)) {
                    await versionAPI.getZWaveSoftware();
                }
            }
            catch {
                // ignore
            }
        }
    }
    /** This is called when a node emits a `"notification"` event */
    onNodeNotification = (endpoint, ccId, ccArgs) => {
        let prefix;
        let details;
        if (ccId === core_1.CommandClasses.Notification) {
            const msg = {
                type: ccArgs.label,
                event: ccArgs.eventLabel,
            };
            if (ccArgs.parameters) {
                if (Buffer.isBuffer(ccArgs.parameters)) {
                    msg.parameters = (0, shared_1.buffer2hex)(ccArgs.parameters);
                }
                else if (ccArgs.parameters instanceof core_1.Duration) {
                    msg.duration = ccArgs.parameters.toString();
                }
                else if ((0, typeguards_1.isObject)(ccArgs.parameters)) {
                    Object.assign(msg, ccArgs.parameters);
                }
            }
            prefix = "[Notification]";
            details = (0, core_1.messageRecordToLines)(msg);
        }
        else if (ccId === core_1.CommandClasses["Entry Control"]) {
            prefix = "[Notification] Entry Control";
            details = (0, core_1.messageRecordToLines)({
                "event type": ccArgs.eventTypeLabel,
                "data type": ccArgs.dataTypeLabel,
            });
        }
        else if (ccId === core_1.CommandClasses["Multilevel Switch"]) {
            prefix = "[Notification] Multilevel Switch";
            details = (0, core_1.messageRecordToLines)((0, core_1.stripUndefined)({
                "event type": ccArgs.eventTypeLabel,
                direction: ccArgs.direction,
            }));
        } /*if (ccId === CommandClasses.Powerlevel)*/
        else {
            // Don't bother logging this
            return;
        }
        this.controllerLog.logNode(endpoint.nodeId, {
            endpoint: endpoint.index,
            message: [prefix, ...details.map((d) => `  ${d}`)].join("\n"),
        });
    };
    /** Checks if there are any pending messages for the given node */
    hasPendingMessages(node) {
        // First check if there are messages in the queue
        if (this.hasPendingTransactions((t) => t.message.getNodeId() === node.id)) {
            return true;
        }
        // Then check if there are scheduled polls
        return node.scheduledPolls.size > 0;
    }
    /** Checks if there are any pending transactions that match the given predicate */
    hasPendingTransactions(predicate) {
        // Queue is not an array
        // eslint-disable-next-line unicorn/prefer-array-some
        if (!!this.queue.find((t) => predicate(t)))
            return true;
        return this.queues.some((q) => q.currentTransaction && predicate(q.currentTransaction));
    }
    /**
     * Retrieves the maximum version of a command class the given endpoint supports.
     * Returns 0 when the CC is not supported. Also returns 0 when the node was not found.
     * Falls back to querying the root endpoint if an endpoint was not found on the node
     *
     * @param cc The command class whose version should be retrieved
     * @param nodeId The node for which the CC version should be retrieved
     * @param endpointIndex The endpoint in question
     */
    getSupportedCCVersion(cc, nodeId, endpointIndex = 0) {
        if (!this._controller?.nodes.has(nodeId)) {
            return 0;
        }
        const node = this.controller.nodes.get(nodeId);
        const endpoint = node.getEndpoint(endpointIndex);
        if (endpoint)
            return endpoint.getCCVersion(cc);
        // We sometimes receive messages from an endpoint, but can't find that endpoint.
        // In that case fall back to the root endpoint to determine the supported version.
        return node.getCCVersion(cc);
    }
    /**
     * Retrieves the maximum version of a command class that can be used to communicate with a node.
     * Returns the highest implemented version if the node's CC version is unknown.
     * Throws if the CC is not implemented in this library yet.
     *
     * @param cc The command class whose version should be retrieved
     * @param nodeId The node for which the CC version should be retrieved
     * @param endpointIndex The endpoint for which the CC version should be retrieved
     */
    getSafeCCVersion(cc, nodeId, endpointIndex = 0) {
        const supportedVersion = this.getSupportedCCVersion(cc, nodeId, endpointIndex);
        if (supportedVersion === 0) {
            // Unknown, use the highest implemented version
            const implementedVersion = (0, cc_1.getImplementedVersion)(cc);
            if (implementedVersion !== 0
                && implementedVersion !== Number.POSITIVE_INFINITY) {
                return implementedVersion;
            }
        }
        else {
            // For supported versions find the maximum version supported by both the
            // node and this library
            const implementedVersion = (0, cc_1.getImplementedVersion)(cc);
            if (implementedVersion !== 0
                && implementedVersion !== Number.POSITIVE_INFINITY) {
                return Math.min(supportedVersion, implementedVersion);
            }
        }
        throw new core_1.ZWaveError("Cannot retrieve the version of a CC that is not implemented", core_1.ZWaveErrorCodes.CC_NotImplemented);
    }
    /**
     * Determines whether a CC must be secure for a given node and endpoint.
     *
     * @param ccId The command class in question
     * @param nodeId The node for which the CC security should be determined
     * @param endpointIndex The endpoint for which the CC security should be determined
     */
    isCCSecure(ccId, nodeId, endpointIndex = 0) {
        // This is obvious
        if (ccId === core_1.CommandClasses.Security
            || ccId === core_1.CommandClasses["Security 2"]) {
            return true;
        }
        const node = this.controller.nodes.get(nodeId);
        // Node is unknown, don't use secure communication
        if (!node)
            return false;
        const endpoint = node.getEndpoint(endpointIndex);
        const securityClass = node.getHighestSecurityClass();
        // Node is not secure, don't use secure communication
        if (securityClass === undefined || securityClass === core_1.SecurityClass.None) {
            return false;
        }
        // Special case for Basic CC, which we sometimes hide:
        // A securely included node MAY support the Basic Command Class at the highest security level but it
        // MUST NOT support the Basic Command Class at any lower security level or non-securely.
        const isBasicCC = ccId === core_1.CommandClasses.Basic;
        // Security S2 specs also mandate that all non-securely supported CCs MUST also be supported securely
        // so we can just shortcut if the node is using S2
        if ((0, core_1.securityClassIsS2)(securityClass)) {
            // Use secure communication if the CC is supported. This avoids silly things like S2-encapsulated pings
            return (!!this.securityManager2
                && (isBasicCC || (endpoint ?? node).supportsCC(ccId)));
        }
        // Security S0 can be a little more complicated, with secure and non-secure endpoints
        if (securityClass === core_1.SecurityClass.S0_Legacy) {
            // Therefore actually check if the CC is marked as secure
            return (!!this.securityManager
                && (isBasicCC || (endpoint ?? node).isCCSecure(ccId)));
        }
        // We shouldn't be here
        return false;
    }
    /**
     * **!!! INTERNAL !!!**
     *
     * Not intended to be used by applications
     */
    schedulePoll(nodeId, valueId, options) {
        // Needed for ZWaveApplicationHost
        const node = this.controller.nodes.getOrThrow(nodeId);
        return node.schedulePoll(valueId, options);
    }
    isSoftResetting = false;
    maySoftReset() {
        // 700+ series controllers have no problems with soft reset and MUST even be soft reset in some cases
        if (this._controller?.sdkVersionGt("7.0"))
            return true;
        // Blacklist some sticks that are known to not support soft reset
        const { manufacturerId, productType, productId } = this.controller;
        // Z-Wave.me UZB1
        if (manufacturerId === 0x0115
            && productType === 0x0000
            && productId === 0x0000) {
            return false;
        }
        // Z-Wave.me UZB
        if (manufacturerId === 0x0115
            && productType === 0x0400
            && productId === 0x0001) {
            return false;
        }
        // Vision Gen5 USB Stick
        if (manufacturerId === 0x0109
            && productType === 0x1001
            && productId === 0x0201
        // firmware version 15.1 (GH#3730)
        ) {
            return false;
        }
        // No clear indication, make the result depend on the config option
        return !!this._options.features.softReset;
    }
    /**
     * Soft-resets the controller if the feature is enabled
     */
    async trySoftReset() {
        if (this.maySoftReset()) {
            await this.softReset();
        }
        else {
            const message = `The controller should not or cannot be soft reset, skipping API call.`;
            this.controllerLog.print(message, "warn");
        }
    }
    /**
     * Instruct the controller to soft-reset.
     *
     * **Warning:** USB modules will reconnect, meaning that they might get a new address.
     *
     * **Warning:** This call will throw if soft-reset is not enabled.
     */
    async softReset() {
        if (!this.maySoftReset()) {
            const message = `The controller does not support soft reset or the soft reset feature has been disabled with a config option or the ZWAVEJS_DISABLE_SOFT_RESET environment variable.`;
            this.controllerLog.print(message, "error");
            throw new core_1.ZWaveError(message, core_1.ZWaveErrorCodes.Driver_FeatureDisabled);
        }
        if (this._controller?.isAnyOTAFirmwareUpdateInProgress()) {
            const message = `Failed to soft reset controller: A firmware update is in progress on this network.`;
            this.controllerLog.print(message, "error");
            throw new core_1.ZWaveError(message, core_1.ZWaveErrorCodes.FirmwareUpdateCC_NetworkBusy);
        }
        return this.softResetInternal(true);
    }
    async softResetInternal(destroyOnError) {
        this.controllerLog.print("Performing soft reset...");
        try {
            this.isSoftResetting = true;
            await this.sendMessage(new SoftResetRequest_1.SoftResetRequest(this), {
                supportCheck: false,
                pauseSendThread: true,
            });
        }
        catch (e) {
            this.controllerLog.print(`Soft reset failed: ${(0, shared_1.getErrorMessage)(e)}`, "error");
            // Don't continue if the controller is unresponsive
            if ((0, core_1.isMissingControllerACK)(e))
                throw e;
        }
        if (this._controller) {
            // Soft-reset resets the node ID type back to 8 bit
            this._controller["_nodeIdType"] = core_1.NodeIDType.Short;
            // Soft-resetting disables any ongoing inclusion, so we need to reset
            // the state that is tracked in the controller
            this._controller.setInclusionState(Inclusion_1.InclusionState.Idle);
        }
        // Make sure we're able to communicate with the controller again
        if (!(await this.ensureSerialAPI())) {
            if (destroyOnError) {
                await this.destroy();
            }
            else {
                throw new core_1.ZWaveError("The Serial API did not respond after soft-reset", core_1.ZWaveErrorCodes.Driver_Failed);
            }
        }
        this.isSoftResetting = false;
        // This is a bit hacky, but what the heck...
        if (!this._enteringBootloader) {
            // If desired, re-configure the controller to use 16 bit node IDs
            void this._controller?.trySetNodeIDType(core_1.NodeIDType.Long);
            // Resume sending
            this.unpauseSendQueue();
        }
    }
    /** @internal */
    async softResetAndRestart(restartLogMessage, restartReason) {
        this.controllerLog.print("Performing soft reset...");
        try {
            this.isSoftResetting = true;
            await this.sendMessage(new SoftResetRequest_1.SoftResetRequest(this), {
                supportCheck: false,
                pauseSendThread: true,
            });
        }
        catch (e) {
            this.controllerLog.print(`Soft reset failed: ${(0, shared_1.getErrorMessage)(e)}`, "error");
        }
        this.isSoftResetting = false;
        this.controllerLog.print(restartLogMessage);
        await this.destroy();
        // Let the async calling context finish before emitting the error
        process.nextTick(() => {
            this.emit("error", new core_1.ZWaveError(restartReason, core_1.ZWaveErrorCodes.Driver_Failed));
        });
    }
    /**
     * Checks whether recovering an unresponsive controller is enabled
     * and whether the driver is in a state where it makes sense.
     */
    mayRecoverUnresponsiveController() {
        if (!this._options.features.unresponsiveControllerRecovery) {
            return false;
        }
        // Only recover after we know the controller has been responsive
        return this._controllerInterviewed;
    }
    async ensureSerialAPI() {
        // Wait 1.5 seconds after reset to ensure that the module is ready for communication again
        // Z-Wave 700 sticks are relatively fast, so we also wait for the Serial API started command
        // to bail early
        this.controllerLog.print("Waiting for the controller to reconnect...");
        let waitResult = await this.waitForMessage((msg) => msg.functionType === serial_1.FunctionType.SerialAPIStarted, 1500).catch(() => false);
        if (waitResult) {
            // Serial API did start, maybe do something with the information?
            this.controllerLog.print("reconnected and restarted");
            return true;
        }
        // If the controller disconnected the serial port during the soft reset, we need to re-open it
        if (!this.serial.isOpen) {
            this.controllerLog.print("Re-opening serial port...");
            try {
                await this.openSerialport();
            }
            catch {
                return false;
            }
        }
        // Wait the configured amount of time for the Serial API started command to be received
        this.controllerLog.print("Waiting for the Serial API to start...");
        waitResult = await this.waitForMessage((msg) => {
            return msg.functionType === serial_1.FunctionType.SerialAPIStarted;
        }, this._options.timeouts.serialAPIStarted).catch(() => false);
        if (waitResult) {
            // Serial API did start, maybe do something with the information?
            this.controllerLog.print("Serial API started");
            return true;
        }
        this.controllerLog.print("Did not receive notification that Serial API has started, checking if it responds...");
        // We don't need to use any specific command here. However we're going to use this one in the interview
        // anyways, so we might aswell use it here too
        const pollController = async () => {
            try {
                // And resume sending - this requires us to unpause the send thread
                this.unpauseSendQueue();
                await this.sendMessage(new GetControllerVersionMessages_1.GetControllerVersionRequest(this), {
                    supportCheck: false,
                    priority: core_1.MessagePriority.ControllerImmediate,
                });
                this.pauseSendQueue();
                this.controllerLog.print("Serial API responded");
                return true;
            }
            catch {
                return false;
            }
        };
        // Poll the controller with increasing backoff delay
        if (await pollController())
            return true;
        for (const backoff of [2, 5, 10, 15]) {
            this.controllerLog.print(`Serial API did not respond, trying again in ${backoff} seconds...`);
            await (0, async_1.wait)(backoff * 1000);
            if (await pollController())
                return true;
        }
        this.controllerLog.print("Serial API did not respond, giving up", "error");
        return false;
    }
    /**
     * Performs a hard reset on the controller. This wipes out all configuration!
     *
     * The returned Promise resolves when the hard reset has been performed.
     * It does not wait for the initialization process which is started afterwards.
     */
    async hardReset() {
        this.ensureReady(true);
        if (this.controller.isAnyOTAFirmwareUpdateInProgress()) {
            const message = `Failed to hard reset controller: A firmware update is in progress on this network.`;
            this.controllerLog.print(message, "error");
            throw new core_1.ZWaveError(message, core_1.ZWaveErrorCodes.FirmwareUpdateCC_NetworkBusy);
        }
        // Update the controller NIF prior to hard resetting
        await this.controller.setControllerNIF();
        await this.controller.hardReset();
        // Clean up
        this.rejectTransactions(() => true, `The controller was hard-reset`);
        this.sendNodeToSleepTimers.forEach((timeout) => clearTimeout(timeout));
        this.sendNodeToSleepTimers.clear();
        this.retryNodeInterviewTimeouts.forEach((timeout) => clearTimeout(timeout));
        this.retryNodeInterviewTimeouts.clear();
        this.autoRefreshNodeValueTimers.forEach((timeout) => clearTimeout(timeout));
        this.autoRefreshNodeValueTimers.clear();
        if (this.pollBackgroundRSSITimer) {
            clearTimeout(this.pollBackgroundRSSITimer);
            this.pollBackgroundRSSITimer = undefined;
        }
        this._controllerInterviewed = false;
        void this.initializeControllerAndNodes();
    }
    /**
     * Instructs the Z-Wave API to shut down in order to safely remove the power.
     * This will destroy the driver instance if it succeeds.
     */
    async shutdown() {
        this.ensureReady(true);
        // Not a good idea to abort firmware updates this way
        if (this.controller.isAnyOTAFirmwareUpdateInProgress()) {
            const message = `Failed to shut down controller: A firmware update is in progress on this network.`;
            this.controllerLog.print(message, "error");
            throw new core_1.ZWaveError(message, core_1.ZWaveErrorCodes.FirmwareUpdateCC_NetworkBusy);
        }
        const result = await this.controller.shutdown();
        try {
            if (result)
                await this.destroy();
        }
        finally {
            return result;
        }
    }
    _destroyPromise;
    get wasDestroyed() {
        return !!this._destroyPromise;
    }
    /**
     * Ensures that the driver is ready to communicate (serial port open and not destroyed).
     * If desired, also checks that the controller interview has been completed.
     */
    ensureReady(includingController = false) {
        if (!this._wasStarted || !this._isOpen || this.wasDestroyed) {
            throw new core_1.ZWaveError("The driver is not ready or has been destroyed", core_1.ZWaveErrorCodes.Driver_NotReady);
        }
        if (includingController && !this._controllerInterviewed) {
            throw new core_1.ZWaveError("The controller is not ready yet", core_1.ZWaveErrorCodes.Driver_NotReady);
        }
        if (this._bootloader) {
            throw new core_1.ZWaveError("Cannot do this while in bootloader mode", core_1.ZWaveErrorCodes.Driver_NotReady);
        }
    }
    /** Indicates whether the driver is ready, i.e. the "driver ready" event was emitted */
    get ready() {
        return (this._wasStarted
            && this._isOpen
            && !this.wasDestroyed
            && this._controllerInterviewed);
    }
    async destroyWithMessage(message) {
        this.driverLog.print(message, "error");
        const error = new core_1.ZWaveError(message, core_1.ZWaveErrorCodes.Driver_Failed);
        this.emit("error", error);
        await this.destroy();
    }
    /**
     * Terminates the driver instance and closes the underlying serial connection.
     * Must be called under any circumstances.
     */
    async destroy() {
        // Ensure this is only called once and all subsequent calls block
        if (this._destroyPromise)
            return this._destroyPromise;
        this._destroyPromise = (0, deferred_promise_1.createDeferredPromise)();
        this.driverLog.print("destroying driver instance...");
        // First stop all queues and close the serial port, so nothing happens anymore
        this.serialAPIQueue.abort();
        for (const queue of this.queues) {
            queue.abort();
        }
        if (this.serialAPIInterpreter?.status === xstate_1.InterpreterStatus.Running) {
            this.serialAPIInterpreter.stop();
        }
        if (this.serial != undefined) {
            // Avoid spewing errors if the port was in the middle of receiving something
            this.serial.removeAllListeners();
            if (this.serial.isOpen)
                await this.serial.close();
            this.serial = undefined;
        }
        // Attempt to close the value DBs and network cache
        try {
            await this._valueDB?.close();
        }
        catch (e) {
            this.driverLog.print(`Closing the value DB failed: ${(0, shared_1.getErrorMessage)(e)}`, "error");
        }
        try {
            await this._metadataDB?.close();
        }
        catch (e) {
            this.driverLog.print(`Closing the metadata DB failed: ${(0, shared_1.getErrorMessage)(e)}`, "error");
        }
        try {
            await this._networkCache?.close();
        }
        catch (e) {
            this.driverLog.print(`Closing the network cache failed: ${(0, shared_1.getErrorMessage)(e)}`, "error");
        }
        // Remove all timeouts
        for (const timeout of [
            ...this.sendNodeToSleepTimers.values(),
            ...this.retryNodeInterviewTimeouts.values(),
            ...this.autoRefreshNodeValueTimers.values(),
            this.statisticsTimeout,
            this.pollBackgroundRSSITimer,
            ...this.awaitedCommands.map((c) => c.timeout),
            ...this.awaitedMessages.map((m) => m.timeout),
            ...this.awaitedMessageHeaders.map((h) => h.timeout),
            ...this.awaitedBootloaderChunks.map((b) => b.timeout),
        ]) {
            if (timeout)
                clearTimeout(timeout);
        }
        // Destroy all nodes and the controller
        if (this._controller) {
            this._controller.nodes.forEach((n) => n.destroy());
            this._controller.nodes.clear();
            this._controller.removeAllListeners();
            this._controller = undefined;
        }
        this.driverLog.print(`driver instance destroyed`);
        // destroy loggers as the very last thing
        this._logContainer.destroy();
        this._destroyPromise.resolve();
    }
    /**
     * Is called when the serial port has received a single-byte message or a complete message buffer
     */
    async serialport_onData(data) {
        if (typeof data === "number") {
            switch (data) {
                // single-byte messages - just forward them to the send thread
                case serial_1.MessageHeaders.ACK: {
                    if (this.serialAPIInterpreter?.status
                        === xstate_1.InterpreterStatus.Running) {
                        this.serialAPIInterpreter.send("ACK");
                    }
                    return;
                }
                case serial_1.MessageHeaders.NAK: {
                    if (this.serialAPIInterpreter?.status
                        === xstate_1.InterpreterStatus.Running) {
                        this.serialAPIInterpreter.send("NAK");
                    }
                    this._controller?.incrementStatistics("NAK");
                    return;
                }
                case serial_1.MessageHeaders.CAN: {
                    if (this.serialAPIInterpreter?.status
                        === xstate_1.InterpreterStatus.Running) {
                        this.serialAPIInterpreter.send("CAN");
                    }
                    this._controller?.incrementStatistics("CAN");
                    return;
                }
            }
        }
        let msg;
        try {
            // Parse the message while remembering potential decoding errors in embedded CCs
            // This way we can log the invalid CC contents
            msg = serial_1.Message.from(this, {
                data,
                sdkVersion: this._controller?.sdkVersion,
            });
            if ((0, cc_1.isCommandClassContainer)(msg)) {
                // Whether successful or not, a message from a node should update last seen
                const node = this.getNodeUnsafe(msg);
                if (node)
                    node.lastSeen = new Date();
                // Ensure there are no errors
                (0, cc_1.assertValidCCs)(msg);
            }
            // And update statistics
            if (!!this._controller) {
                if ((0, cc_1.isCommandClassContainer)(msg)) {
                    this.getNodeUnsafe(msg)?.incrementStatistics("commandsRX");
                }
                else {
                    this._controller.incrementStatistics("messagesRX");
                }
            }
            // all good, send ACK
            await this.writeHeader(serial_1.MessageHeaders.ACK);
        }
        catch (e) {
            try {
                if (await this.handleSecurityS2DecodeError(e, msg)) {
                    // TODO
                }
                else {
                    const response = this.handleDecodeError(e, data, msg);
                    if (response)
                        await this.writeHeader(response);
                    if (!!this._controller) {
                        if ((0, cc_1.isCommandClassContainer)(msg)) {
                            this.getNodeUnsafe(msg)?.incrementStatistics("commandsDroppedRX");
                            // Figure out if the command was received with supervision encapsulation
                            const supervisionSessionId = cc_1.SupervisionCC
                                .getSessionId(msg.command);
                            if (supervisionSessionId !== undefined
                                && msg.command instanceof cc_1.InvalidCC) {
                                // If it was, we need to notify the sender that we couldn't decode the command
                                const node = this.getNodeUnsafe(msg);
                                if (node) {
                                    const endpoint = node.getEndpoint(msg.command.endpointIndex) ?? node;
                                    const encapsulationFlags = msg.command.encapsulationFlags;
                                    await endpoint
                                        .createAPI(core_1.CommandClasses.Supervision, false)
                                        .sendReport({
                                        sessionId: supervisionSessionId,
                                        moreUpdatesFollow: false,
                                        status: core_1.SupervisionStatus.NoSupport,
                                        requestWakeUpOnDemand: this
                                            .shouldRequestWakeupOnDemand(node),
                                        encapsulationFlags,
                                        lowPriority: this
                                            .shouldUseLowPriorityForSupervisionReport(node, encapsulationFlags),
                                    });
                                }
                                return;
                            }
                        }
                        else {
                            this._controller.incrementStatistics("messagesDroppedRX");
                        }
                    }
                }
            }
            catch (ee) {
                if (ee instanceof Error) {
                    if (/serial port is not open/.test(ee.message)) {
                        this.emit("error", ee);
                        void this.destroy();
                        return;
                    }
                    // Print something, so we know what is wrong
                    this._driverLog.print(ee.stack ?? ee.message, "error");
                }
            }
            // Don't keep handling the message
            msg = undefined;
        }
        // If we receive a CC from a node while the controller is not ready yet,
        // we can't do anything with it, but logging it may assume that it can access the controller.
        // To prevent this problem, we just ignore CCs until the controller is ready
        if (!this._controller && (0, cc_1.isCommandClassContainer)(msg))
            return;
        // If the message could be decoded, forward it to the send thread
        if (msg) {
            let wasMessageLogged = false;
            if ((0, cc_1.isCommandClassContainer)(msg)) {
                // SecurityCCCommandEncapsulationNonceGet is two commands in one, but
                // we're not set up to handle things like this. Reply to the nonce get
                // and handle the encapsulation part normally
                if (msg.command
                    instanceof cc_1.SecurityCCCommandEncapsulationNonceGet) {
                    void this.getNodeUnsafe(msg)?.handleSecurityNonceGet();
                }
                // Transport Service commands must be handled before assembling partial CCs
                if ((0, cc_1.isTransportServiceEncapsulation)(msg.command)) {
                    // Log Transport Service commands before doing anything else
                    this.driverLog.logMessage(msg, {
                        secondaryTags: ["partial"],
                        direction: "inbound",
                    });
                    wasMessageLogged = true;
                    void this.handleTransportServiceCommand(msg.command).catch(() => {
                        // Don't care about errors in incoming transport service commands
                    });
                }
                // Assemble partial CCs on the driver level. Only forward complete messages to the send thread machine
                if (!this.assemblePartialCCs(msg)) {
                    // Check if a message timer needs to be refreshed.
                    for (const entry of this.awaitedMessages) {
                        if (entry.refreshPredicate?.(msg)) {
                            entry.timeout?.refresh();
                            // Since this is a partial message there may be no clear 1:1 match.
                            // Therefore we loop through all awaited messages
                        }
                    }
                    return;
                }
                // Make sure we are allowed to handle this command
                if (this.isSecurityLevelTooLow(msg.command)
                    || this.shouldDiscardCC(msg.command)) {
                    if (!wasMessageLogged) {
                        this.driverLog.logMessage(msg, {
                            direction: "inbound",
                            secondaryTags: ["discarded"],
                        });
                    }
                    return;
                }
                // When we have a complete CC, save its values
                try {
                    this.persistCCValues(msg.command);
                }
                catch (e) {
                    // Indicate invalid payloads with a special CC type
                    if ((0, core_1.isZWaveError)(e)
                        && e.code
                            === core_1.ZWaveErrorCodes.PacketFormat_InvalidPayload) {
                        this.driverLog.print(`dropping CC with invalid values${typeof e.context === "string"
                            ? ` (Reason: ${e.context})`
                            : ""}`, "warn");
                        // TODO: We may need to do the S2 MOS dance here - or we can deal with it when the next valid CC arrives
                        return;
                    }
                    else {
                        throw e;
                    }
                }
                // Transport Service CC can be eliminated from the encapsulation stack, since it is always the outermost CC
                if ((0, cc_1.isTransportServiceEncapsulation)(msg.command)) {
                    msg.command = msg.command.encapsulated;
                    // Now we do want to log the command again, so we can see what was inside
                    wasMessageLogged = false;
                }
            }
            if (!wasMessageLogged) {
                try {
                    this.driverLog.logMessage(msg, {
                        direction: "inbound",
                    });
                }
                catch (e) {
                    // We shouldn't throw just because logging a message fails
                    this.driverLog.print(`Logging a message failed: ${(0, shared_1.getErrorMessage)(e)}`);
                }
            }
            // Check if this message is unsolicited by passing it to the Serial API command interpreter if possible
            if (this.serialAPIInterpreter?.status === xstate_1.InterpreterStatus.Running) {
                this.serialAPIInterpreter.send({
                    type: "message",
                    message: msg,
                });
            }
            else {
                void this.handleUnsolicitedMessage(msg);
            }
        }
    }
    /** Handles a decoding error and returns the desired reply to the stick */
    handleDecodeError(e, data, msg) {
        if ((0, core_1.isZWaveError)(e)) {
            switch (e.code) {
                case core_1.ZWaveErrorCodes.PacketFormat_Invalid:
                case core_1.ZWaveErrorCodes.PacketFormat_Checksum:
                case core_1.ZWaveErrorCodes.PacketFormat_Truncated:
                    this.driverLog.print(`Dropping message because it contains invalid data`, "warn");
                    return serial_1.MessageHeaders.NAK;
                case core_1.ZWaveErrorCodes.Deserialization_NotImplemented:
                case core_1.ZWaveErrorCodes.CC_NotImplemented:
                    this.driverLog.print(`Dropping message because it could not be deserialized: ${e.message}`, "warn");
                    return serial_1.MessageHeaders.ACK;
                case core_1.ZWaveErrorCodes.Driver_NotReady:
                    this.driverLog.print(`Dropping message because the driver is not ready to handle it yet.`, "warn");
                    return serial_1.MessageHeaders.ACK;
                case core_1.ZWaveErrorCodes.PacketFormat_InvalidPayload:
                    if (msg) {
                        this.driverLog.print(`Dropping message with invalid payload`, "warn");
                        try {
                            this.driverLog.logMessage(msg, {
                                direction: "inbound",
                            });
                        }
                        catch (e) {
                            // We shouldn't throw just because logging a message fails
                            this.driverLog.print(`Logging a message failed: ${(0, shared_1.getErrorMessage)(e)}`);
                        }
                    }
                    else {
                        this.driverLog.print(`Dropping message with invalid payload${typeof e.context === "string"
                            ? ` (Reason: ${e.context})`
                            : ""}:
0x${data.toString("hex")}`, "warn");
                    }
                    return serial_1.MessageHeaders.ACK;
                case core_1.ZWaveErrorCodes.Driver_NoSecurity:
                case core_1.ZWaveErrorCodes.Security2CC_NotInitialized:
                    this.driverLog.print(`Dropping message because network keys are not set or the driver is not yet ready to receive secure messages.`, "warn");
                    return serial_1.MessageHeaders.ACK;
                case core_1.ZWaveErrorCodes.Controller_NodeNotFound:
                    this.driverLog.print(`Dropping message because ${typeof e.context === "number"
                        ? `node ${e.context}`
                        : "the node"} does not exist.`, "warn");
                    return serial_1.MessageHeaders.ACK;
            }
        }
        else {
            if (/database is not open/.test(e.message)) {
                // The JSONL-DB is not open yet
                this.driverLog.print(`Dropping message because the driver is not ready to handle it yet.`, "warn");
                return serial_1.MessageHeaders.ACK;
            }
        }
        // Pass all other errors through
        throw e;
    }
    mustReplyWithSecurityS2MOS(msg) {
        // We're looking for a singlecast S2-encapsulated request
        if (msg.frameType !== "singlecast")
            return false;
        const encapS2 = msg.command.getEncapsulatingCC(core_1.CommandClasses["Security 2"], cc_1.Security2Command.MessageEncapsulation);
        if (!encapS2)
            return false;
        // With the MGRP extension present
        const node = this.getNodeUnsafe(msg);
        const groupId = encapS2.getMulticastGroupId();
        if (node
            && groupId != undefined
            // but where we don't have an MPAN stored
            && this.securityManager2?.getPeerMPAN(msg.command.nodeId, groupId).type !== core_1.MPANState.MPAN) {
            return true;
        }
        return false;
    }
    async handleSecurityS2DecodeError(e, msg) {
        if (!(0, core_1.isZWaveError)(e))
            return false;
        if ((e.code === core_1.ZWaveErrorCodes.Security2CC_NoSPAN
            || e.code === core_1.ZWaveErrorCodes.Security2CC_CannotDecode)
            && (0, cc_1.isCommandClassContainer)(msg)) {
            // Decoding the command failed because no SPAN has been established with the other node
            const nodeId = msg.getNodeId();
            // If the node isn't known, ignore this error
            const node = this._controller?.nodes.get(nodeId);
            if (!node)
                return false;
            // Before we can send anything, ACK the command
            await this.writeHeader(serial_1.MessageHeaders.ACK);
            this.driverLog.logMessage(msg, { direction: "inbound" });
            node.incrementStatistics("commandsDroppedRX");
            // We might receive this before the node has been interviewed. If that case, we need to mark Security S2 as
            // supported or we won't ever be able to communicate with the node
            if (node.interviewStage < _Types_1.InterviewStage.NodeInfo) {
                node.addCC(core_1.CommandClasses["Security 2"], {
                    isSupported: true,
                    version: 1,
                });
            }
            // Ensure that we're not flooding the queue with unnecessary NonceReports
            const isS2NonceReport = (t) => t.message.getNodeId() === nodeId
                && (0, cc_1.isCommandClassContainer)(t.message)
                && t.message.command instanceof cc_1.Security2CCNonceReport;
            const message = e.code === core_1.ZWaveErrorCodes.Security2CC_CannotDecode
                ? "Message authentication failed"
                : "No SPAN is established yet";
            if (this.controller.bootstrappingS2NodeId === nodeId) {
                // The node is currently being bootstrapped.
                if (this.securityManager2?.tempKeys.has(nodeId)) {
                    // The DSK has been verified, so we should be able to decode this command.
                    // If this is the first attempt, we need to request a nonce first
                    if (this.securityManager2.getSPANState(nodeId).type
                        === core_1.SPANState.None) {
                        this.controllerLog.logNode(nodeId, {
                            message: `${message}, cannot decode command. Requesting a nonce...`,
                            level: "verbose",
                            direction: "outbound",
                        });
                        // Send the node our nonce
                        node.commandClasses["Security 2"]
                            .sendNonce()
                            .catch(() => {
                            // Ignore errors
                        });
                    }
                    else {
                        // Us repeatedly not being able to decode the command means we need to abort the bootstrapping process
                        // because the PIN is wrong
                        this.controllerLog.logNode(nodeId, {
                            message: `${message}, cannot decode command. Aborting the S2 bootstrapping process...`,
                            level: "error",
                            direction: "inbound",
                        });
                        this.controller.cancelSecureBootstrapS2(cc_1.KEXFailType.BootstrappingCanceled);
                    }
                }
                else {
                    this.controllerLog.logNode(nodeId, {
                        message: `Ignoring KEXSet because the DSK has not been verified yet`,
                        level: "verbose",
                        direction: "inbound",
                    });
                }
            }
            else if (!this.hasPendingTransactions(isS2NonceReport)) {
                this.controllerLog.logNode(nodeId, {
                    message: `${message}, cannot decode command. Requesting a nonce...`,
                    level: "verbose",
                    direction: "outbound",
                });
                // Send the node our nonce, and use the chance to re-sync the MPAN if necessary
                const s2MulticastOutOfSync = (msg instanceof ApplicationCommandRequest_1.ApplicationCommandRequest
                    || msg instanceof BridgeApplicationCommandRequest_1.BridgeApplicationCommandRequest)
                    && this.mustReplyWithSecurityS2MOS(msg);
                node.commandClasses["Security 2"]
                    .withOptions({ s2MulticastOutOfSync })
                    .sendNonce()
                    .catch(() => {
                    // Ignore errors
                });
            }
            else {
                this.controllerLog.logNode(nodeId, {
                    message: `${message}, cannot decode command.`,
                    level: "verbose",
                    direction: "none",
                });
            }
            return true;
        }
        else if ((e.code === core_1.ZWaveErrorCodes.Security2CC_NoMPAN
            || e.code === core_1.ZWaveErrorCodes.Security2CC_CannotDecodeMulticast)
            && (0, cc_1.isCommandClassContainer)(msg)) {
            // Decoding the command failed because the MPAN used by the other node
            // is not known to us yet
            const nodeId = msg.getNodeId();
            // If the node isn't known, ignore this error
            const node = this._controller?.nodes.get(nodeId);
            if (!node)
                return false;
            // Before we can send anything, ACK the command
            await this.writeHeader(serial_1.MessageHeaders.ACK);
            this.driverLog.logMessage(msg, { direction: "inbound" });
            node.incrementStatistics("commandsDroppedRX");
            this.controllerLog.logNode(nodeId, {
                message: `Cannot decode S2 multicast command, since MPAN is not known yet. Will attempt re-sync after the next singlecast.`,
                level: "verbose",
            });
            return true;
        }
        return false;
    }
    /** Checks if a transaction failed because a node didn't respond in time */
    isMissingNodeACK(transaction, e) {
        return (
        // If the node does not acknowledge our request, it is either asleep or dead
        e.code === core_1.ZWaveErrorCodes.Controller_CallbackNOK
            && (transaction.message instanceof SendDataMessages_1.SendDataRequest
                || transaction.message instanceof SendDataBridgeMessages_1.SendDataBridgeRequest));
    }
    /**
     * @internal
     * Handles the case that a node failed to respond in time.
     * Returns `true` if the transaction failure was handled, `false` if it needs to be rejected.
     */
    handleMissingNodeACK(transaction, error) {
        const node = this.getNodeUnsafe(transaction.message);
        if (!node)
            return false; // This should never happen, but whatever
        const messagePart1 = (0, SendDataShared_1.isSendData)(transaction.message)
            ? `The node did not respond after ${transaction.message.maxSendAttempts} attempts`
            : `The node did not respond`;
        if (!transaction.changeNodeStatusOnTimeout) {
            // The sender of this transaction doesn't want it to change the status of the node
            return false;
        }
        else if (node.canSleep) {
            if (node.status === _Types_1.NodeStatus.Asleep) {
                // We already moved the messages to the wakeup queue before. If we end up here, this means a command
                // was sent that may be sent to potentially asleep nodes - including pings.
                return false;
            }
            this.controllerLog.logNode(node.id, `${messagePart1}. It is probably asleep, moving its messages to the wakeup queue.`, "warn");
            // There is no longer a reference to the current transaction. If it should be moved to the wakeup queue,
            // it temporarily needs to be added to the queue again.
            const handled = this.mayMoveToWakeupQueue(transaction);
            if (handled) {
                this.queue.add(transaction);
            }
            // Mark the node as asleep. This will move the messages to the wakeup queue
            node.markAsAsleep();
            return handled;
        }
        else {
            const errorMsg = `${messagePart1}, it is presumed dead`;
            this.controllerLog.logNode(node.id, errorMsg, "warn");
            node.markAsDead();
            // There is no longer a reference to the current transaction on the queue, so we need to reject it separately.
            transaction.setProgress({
                state: core_1.TransactionState.Failed,
                reason: errorMsg,
            });
            transaction.abort(error);
            this.rejectAllTransactionsForNode(node.id, errorMsg);
            return true;
        }
    }
    /**
     * @internal
     * Handles the case that the controller didn't acknowledge a command in time
     * Returns `true` if the transaction failure was handled, `false` if it needs to be rejected.
     */
    handleMissingControllerACK(transaction, error) {
        if (!this._controller || !this.mayRecoverUnresponsiveController()) {
            return false;
        }
        const recoverByReopeningSerialport = async () => {
            if (!this.serial)
                return;
            this.driverLog.print("Attempting to recover unresponsive controller by reopening the serial port...", "warn");
            if (this.serial.isOpen)
                await this.serial.close();
            await (0, async_1.wait)(1000);
            await this.openSerialport();
            this.driverLog.print("Serial port reopened. Returning to normal operation and hoping for the best...", "warn");
            // We don't know if this worked
            // Go back to normal operation and hope for the best.
            this._controller?.setStatus(core_1.ControllerStatus.Ready);
            this._recoveryPhase = 0 /* ControllerRecoveryPhase.None */;
        };
        if ((this._controller.status !== core_1.ControllerStatus.Unresponsive
            && !this.maySoftReset())
            || this._recoveryPhase
                === 2 /* ControllerRecoveryPhase.ACKTimeoutAfterReset */) {
            // Either we can/could not do a soft reset or the controller is still timing out afterwards
            void recoverByReopeningSerialport().catch(shared_1.noop);
            return true;
        }
        else if (this._controller.status !== core_1.ControllerStatus.Unresponsive) {
            // The controller was responsive before this transaction failed.
            // Mark it as unresponsive and try to soft-reset it.
            this.controller.setStatus(core_1.ControllerStatus.Unresponsive);
            this._recoveryPhase = 1 /* ControllerRecoveryPhase.ACKTimeout */;
            this.driverLog.print("Attempting to recover unresponsive controller by restarting it...", "warn");
            // Execute the soft-reset asynchronously
            void this.softReset().then(() => {
                // The controller responded. It is no longer unresponsive
                // Re-queue the transaction, so it can get handled next.
                // Its message generator may have finished, so reset that too.
                transaction.reset();
                this.getQueueForTransaction(transaction).add(transaction.clone());
                this._controller?.setStatus(core_1.ControllerStatus.Ready);
                this._recoveryPhase = 0 /* ControllerRecoveryPhase.None */;
            }).catch(() => {
                // Soft-reset failed. Reject the transaction
                this.rejectTransaction(transaction, error);
                // and reopen the serial port
                return recoverByReopeningSerialport();
            });
            return true;
        }
        else {
            // Not sure what to do here
            return false;
        }
    }
    /**
     * @internal
     * Handles the case that the controller didn't send the callback for a SendData in time
     * Returns `true` if the transaction failure was handled, `false` if it needs to be rejected.
     */
    handleMissingSendDataResponseOrCallback(transaction, error) {
        if (!this._controller || !this.mayRecoverUnresponsiveController()) {
            return false;
        }
        if (
        // The SendData response can time out on older controllers trying to reach a dead node.
        // In this case, we do not want to reset the controller, but just mark the node as dead.
        error.context === "response"
            // Also do this if the callback is timing out even after restarting the controller
            || this._recoveryPhase
                === 4 /* ControllerRecoveryPhase.CallbackTimeoutAfterReset */) {
            const node = this.getNodeUnsafe(transaction.message);
            if (!node)
                return false; // This should never happen, but whatever
            // The controller is still timing out transmitting after a soft reset, don't try again.
            // Real-world experience has shown that for older controllers this situation can be caused by unresponsive nodes.
            // The following is essentially a copy of handleMissingNodeACK, but with updated error messages
            const messagePart1 = "The node is causing the controller to become unresponsive";
            if (node.canSleep) {
                if (node.status === _Types_1.NodeStatus.Asleep) {
                    // We already moved the messages to the wakeup queue before. If we end up here, this means a command
                    // was sent that may be sent to potentially asleep nodes - including pings.
                    return false;
                }
                this.controllerLog.logNode(node.id, `${messagePart1}. It is probably asleep, moving its messages to the wakeup queue.`, "warn");
                // There is no longer a reference to the current transaction. If it should be moved to the wakeup queue,
                // it temporarily needs to be added to the queue again.
                const handled = this.mayMoveToWakeupQueue(transaction);
                if (handled) {
                    this.queue.add(transaction);
                }
                // Mark the node as asleep. This will move the messages to the wakeup queue
                node.markAsAsleep();
                return handled;
            }
            else {
                const errorMsg = `${messagePart1}, it is presumed dead`;
                this.controllerLog.logNode(node.id, errorMsg, "warn");
                node.markAsDead();
                // There is no longer a reference to the current transaction on the queue, so we need to reject it separately.
                transaction.setProgress({
                    state: core_1.TransactionState.Failed,
                    reason: errorMsg,
                });
                transaction.abort(error);
                this.rejectAllTransactionsForNode(node.id, errorMsg);
                return true;
            }
        }
        else if (this._controller.status !== core_1.ControllerStatus.Unresponsive) {
            // The controller was responsive before this transaction failed.
            if (this.maySoftReset()) {
                // Mark it as unresponsive and try to soft-reset it.
                this.controller.setStatus(core_1.ControllerStatus.Unresponsive);
                this._recoveryPhase = 3 /* ControllerRecoveryPhase.CallbackTimeout */;
                this.driverLog.print("Controller missed Send Data callback. Attempting to recover...", "warn");
                // Execute the soft-reset asynchronously
                void this.softReset().then(() => {
                    // The controller responded. It is no longer unresponsive.
                    // Re-queue the transaction, so it can get handled next.
                    // Its message generator may have finished, so reset that too.
                    transaction.reset();
                    this.getQueueForTransaction(transaction).add(transaction.clone());
                    this._controller?.setStatus(core_1.ControllerStatus.Ready);
                    this._recoveryPhase =
                        4 /* ControllerRecoveryPhase.CallbackTimeoutAfterReset */;
                }).catch(() => {
                    // Soft-reset failed. Just reject the transaction
                    this.rejectTransaction(transaction, error);
                    this.driverLog.print("Automatic controller recovery failed. Returning to normal operation and hoping for the best.", "warn");
                    this._recoveryPhase = 0 /* ControllerRecoveryPhase.None */;
                    this._controller?.setStatus(core_1.ControllerStatus.Ready);
                });
            }
            else {
                this.driverLog.print("Controller missed Send Data callback. Cannot recover automatically because the soft reset feature is unsupported or disabled. Returning to normal operation and hoping for the best...", "warn");
                this.rejectTransaction(transaction, error);
            }
            return true;
        }
        else {
            // Not sure what to do here
            return false;
        }
    }
    shouldRequestWakeupOnDemand(node) {
        return (!!node.supportsWakeUpOnDemand
            && node.status === _Types_1.NodeStatus.Asleep
            && this.hasPendingTransactions((t) => t.requestWakeUpOnDemand
                && t.message.getNodeId() === node.id));
    }
    partialCCSessions = new Map();
    getPartialCCSession(command, createIfMissing) {
        const sessionId = command.getPartialCCSessionId();
        if (sessionId) {
            // This CC belongs to a partial session
            const partialSessionKey = JSON.stringify({
                nodeId: command.nodeId,
                ccId: command.ccId,
                ccCommand: command.ccCommand,
                ...sessionId,
            });
            if (createIfMissing
                && !this.partialCCSessions.has(partialSessionKey)) {
                this.partialCCSessions.set(partialSessionKey, []);
            }
            return {
                partialSessionKey,
                session: this.partialCCSessions.get(partialSessionKey),
            };
        }
    }
    /**
     * Assembles partial CCs of in a message body. Returns `true` when the message is complete and can be handled further.
     * If the message expects another partial one, this returns `false`.
     */
    assemblePartialCCs(msg) {
        let command = msg.command;
        // We search for the every CC that provides us with a session ID
        // There might be newly-completed CCs that contain a partial CC,
        // so investigate the entire CC encapsulation stack.
        while (true) {
            const { partialSessionKey, session } = this.getPartialCCSession(command, true) ?? {};
            if (session) {
                // This CC belongs to a partial session
                if (command.expectMoreMessages(session)) {
                    // this is not the final one, store it
                    session.push(command);
                    if (!(0, cc_1.isTransportServiceEncapsulation)(msg.command)) {
                        // and don't handle the command now
                        this.driverLog.logMessage(msg, {
                            secondaryTags: ["partial"],
                            direction: "inbound",
                        });
                    }
                    return false;
                }
                else {
                    // this is the final one, merge the previous responses
                    this.partialCCSessions.delete(partialSessionKey);
                    try {
                        command.mergePartialCCs(this, session);
                        // Ensure there are no errors
                        (0, cc_1.assertValidCCs)(msg);
                    }
                    catch (e) {
                        if ((0, core_1.isZWaveError)(e)) {
                            switch (e.code) {
                                case core_1.ZWaveErrorCodes
                                    .Deserialization_NotImplemented:
                                case core_1.ZWaveErrorCodes.CC_NotImplemented:
                                    this.driverLog.print(`Dropping message because it could not be deserialized: ${e.message}`, "warn");
                                    // Don't continue handling this message
                                    return false;
                                case core_1.ZWaveErrorCodes
                                    .PacketFormat_InvalidPayload:
                                    this.driverLog.print(`Could not assemble partial CCs because the payload is invalid. Dropping them.`, "warn");
                                    // Don't continue handling this message
                                    return false;
                                case core_1.ZWaveErrorCodes.Driver_NotReady:
                                    this.driverLog.print(`Could not assemble partial CCs because the driver is not ready yet. Dropping them`, "warn");
                                    // Don't continue handling this message
                                    return false;
                            }
                        }
                        throw e;
                    }
                    // Assembling this CC was successful - but it might contain another partial CC
                }
            }
            else {
                // No partial CC, just continue
            }
            // If this is an encapsulating CC, we need to look one level deeper
            if ((0, cc_1.isEncapsulatingCommandClass)(command)) {
                command = command.encapsulated;
            }
            else {
                break;
            }
        }
        return true;
    }
    /** Is called when a Transport Service command is received */
    async handleTransportServiceCommand(command) {
        const nodeSessions = this.ensureNodeSessions(command.nodeId);
        // If this command belongs to an existing session, just forward it to the state machine
        const transportSession = nodeSessions.transportService.get(command.sessionId);
        if (command instanceof cc_1.TransportServiceCCFirstSegment) {
            // This is the first message in a sequence. Create or re-initialize the session
            // We don't delete finished sessions when the last message is received in order to be able to
            // handle when the SegmentComplete message gets lost. As soon as the node initializes a new session,
            // we do know that the previous one is finished.
            if (transportSession) {
                transportSession.interpreter.stop();
            }
            nodeSessions.transportService.clear();
            this.controllerLog.logNode(command.nodeId, {
                message: `Beginning Transport Service RX session #${command.sessionId}...`,
                level: "debug",
                direction: "inbound",
            });
            const RXStateMachine = (0, TransportServiceMachine_1.createTransportServiceRXMachine)({
                requestMissingSegment: async (offset) => {
                    this.controllerLog.logNode(command.nodeId, {
                        message: `Transport Service RX session #${command.sessionId}: Segment with offset ${offset} missing - requesting it...`,
                        level: "debug",
                        direction: "outbound",
                    });
                    const cc = new cc_1.TransportServiceCCSegmentRequest(this, {
                        nodeId: command.nodeId,
                        sessionId: command.sessionId,
                        datagramOffset: offset,
                    });
                    await this.sendCommand(cc, {
                        maxSendAttempts: 1,
                        priority: core_1.MessagePriority.Immediate,
                    });
                },
                sendSegmentsComplete: async () => {
                    this.controllerLog.logNode(command.nodeId, {
                        message: `Transport Service RX session #${command.sessionId} complete`,
                        level: "debug",
                        direction: "outbound",
                    });
                    const cc = new cc_1.TransportServiceCCSegmentComplete(this, {
                        nodeId: command.nodeId,
                        sessionId: command.sessionId,
                    });
                    await this.sendCommand(cc, {
                        maxSendAttempts: 1,
                        priority: core_1.MessagePriority.Immediate,
                    });
                },
            }, {
                // TODO: Figure out how to know which timeout is the correct one. For now use the larger one
                missingSegmentTimeout: cc_1.TransportServiceTimeouts.requestMissingSegmentR2,
                datagramSize: command.datagramSize,
                firstSegmentSize: command.partialDatagram.length,
            });
            const interpreter = (0, xstate_1.interpret)(RXStateMachine).start();
            nodeSessions.transportService.set(command.sessionId, {
                fragmentSize: command.partialDatagram.length,
                interpreter,
            });
            interpreter.onTransition((state) => {
                if (state.changed && state.value === "failure") {
                    this.controllerLog.logNode(command.nodeId, {
                        message: `Transport Service RX session #${command.sessionId} failed`,
                        level: "error",
                        direction: "none",
                    });
                    // TODO: Update statistics
                    interpreter.stop();
                    nodeSessions.transportService.delete(command.sessionId);
                }
            });
        }
        else {
            // This is a subsequent message in a sequence. Just forward it to the state machine if there is one
            if (transportSession) {
                transportSession.interpreter.send({
                    type: "segment",
                    offset: command.datagramOffset,
                    length: command.partialDatagram.length,
                });
            }
            else {
                // This belongs to a session we don't know... tell the sending node to try again
                const cc = new cc_1.TransportServiceCCSegmentWait(this, {
                    nodeId: command.nodeId,
                    pendingSegments: 0,
                });
                await this.sendCommand(cc, {
                    maxSendAttempts: 1,
                    priority: core_1.MessagePriority.Immediate,
                });
            }
        }
    }
    /**
     * Is called when a message is received that does not belong to any ongoing transactions
     * @param msg The decoded message
     */
    async handleUnsolicitedMessage(msg) {
        if (msg.type === serial_1.MessageType.Request) {
            // This is a request we might have registered handlers for
            try {
                await this.handleRequest(msg);
            }
            catch (e) {
                if ((0, core_1.isZWaveError)(e)
                    && e.code === core_1.ZWaveErrorCodes.Driver_NotReady) {
                    this.driverLog.print(`Cannot handle message because the driver is not ready to handle it yet.`, "warn");
                }
                else {
                    throw e;
                }
            }
        }
        else {
            this.driverLog.transactionResponse(msg, undefined, "unexpected");
            this.driverLog.print("unexpected response, discarding...", "warn");
        }
    }
    /**
     * Registers a handler for messages that are not handled by the driver as part of a message exchange.
     * The handler function needs to return a boolean indicating if the message has been handled.
     * Registered handlers are called in sequence until a handler returns `true`.
     *
     * @param fnType The function type to register the handler for
     * @param handler The request handler callback
     * @param oneTime Whether the handler should be removed after its first successful invocation
     */
    registerRequestHandler(fnType, handler, oneTime = false) {
        const handlers = this.requestHandlers.has(fnType)
            ? this.requestHandlers.get(fnType)
            : [];
        const entry = { invoke: handler, oneTime };
        handlers.push(entry);
        this.driverLog.print(`added${oneTime ? " one-time" : ""} request handler for ${serial_1.FunctionType[fnType]} (${(0, shared_1.num2hex)(fnType)})...
${handlers.length} registered`);
        this.requestHandlers.set(fnType, handlers);
    }
    /**
     * Unregisters a message handler that has been added with `registerRequestHandler`
     * @param fnType The function type to unregister the handler for
     * @param handler The previously registered request handler callback
     */
    unregisterRequestHandler(fnType, handler) {
        const handlers = this.requestHandlers.has(fnType)
            ? this.requestHandlers.get(fnType)
            : [];
        for (let i = 0, entry = handlers[i]; i < handlers.length; i++) {
            // remove the handler if it was found
            if (entry.invoke === handler) {
                handlers.splice(i, 1);
                break;
            }
        }
        this.driverLog.print(`removed request handler for ${serial_1.FunctionType[fnType]} (${fnType})...
${handlers.length} left`);
        this.requestHandlers.set(fnType, handlers);
    }
    /**
     * Checks whether a CC has a lower than expected security level and needs to be discarded
     */
    isSecurityLevelTooLow(cc) {
        // With Security S0, some commands may be accepted without encryption, some require it
        // With Security S2, a node MUST support its command classes only when communication is using its
        // highest Security Class granted during security bootstrapping.
        // We already discard lower S2 keys when decrypting, so all that's left here to check is if the
        // CC is encrypted at all.
        const node = this._controller?.nodes.get(cc.nodeId);
        if (!node) {
            // Node does not exist, don't accept the CC
            this.controllerLog.logNode(cc.nodeId, `is unknown - discarding received command...`, "warn");
            return true;
        }
        // Transport Service has a special handler
        if (cc instanceof cc_1.TransportServiceCC)
            return false;
        // CRC16 belongs outside of Security encapsulation
        if (cc instanceof cc_1.CRC16CCCommandEncapsulation) {
            return this.isSecurityLevelTooLow(cc.encapsulated);
        }
        if (cc.constructor.name.endsWith("Get")
            && (cc.frameType === "multicast" || cc.frameType === "broadcast")) {
            this.controllerLog.logNode(cc.nodeId, `received GET-type command via ${cc.frameType} - discarding...`, "warn");
            return true;
        }
        const secClass = node.getHighestSecurityClass();
        if (secClass === core_1.SecurityClass.None
            || secClass === core_1.SecurityClass.Temporary) {
            return false;
        }
        const expectedSecurityCC = (0, core_1.securityClassIsS2)(secClass)
            ? core_1.CommandClasses["Security 2"]
            : secClass === core_1.SecurityClass.S0_Legacy
                ? core_1.CommandClasses.Security
                : undefined;
        const discardAnyways = (cmd) => {
            // S2-encapsulated CCs must always be discarded if they are received using a lower security class, except:
            // - CommandsSupportedGet and CommandsSupportedReport
            // - multicast commands
            if (!(cmd instanceof cc_1.Security2CCMessageEncapsulation))
                return false;
            if (cmd.getMulticastGroupId() != undefined)
                return false;
            // This shouldn't happen, but better be sure
            if (cmd.securityClass == undefined)
                return true;
            // Received at the highest security class -> ok
            if (cmd.securityClass === secClass)
                return false;
            if (cmd.encapsulated instanceof cc_1.Security2CCCommandsSupportedGet
                || cmd.encapsulated
                    instanceof cc_1.Security2CCCommandsSupportedReport) {
                return false;
            }
            return true;
        };
        const acceptAnyways = (cmd) => {
            // Some CCs are always accepted, regardless of security class
            if (cmd instanceof cc_1.SecurityCC) {
                switch (cmd.ccCommand) {
                    // Cannot be sent encapsulated:
                    case cc_1.SecurityCommand.NonceGet:
                    case cc_1.SecurityCommand.NonceReport:
                    case cc_1.SecurityCommand.SchemeGet:
                    case cc_1.SecurityCommand.SchemeReport:
                        return true;
                    // Needs to be accepted to be able interview/respond to S0 queries
                    case cc_1.SecurityCommand.CommandsSupportedGet:
                    case cc_1.SecurityCommand.CommandsSupportedReport:
                        return cmd.isEncapsulatedWith(core_1.CommandClasses.Security, cc_1.SecurityCommand.CommandEncapsulation);
                }
            }
            return false;
        };
        let isSecure = false;
        let requiresSecurity = (0, core_1.securityClassIsS2)(secClass);
        while (true) {
            if ((cc.ccId === expectedSecurityCC && !discardAnyways(cc))
                || acceptAnyways(cc)) {
                isSecure = true;
            }
            if ((0, cc_1.isEncapsulatingCommandClass)(cc)) {
                cc = cc.encapsulated;
            }
            else if ((0, cc_1.isMultiEncapsulatingCommandClass)(cc)) {
                requiresSecurity ||= cc.encapsulated.some((cmd) => node.isCCSecure(cmd.ccId));
                break;
            }
            else {
                requiresSecurity ||= node.isCCSecure(cc.ccId)
                    && cc.ccId !== core_1.CommandClasses.Security
                    && cc.ccId !== core_1.CommandClasses["Security 2"];
                break;
            }
        }
        if (requiresSecurity && !isSecure) {
            // none found, don't accept the CC
            this.controllerLog.logNode(cc.nodeId, `command was received at a lower security level than expected - discarding it...`, "warn");
            return true;
        }
        return false;
    }
    /** Checks whether a CC should be discarded */
    shouldDiscardCC(cc) {
        if ((0, cc_1.isEncapsulatingCommandClass)(cc)) {
            return this.shouldDiscardCC(cc.encapsulated);
        }
        const node = this._controller?.nodes.get(cc.nodeId);
        // We should have checked this before, but better be safe than sorry
        if (!node) {
            // Node does not exist, don't accept the CC
            this.controllerLog.logNode(cc.nodeId, `is unknown - discarding received command...`, "warn");
            return true;
        }
        // Do not accept Meter CC and/or Multilevel Sensor CC if the node does not support them
        // https://github.com/zwave-js/node-zwave-js/issues/5510
        // TODO: Consider expanding this to all CCs and not only reports
        if (cc.ccId === core_1.CommandClasses.Meter
            || cc.ccId === core_1.CommandClasses["Multilevel Sensor"]) {
            const endpoint = node.getEndpoint(cc.endpointIndex) ?? node;
            if (!endpoint.supportsCC(cc.ccId) && !endpoint.controlsCC(cc.ccId)) {
                this.controllerLog.logNode(cc.nodeId, `${cc.endpointIndex > 0
                    ? `Endpoint ${cc.endpointIndex} `
                    : ""}does not support CC ${(0, core_1.getCCName)(cc.ccId)} - discarding received command...`, "warn");
                return true;
            }
        }
        return false;
    }
    /**
     * Is called when a Request-type message was received
     */
    async handleRequest(msg) {
        let handlers;
        if ((0, serial_1.isNodeQuery)(msg) || (0, cc_1.isCommandClassContainer)(msg)) {
            const node = this.getNodeUnsafe(msg);
            if (node) {
                // We have received an unsolicited message from a dead node, bring it back to life
                if (node.status === _Types_1.NodeStatus.Dead) {
                    node.markAsAlive();
                }
            }
        }
        // Check if we have a dynamic handler waiting for this message
        for (const entry of this.awaitedMessages) {
            if (entry.predicate(msg)) {
                // We do
                entry.handler(msg);
                return;
            }
        }
        // It could also be that this is the node's response for a CC that we sent, but where the ACK is delayed
        if ((0, cc_1.isCommandClassContainer)(msg)) {
            const currentMessage = this.queue.currentTransaction
                ?.getCurrentMessage();
            if (currentMessage
                && currentMessage.expectsNodeUpdate()
                && currentMessage.isExpectedNodeUpdate(msg)) {
                // The message we're currently sending is still in progress but expects this message in response.
                // Remember the message there.
                this.controllerLog.logNode(msg.getNodeId(), {
                    message: `received expected response prematurely, remembering it...`,
                    level: "verbose",
                    direction: "inbound",
                });
                currentMessage.prematureNodeUpdate = msg;
                return;
            }
        }
        if ((0, cc_1.isCommandClassContainer)(msg)) {
            // For further actions, we are only interested in the innermost CC
            this.unwrapCommands(msg);
        }
        // Otherwise go through the static handlers
        if (msg instanceof ApplicationCommandRequest_1.ApplicationCommandRequest
            || msg instanceof BridgeApplicationCommandRequest_1.BridgeApplicationCommandRequest) {
            // we handle ApplicationCommandRequests differently because they are handled by the nodes directly
            const nodeId = msg.command.nodeId;
            // cannot handle ApplicationCommandRequests without a controller
            if (this._controller == undefined) {
                this.driverLog.print(`  the controller is not ready yet, discarding...`, "warn");
                return;
            }
            else if (!this.controller.nodes.has(nodeId)) {
                this.driverLog.print(`  the node is unknown or not initialized yet, discarding...`, "warn");
                return;
            }
            const node = this.controller.nodes.get(nodeId);
            const nodeSessions = this.nodeSessions.get(nodeId);
            // Check if we need to handle the command ourselves
            if (msg.command.ccId === core_1.CommandClasses["Device Reset Locally"]
                && msg.command instanceof cc_1.DeviceResetLocallyCCNotification) {
                this.controllerLog.logNode(msg.command.nodeId, {
                    message: `The node was reset locally, removing it`,
                    direction: "inbound",
                });
                try {
                    await this.controller.removeFailedNodeInternal(msg.command.nodeId, Inclusion_1.RemoveNodeReason.Reset);
                }
                catch (e) {
                    this.controllerLog.logNode(msg.command.nodeId, {
                        message: `removing the node failed: ${(0, shared_1.getErrorMessage)(e)}`,
                        level: "error",
                    });
                }
            }
            else if (msg.command.ccId === core_1.CommandClasses.Supervision
                && msg.command instanceof cc_1.SupervisionCCReport
                && nodeSessions?.supervision.has(msg.command.sessionId)) {
                // Supervision commands are handled here
                this.controllerLog.logNode(msg.command.nodeId, {
                    message: `Received update for a Supervision session`,
                    direction: "inbound",
                });
                // Call the update handler
                nodeSessions.supervision.get(msg.command.sessionId)({
                    status: msg.command.status,
                    remainingDuration: msg.command.duration,
                });
                // If this was a final report, remove the handler
                if (!msg.command.moreUpdatesFollow) {
                    nodeSessions.supervision.delete(msg.command.sessionId);
                }
            }
            else {
                // Figure out if the command was received with supervision encapsulation and we need to respond accordingly
                const supervisionSessionId = cc_1.SupervisionCC.getSessionId(msg.command);
                // Figure out if this is an S2 multicast followup for a group that is out of sync
                const s2MulticastOutOfSync = this.mustReplyWithSecurityS2MOS(msg);
                const encapsulationFlags = msg.command.encapsulationFlags;
                let reply;
                if (supervisionSessionId != undefined) {
                    // The command was supervised, and we must respond with a Supervision Report
                    const endpoint = node.getEndpoint(msg.command.endpointIndex)
                        ?? node;
                    reply = (success) => endpoint
                        .createAPI(core_1.CommandClasses.Supervision, false)
                        .withOptions({ s2MulticastOutOfSync })
                        .sendReport({
                        sessionId: supervisionSessionId,
                        moreUpdatesFollow: false,
                        status: success
                            ? core_1.SupervisionStatus.Success
                            : core_1.SupervisionStatus.Fail,
                        requestWakeUpOnDemand: this
                            .shouldRequestWakeupOnDemand(node),
                        encapsulationFlags,
                        lowPriority: this
                            .shouldUseLowPriorityForSupervisionReport(node, encapsulationFlags),
                    });
                }
                else {
                    // Unsupervised, reply is a no-op
                    reply = () => Promise.resolve();
                }
                // DO NOT force-add support for the Supervision CC here. Some devices only support Supervision when sending,
                // so we need to trust the information we already have.
                // In the case where the command was unsupervised and we need to send a MOS, do it as soon as possible
                if (supervisionSessionId == undefined && s2MulticastOutOfSync) {
                    // If the command was NOT received using Supervision,
                    // we need to respond with an MOS nonce. Otherwise we'll set the flag
                    // on the Supervision Report
                    node.commandClasses["Security 2"].sendMOS().catch(() => {
                        // Ignore errors
                    });
                }
                // check if someone is waiting for this command
                for (const entry of this.awaitedCommands) {
                    if (entry.predicate(msg.command)) {
                        // there is!
                        entry.handler(msg.command);
                        // and possibly reply to a supervised command
                        await reply(true);
                        return;
                    }
                }
                // No one is waiting, dispatch the command to the node itself
                try {
                    await node.handleCommand(msg.command);
                    await reply(true);
                }
                catch (e) {
                    await reply(false);
                    // We only caught the error to be able to respond to supervised requests.
                    // Re-Throw so it can be handled accordingly
                    throw e;
                }
            }
            return;
        }
        else if (msg instanceof ApplicationUpdateRequest_1.ApplicationUpdateRequest) {
            // Make sure we're ready to handle this command
            this.ensureReady(true);
            return this.controller.handleApplicationUpdateRequest(msg);
        }
        else {
            // TODO: This deserves a nicer formatting
            this.driverLog.print(`handling request ${serial_1.FunctionType[msg.functionType]} (${msg.functionType})`);
            handlers = this.requestHandlers.get(msg.functionType);
        }
        if (handlers != undefined && handlers.length > 0) {
            this.driverLog.print(`  ${handlers.length} handler${handlers.length !== 1 ? "s" : ""} registered!`);
            // loop through all handlers and find the first one that returns true to indicate that it handled the message
            for (let i = 0; i < handlers.length; i++) {
                this.driverLog.print(`  invoking handler #${i}`);
                // Invoke the handler and remember its result
                const handler = handlers[i];
                let handlerResult = handler.invoke(msg);
                if (handlerResult instanceof Promise) {
                    handlerResult = await handlerResult;
                }
                if (handlerResult) {
                    this.driverLog.print(`    the message was handled`);
                    if (handler.oneTime) {
                        this.driverLog.print("  one-time handler was successfully called, removing it...");
                        handlers.splice(i, 1);
                    }
                    // don't invoke any more handlers
                    break;
                }
            }
        }
        else {
            this.driverLog.print("  no handlers registered!", "warn");
        }
    }
    /**
     * Returns the next callback ID. Callback IDs are used to correlate requests
     * to the controller/nodes with its response
     */
    getNextCallbackId = (0, shared_1.createWrappingCounter)(0xff);
    supervisionSessionIDs = new Map();
    /**
     * Returns the next session ID for Supervision CC
     */
    getNextSupervisionSessionId(nodeId) {
        if (!this.supervisionSessionIDs.has(nodeId)) {
            this.supervisionSessionIDs.set(nodeId, (0, shared_1.createWrappingCounter)(core_1.MAX_SUPERVISION_SESSION_ID, true));
        }
        return this.supervisionSessionIDs.get(nodeId)();
    }
    /**
     * Returns the next session ID for Transport Service CC
     */
    getNextTransportServiceSessionId = (0, shared_1.createWrappingCounter)(core_1.MAX_TRANSPORT_SERVICE_SESSION_ID, true);
    encapsulateCommands(cmd, options = {}) {
        // The encapsulation order (from outside to inside) is as follows:
        // 5. Any one of the following combinations:
        //   a. Security (S0 or S2) followed by transport service
        //   b. Transport Service
        //   c. Security (S0 or S2)
        //   d. CRC16
        // b and d are mutually exclusive, security is not
        // 4. Multi Channel
        // 3. Supervision
        // 2. Multi Command
        // 1. Encapsulated Command Class (payload), e.g. Basic Set
        // TODO: 2.
        // 3.
        if (cc_1.SupervisionCC.requiresEncapsulation(cmd)) {
            cmd = cc_1.SupervisionCC.encapsulate(this, cmd);
        }
        // 4.
        if (cc_1.MultiChannelCC.requiresEncapsulation(cmd)) {
            cmd = cc_1.MultiChannelCC.encapsulate(this, cmd);
        }
        // 5.
        if (cc_1.CRC16CC.requiresEncapsulation(cmd)) {
            cmd = cc_1.CRC16CC.encapsulate(this, cmd);
        }
        else {
            // The command must be S2-encapsulated, if ...
            let maybeS2 = false;
            const node = cmd.getNode(this);
            if (node?.supportsCC(core_1.CommandClasses["Security 2"])) {
                // ... the node supports S2 and has a valid security class
                const nodeSecClass = node.getHighestSecurityClass();
                maybeS2 = (0, core_1.securityClassIsS2)(nodeSecClass)
                    || !!this.securityManager2?.tempKeys.has(node.id);
            }
            else if (options.s2MulticastGroupId != undefined) {
                // ... or we're dealing with S2 multicast
                maybeS2 = true;
            }
            if (maybeS2 && cc_1.Security2CC.requiresEncapsulation(cmd)) {
                cmd = cc_1.Security2CC.encapsulate(this, cmd, {
                    securityClass: options.s2OverrideSecurityClass,
                    multicastOutOfSync: !!options.s2MulticastOutOfSync,
                    multicastGroupId: options.s2MulticastGroupId,
                    verifyDelivery: options.s2VerifyDelivery,
                });
            }
            // This check will return false for S2-encapsulated commands
            if (cc_1.SecurityCC.requiresEncapsulation(cmd)) {
                cmd = cc_1.SecurityCC.encapsulate(this, cmd);
            }
        }
        return cmd;
    }
    unwrapCommands(msg) {
        // Unwrap encapsulating CCs until we get to the core
        while ((0, cc_1.isEncapsulatingCommandClass)(msg.command)
            || (0, cc_1.isMultiEncapsulatingCommandClass)(msg.command)) {
            const unwrapped = msg.command.encapsulated;
            if ((0, typeguards_1.isArray)(unwrapped)) {
                // Multi Command CC cannot be further unwrapped
                return;
            }
            // Copy the encapsulation flags and add the current encapsulation
            unwrapped.encapsulationFlags = msg.command.encapsulationFlags;
            switch (msg.command.ccId) {
                case core_1.CommandClasses.Supervision:
                    unwrapped.toggleEncapsulationFlag(core_1.EncapsulationFlags.Supervision, true);
                    break;
                case core_1.CommandClasses["Security 2"]:
                case core_1.CommandClasses.Security:
                    unwrapped.toggleEncapsulationFlag(core_1.EncapsulationFlags.Security, true);
                    break;
                case core_1.CommandClasses["CRC-16 Encapsulation"]:
                    unwrapped.toggleEncapsulationFlag(core_1.EncapsulationFlags.CRC16, true);
                    break;
            }
            msg.command = unwrapped;
        }
    }
    /** Persists the values contained in a Command Class in the corresponding nodes's value DB */
    persistCCValues(cc) {
        cc.persistValues(this);
        if ((0, cc_1.isEncapsulatingCommandClass)(cc)) {
            this.persistCCValues(cc.encapsulated);
        }
        else if ((0, cc_1.isMultiEncapsulatingCommandClass)(cc)) {
            for (const encapsulated of cc.encapsulated) {
                this.persistCCValues(encapsulated);
            }
        }
    }
    /**
     * Gets called whenever any Serial API command succeeded or a SendData command had a negative callback.
     */
    handleSerialAPICommandResult(msg, options, result) {
        // Update statistics
        const node = this.getNodeUnsafe(msg);
        let success = true;
        if ((0, SendDataShared_1.isSendData)(msg) || (0, serial_1.isNodeQuery)(msg)) {
            // This shouldn't happen, but just in case
            if (!node)
                return;
            // If this is a transmit report, use it to update statistics
            if ((0, SendDataShared_1.isTransmitReport)(result)) {
                if (!result.isOK()) {
                    success = false;
                    node.incrementStatistics("commandsDroppedTX");
                }
                else {
                    node.incrementStatistics("commandsTX");
                    node.updateRTT(msg);
                    // Update last seen state
                    node.lastSeen = new Date();
                }
                // Notify listeners about the status report if one was received
                if ((0, SendDataShared_1.hasTXReport)(result)) {
                    options.onTXReport?.(result.txReport);
                    node.updateRouteStatistics(result.txReport);
                }
            }
            // Track and potentially update the status of the node when communication succeeds
            if (success) {
                if (node.canSleep) {
                    // Do not update the node status when we only responded to a nonce/supervision request
                    if (options.priority !== core_1.MessagePriority.Immediate) {
                        // If the node is not meant to be kept awake, try to send it back to sleep
                        if (!node.keepAwake) {
                            setImmediate(() => this.debounceSendNodeToSleep(node));
                        }
                        // The node must be awake because it answered
                        node.markAsAwake();
                    }
                }
                else if (node.status !== _Types_1.NodeStatus.Alive) {
                    // The node status was unknown or dead - in either case it must be alive because it answered
                    node.markAsAlive();
                }
            }
        }
        else {
            this._controller?.incrementStatistics("messagesTX");
        }
    }
    shouldUseLowPriorityForSupervisionReport(targetNode, encapsulationFlags) {
        // To avoid S2 collisions, we reduce the priority of Supervision reports
        // when they are S2-encapsulated, and another S2-encapsulated transaction is in
        // progress for the same node
        // Use Immediate priority if there is no other transaction for this node in progress
        const currentNormalMsg = this.queue.currentTransaction?.message;
        if (currentNormalMsg?.getNodeId() !== targetNode.id) {
            return false;
        }
        if (!(0, cc_1.isCommandClassContainer)(currentNormalMsg)) {
            return false;
        }
        // Use Immediate priority if the node isn't using Security S2
        if (!(0, core_1.securityClassIsS2)(targetNode.getHighestSecurityClass())) {
            return false;
        }
        // Use Immediate priority unless both messages are S2-encapsulated
        const currentMsgIsSecure = currentNormalMsg.command
            instanceof cc_1.Security2CCMessageEncapsulation;
        const reportIsSecure = !!(encapsulationFlags & core_1.EncapsulationFlags.Security);
        if (!currentMsgIsSecure || !reportIsSecure) {
            return false;
        }
        // This has potential for a conflict, use low priority
        this.controllerLog.logNode(targetNode.id, {
            message: "S2 collision detected, reducing priority for Supervision report",
            level: "debug",
        });
        return true;
    }
    mayStartTransaction(transaction) {
        // We may not send anything on the normal queue if the send thread is paused
        // or the controller is unresponsive
        if (this.queuePaused
            || this.controller.status === core_1.ControllerStatus.Unresponsive) {
            return false;
        }
        const message = transaction.message;
        const targetNode = message.getNodeUnsafe(this);
        // Messages to the controller may always be sent...
        if (!targetNode)
            return true;
        // The transaction queue is sorted automatically. If the first message is for a sleeping node, all messages in the queue are.
        // There are a few exceptions:
        // 1. Pings may be used to determine whether a node is really asleep.
        // 2. Responses to nonce requests must be sent independent of the node status, because some sleeping nodes may try to send us encrypted messages.
        //    If we don't send them, they block the send queue
        // 3. Nodes that can sleep but do not support wakeup: https://github.com/zwave-js/node-zwave-js/discussions/1537
        //    We need to try and send messages to them even if they are asleep, because we might never hear from them
        // 2. is handled by putting the message into the immediate queue
        // Pings may always be sent
        if ((0, cc_1.messageIsPing)(message))
            return true;
        return (targetNode.status !== _Types_1.NodeStatus.Asleep
            || (!targetNode.supportsCC(core_1.CommandClasses["Wake Up"])
                && targetNode.interviewStage >= _Types_1.InterviewStage.NodeInfo));
    }
    markQueueBusy(queue, busy) {
        const index = this.queues.indexOf(queue);
        if (busy) {
            this._queuesBusyFlags |= 1 << index;
        }
        else {
            this._queuesBusyFlags &= ~(1 << index);
        }
        this.queueIdle = this._queuesBusyFlags === 0;
    }
    async drainTransactionQueue(queue) {
        let setIdleTimer;
        for await (const transaction of queue) {
            if (setIdleTimer) {
                clearImmediate(setIdleTimer);
                setIdleTimer = undefined;
            }
            this.markQueueBusy(queue, true);
            let error;
            try {
                await this.executeTransaction(transaction);
            }
            catch (e) {
                error = e;
            }
            finally {
                queue.finalizeTransaction();
            }
            // Handle errors after clearing the current transaction.
            // Otherwise, it will get considered the active transaction and cause an unnecessary SendDataAbort
            if (error) {
                this.handleFailedTransaction(transaction, error);
            }
            setIdleTimer = setImmediate(() => {
                this.markQueueBusy(queue, false);
            });
        }
    }
    /** Steps through the message generator of a transaction. Throws an error if the transaction should fail. */
    async executeTransaction(transaction) {
        let prevResult;
        let msg;
        transaction.start();
        transaction.setProgress({ state: core_1.TransactionState.Active });
        // Step through the transaction as long as it gives us a next message
        while ((msg = await transaction.generateNextMessage(prevResult))) {
            // Keep track of how often the controller failed to send a command, to prevent ending up in an infinite loop
            let jammedAttempts = 0;
            attemptMessage: for (let attemptNumber = 1;; attemptNumber++) {
                try {
                    prevResult = await this.queueSerialAPICommand(msg, transaction.stack);
                    if ((0, SendDataShared_1.isTransmitReport)(prevResult)) {
                        // Figure out if the controller is jammed. If it is, wait a second and try again.
                        // https://github.com/zwave-js/node-zwave-js/issues/6199
                        // In some cases, the transmit status can be Fail, even after transmitting for a couple of seconds.
                        // Not sure what causes this, but it doesn't mean that the controller is jammed.
                        if (prevResult.transmitStatus === core_1.TransmitStatus.Fail
                            && "txReport" in prevResult
                            // Ensure the controller didn't actually transmit
                            && prevResult.txReport?.txTicks === 0) {
                            jammedAttempts++;
                            if (jammedAttempts
                                < this.options.attempts.sendDataJammed) {
                                // The controller is jammed. Wait a bit, then try again.
                                this.controller.setStatus(core_1.ControllerStatus.Jammed);
                                await (0, async_1.wait)(this.options.timeouts.retryJammed, true);
                                continue attemptMessage;
                            }
                            else {
                                // Maybe this isn't actually the controller being jammed. Give up on this command.
                                this.controller.setStatus(core_1.ControllerStatus.Ready);
                                throw new core_1.ZWaveError(`Failed to send the command after ${jammedAttempts} attempts`, core_1.ZWaveErrorCodes.Controller_MessageDropped, prevResult, transaction.stack);
                            }
                        }
                        if (this.controller.status === core_1.ControllerStatus.Jammed) {
                            // A command could be sent, so the controller is no longer jammed
                            this.controller.setStatus(core_1.ControllerStatus.Ready);
                        }
                        if (!prevResult.isOK()) {
                            throw new core_1.ZWaveError("The node did not acknowledge the command", core_1.ZWaveErrorCodes.Controller_CallbackNOK, prevResult, transaction.stack);
                        }
                    }
                    // We got a result - it will be passed to the next iteration
                    break attemptMessage;
                }
                catch (e) {
                    let zwError;
                    if (!(0, core_1.isZWaveError)(e)) {
                        zwError = (0, StateMachineShared_1.createMessageDroppedUnexpectedError)(e);
                    }
                    else {
                        if ((0, SendDataShared_1.isSendData)(msg) && (0, core_1.isMissingControllerCallback)(e)) {
                            // The controller is unresponsive. Reject the transaction, so we can attempt to recover
                            throw e;
                        }
                        else if ((0, core_1.isMissingControllerACK)(e)) {
                            // The controller is unresponsive. Reject the transaction, so we can attempt to recover
                            throw e;
                        }
                        else if (e.code === core_1.ZWaveErrorCodes.Controller_MessageDropped) {
                            // We gave up on this command, so don't retry it
                            throw e;
                        }
                        if (this.mayRetrySerialAPICommand(msg, 
                        // Ignore the number of attempts while jammed
                        attemptNumber - jammedAttempts, e)) {
                            // Retry the command
                            continue attemptMessage;
                        }
                        zwError = e;
                    }
                    // Sending the command failed, reject the transaction
                    throw zwError;
                }
            }
        }
        // This transaction completed successfully, try the next one
        transaction.setProgress({ state: core_1.TransactionState.Completed });
    }
    /** Handles sequencing of queued Serial API commands */
    async drainSerialAPIQueue() {
        for await (const item of this.serialAPIQueue) {
            const { msg, transactionSource, result } = item;
            try {
                const ret = await this.executeSerialAPICommand(msg, transactionSource);
                result.resolve(ret);
            }
            catch (e) {
                result.reject(e);
            }
        }
    }
    triggerQueues() {
        for (const queue of this.queues) {
            queue.trigger();
        }
    }
    /** Puts a message on the serial API queue and returns or throws the command result */
    queueSerialAPICommand(msg, transactionSource) {
        const result = (0, deferred_promise_1.createDeferredPromise)();
        this.serialAPIQueue.add({
            msg,
            transactionSource,
            result,
        });
        return result;
    }
    mayRetrySerialAPICommand(msg, attemptNumber, error) {
        // Only retry Send Data, nothing else
        if (!(0, SendDataShared_1.isSendData)(msg))
            return false;
        // Don't try to resend SendData commands when the response times out
        if (error.code === core_1.ZWaveErrorCodes.Controller_Timeout
            && error.context === "response") {
            return false;
        }
        // Don't try to resend multicast messages if they were already transmitted.
        // One or more nodes might have already reacted
        if ((msg instanceof SendDataMessages_1.SendDataMulticastRequest
            || msg instanceof SendDataBridgeMessages_1.SendDataMulticastBridgeRequest)
            && error.code === core_1.ZWaveErrorCodes.Controller_CallbackNOK) {
            return false;
        }
        return attemptNumber < msg.maxSendAttempts;
    }
    /**
     * Executes a Serial API command and returns or throws the result.
     * This method should not be called outside of {@link drainSerialAPIQueue}.
     */
    async executeSerialAPICommand(msg, transactionSource) {
        const machine = (0, SerialAPICommandMachine_1.createSerialAPICommandMachine)(msg, {
            sendData: (data) => this.writeSerial(data),
            sendDataAbort: () => this.abortSendData(),
            notifyUnsolicited: (msg) => {
                void this.handleUnsolicitedMessage(msg);
            },
            notifyRetry: (lastError, message, attempts, maxAttempts, delay) => {
                // Translate the error into a better one
                let errorReason;
                switch (lastError) {
                    case "response timeout":
                        errorReason = "No response from controller";
                        this._controller?.incrementStatistics("timeoutResponse");
                        break;
                    case "callback timeout":
                        errorReason = "No callback from controller";
                        this._controller?.incrementStatistics("timeoutCallback");
                        break;
                    case "response NOK":
                        errorReason =
                            "The controller response indicated failure";
                        break;
                    case "callback NOK":
                        errorReason =
                            "The controller callback indicated failure";
                        break;
                    case "ACK timeout":
                        this._controller?.incrementStatistics("timeoutACK");
                    // fall through
                    case "CAN":
                    case "NAK":
                    default:
                        errorReason =
                            "Failed to execute controller command";
                        break;
                }
                this.controllerLog.print(`${errorReason} after ${attempts}/${maxAttempts} attempts. Scheduling next try in ${delay} ms.`, "warn");
            },
            timestamp: core_1.highResTimestamp,
            logOutgoingMessage: (msg) => {
                this.driverLog.logMessage(msg, {
                    direction: "outbound",
                });
            },
        }, (0, shared_1.pick)(this._options, ["timeouts", "attempts"]));
        const result = (0, deferred_promise_1.createDeferredPromise)();
        // Work around an issue in the 700 series firmware where the ACK after a soft-reset has a random high nibble.
        // This was broken in 7.19, not fixed so far
        if (msg.functionType === serial_1.FunctionType.SoftReset
            && this.controller.sdkVersionGte("7.19.0")) {
            this.serial?.ignoreAckHighNibbleOnce();
        }
        this.serialAPIInterpreter = (0, xstate_1.interpret)(machine).onDone((evt) => {
            this.serialAPIInterpreter?.stop();
            this.serialAPIInterpreter = undefined;
            const cmdResult = evt.data;
            if (cmdResult.type === "success") {
                result.resolve(cmdResult.result);
            }
            else if (cmdResult.reason === "callback NOK"
                && ((0, SendDataShared_1.isSendData)(msg) || (0, SendDataShared_1.isTransmitReport)(cmdResult.result))) {
                // For messages that were sent to a node, a NOK callback still contains useful info we need to evaluate
                // ... so we treat it as a result
                result.resolve(cmdResult.result);
            }
            else {
                // Convert to a Z-Wave error
                result.reject((0, StateMachineShared_1.serialAPICommandErrorToZWaveError)(cmdResult.reason, msg, cmdResult.result, transactionSource));
            }
        });
        // Uncomment this for debugging state machine transitions
        // this.serialAPIInterpreter.onTransition((state) => {
        // 	if (state.changed) {
        // 		this.driverLog.print(
        // 			`CMDMACHINE: ${JSON.stringify(state.toStrings())}`,
        // 		);
        // 	}
        // });
        this.serialAPIInterpreter.start();
        return result;
    }
    getQueueForTransaction(t) {
        if (t.priority === core_1.MessagePriority.Immediate
            || t.priority === core_1.MessagePriority.ControllerImmediate) {
            return this.immediateQueue;
        }
        else {
            return this.queue;
        }
    }
    /**
     * Sends a message to the Z-Wave stick.
     * @param msg The message to send
     * @param options (optional) Options regarding the message transmission
     */
    async sendMessage(msg, options = {}) {
        this.ensureReady();
        let node;
        // Don't send messages to dead nodes
        if ((0, serial_1.isNodeQuery)(msg) || (0, cc_1.isCommandClassContainer)(msg)) {
            node = this.getNodeUnsafe(msg);
            if (!(0, cc_1.messageIsPing)(msg) && node?.status === _Types_1.NodeStatus.Dead) {
                // Instead of throwing immediately, try to ping the node first - if it responds, continue
                if (!(await node.ping())) {
                    throw new core_1.ZWaveError(`The message cannot be sent because node ${node.id} is dead`, core_1.ZWaveErrorCodes.Controller_MessageDropped);
                }
            }
        }
        if (options.priority == undefined) {
            options.priority = (0, serial_1.getDefaultPriority)(msg);
        }
        if (options.priority == undefined) {
            const className = msg.constructor.name;
            const msgTypeName = serial_1.FunctionType[msg.functionType];
            throw new core_1.ZWaveError(`No default priority has been defined for ${className} (${msgTypeName}), so you have to provide one for your message`, core_1.ZWaveErrorCodes.Driver_NoPriority);
        }
        if (options.supportCheck == undefined)
            options.supportCheck = true;
        if (options.supportCheck
            && this._controller != undefined
            && !this._controller.isFunctionSupported(msg.functionType)) {
            throw new core_1.ZWaveError(`Your hardware does not support the ${serial_1.FunctionType[msg.functionType]} function`, core_1.ZWaveErrorCodes.Driver_NotSupported);
        }
        // When sending a message to a node that is known to be sleeping,
        // the priority must be WakeUp, so the message gets deprioritized
        // in comparison with messages to awake nodes.
        // However there are a few exceptions...
        if (!!node
            // Pings can be used to check if a node is really asleep, so they should be sent regardless
            && !(0, cc_1.messageIsPing)(msg)
            // Nodes that can sleep and support the Wake Up CC should have their messages queued for wakeup
            && node.canSleep
            && (node.supportsCC(core_1.CommandClasses["Wake Up"])
                // If we don't know the Wake Up support yet, also change the priority or RequestNodeInfoRequests will get stuck
                // in front of the queue
                || node.interviewStage < _Types_1.InterviewStage.NodeInfo)
            // If we move multicasts to the wakeup queue, it is unlikely
            // that there is ever a points where all targets are awake
            && !(msg instanceof SendDataMessages_1.SendDataMulticastRequest)
            && !(msg instanceof SendDataBridgeMessages_1.SendDataMulticastBridgeRequest)
            // Nonces and responses to Supervision Get have to be sent immediately
            && options.priority !== core_1.MessagePriority.Immediate) {
            if (options.priority === core_1.MessagePriority.NodeQuery) {
                // Remember that this transaction was part of an interview
                options.tag = "interview";
            }
            options.priority = core_1.MessagePriority.WakeUp;
        }
        // Create the transaction
        const { generator, resultPromise } = (0, MessageGenerators_1.createMessageGenerator)(this, msg, (msg, _result) => {
            this.handleSerialAPICommandResult(msg, options, _result);
        });
        const transaction = new Transaction_1.Transaction(this, {
            message: msg,
            priority: options.priority,
            parts: generator,
            promise: resultPromise,
            listener: options.onProgress,
        });
        // Configure its options
        if (options.changeNodeStatusOnMissingACK != undefined) {
            transaction.changeNodeStatusOnTimeout =
                options.changeNodeStatusOnMissingACK;
        }
        if (options.pauseSendThread === true) {
            transaction.pauseSendThread = true;
        }
        transaction.requestWakeUpOnDemand = !!options.requestWakeUpOnDemand;
        transaction.tag = options.tag;
        // And queue it
        this.getQueueForTransaction(transaction).add(transaction);
        transaction.setProgress({ state: core_1.TransactionState.Queued });
        // If the transaction should expire, start the timeout
        let expirationTimeout;
        if (options.expire) {
            expirationTimeout = setTimeout(() => {
                this.reduceQueues((t, _source) => {
                    if (t === transaction) {
                        return {
                            type: "reject",
                            message: `The message has expired`,
                            code: core_1.ZWaveErrorCodes.Controller_MessageExpired,
                        };
                    }
                    return { type: "keep" };
                });
            }, options.expire).unref();
        }
        try {
            const result = (await resultPromise);
            // If this was a successful non-nonce message to a sleeping node, make sure it goes to sleep again
            let maybeSendToSleep;
            if ((0, SendDataShared_1.isSendData)(msg)) {
                // For SendData messages, make sure the message is not a nonce
                maybeSendToSleep =
                    options.priority !== core_1.MessagePriority.Immediate
                        // And that the result is either a response from the node
                        // or a transmit report indicating success
                        && result
                        && (result.functionType
                            === serial_1.FunctionType.BridgeApplicationCommand
                            || result.functionType
                                === serial_1.FunctionType.ApplicationCommand
                            || ((0, SendDataShared_1.isSendDataTransmitReport)(result) && result.isOK()));
            }
            else {
                // For other messages to the node, just check for successful completion. If the callback is not OK,
                // we might not be able to communicate with the node. Sending another message is not a good idea.
                maybeSendToSleep = (0, serial_1.isNodeQuery)(msg)
                    && result
                    && (0, serial_1.isSuccessIndicator)(result)
                    && result.isOK();
            }
            if (maybeSendToSleep && node && node.canSleep && !node.keepAwake) {
                setImmediate(() => this.debounceSendNodeToSleep(node));
            }
            // Set the transaction progress to completed before resolving the Promise
            transaction.setProgress({ state: core_1.TransactionState.Completed });
            return result;
        }
        catch (e) {
            if ((0, core_1.isZWaveError)(e)) {
                if (
                // If a controller command failed (that is not SendData), pass the response/callback through
                (e.code === core_1.ZWaveErrorCodes.Controller_ResponseNOK
                    || e.code === core_1.ZWaveErrorCodes.Controller_CallbackNOK)
                    && e.context instanceof serial_1.Message
                    // We need to check the function type here because context can be the transmit reports
                    && e.context.functionType !== serial_1.FunctionType.SendData
                    && e.context.functionType !== serial_1.FunctionType.SendDataMulticast
                    && e.context.functionType !== serial_1.FunctionType.SendDataBridge
                    && e.context.functionType
                        !== serial_1.FunctionType.SendDataMulticastBridge) {
                    this._controller?.incrementStatistics("messagesDroppedTX");
                    return e.context;
                }
                else if (e.code === core_1.ZWaveErrorCodes.Controller_NodeTimeout) {
                    // If the node failed to respond in time, remember this for the statistics
                    node?.incrementStatistics("timeoutResponse");
                }
                // Enrich errors with the transaction's stack instead of the internal stack
                if (!e.transactionSource) {
                    throw new core_1.ZWaveError(e.message, e.code, e.context, transaction.stack);
                }
            }
            throw e;
        }
        finally {
            // The transaction was handled, so it can no longer expire
            if (expirationTimeout)
                clearTimeout(expirationTimeout);
        }
    }
    /** Wraps a CC in the correct SendData message to use for sending */
    createSendDataMessage(command, options = {}) {
        // Automatically encapsulate commands before sending
        if (options.autoEncapsulate !== false) {
            command = this.encapsulateCommands(command, options);
        }
        let msg;
        if (command.isSinglecast() || command.isBroadcast()) {
            if (this.controller.isFunctionSupported(serial_1.FunctionType.SendDataBridge)) {
                // Prioritize Bridge commands when they are supported
                msg = new SendDataBridgeMessages_1.SendDataBridgeRequest(this, {
                    command,
                    maxSendAttempts: this._options.attempts.sendData,
                });
            }
            else {
                msg = new SendDataMessages_1.SendDataRequest(this, {
                    command,
                    maxSendAttempts: this._options.attempts.sendData,
                });
            }
        }
        else if (command.isMulticast()) {
            if (this.controller.isFunctionSupported(serial_1.FunctionType.SendDataMulticastBridge)) {
                // Prioritize Bridge commands when they are supported
                msg = new SendDataBridgeMessages_1.SendDataMulticastBridgeRequest(this, {
                    command,
                    maxSendAttempts: this._options.attempts.sendData,
                });
            }
            else {
                msg = new SendDataMessages_1.SendDataMulticastRequest(this, {
                    command,
                    maxSendAttempts: this._options.attempts.sendData,
                });
            }
        }
        else {
            throw new core_1.ZWaveError(`A CC must either be singlecast or multicast`, core_1.ZWaveErrorCodes.Argument_Invalid);
        }
        // Specify the number of send attempts for the request
        if (options.maxSendAttempts != undefined) {
            msg.maxSendAttempts = options.maxSendAttempts;
        }
        // Specify transmit options for the request
        if (options.transmitOptions != undefined) {
            msg.transmitOptions = options.transmitOptions;
            if (!(options.transmitOptions & core_1.TransmitOptions.ACK)) {
                // If no ACK is requested, set the callback ID to zero, because we won't get a controller callback
                msg.callbackId = 0;
            }
        }
        if (!!options.reportTimeoutMs) {
            msg.nodeUpdateTimeout = options.reportTimeoutMs;
        }
        return msg;
    }
    /**
     * Sends a command to a Z-Wave node. If the node returns a command in response, that command will be the return value.
     * If the command expects no response **or** the response times out, nothing will be returned
     * @param command The command to send. It will be encapsulated in a SendData[Multicast]Request.
     * @param options (optional) Options regarding the message transmission
     */
    async sendCommandInternal(command, options = {}) {
        const msg = this.createSendDataMessage(command, options);
        try {
            const resp = await this.sendMessage(msg, options);
            // And unwrap the response if there was any
            if ((0, cc_1.isCommandClassContainer)(resp)) {
                this.unwrapCommands(resp);
                return resp.command;
            }
        }
        catch (e) {
            // A timeout always has to be expected. In this case return nothing.
            if ((0, core_1.isZWaveError)(e)
                && e.code === core_1.ZWaveErrorCodes.Controller_NodeTimeout) {
                if (command.isSinglecast()) {
                    this.controllerLog.logNode(command.nodeId, e.message, "warn");
                }
            }
            else {
                // We don't want to swallow any other errors
                throw e;
            }
        }
    }
    /**
     * Sends a supervised command to a Z-Wave node. When status updates are requested, the passed callback will be executed for every non-final update.
     * @param command The command to send
     * @param options (optional) Options regarding the message transmission
     */
    async sendSupervisedCommand(command, options = {
        requestStatusUpdates: false,
    }) {
        // Create the encapsulating CC so we have a session ID
        command = cc_1.SupervisionCC.encapsulate(this, command, options.requestStatusUpdates);
        const resp = await this.sendCommandInternal(command, options);
        if (!resp)
            return;
        // If future updates are expected, listen for them
        if (options.requestStatusUpdates && resp.moreUpdatesFollow) {
            this.ensureNodeSessions(command.nodeId).supervision.set(command.sessionId, options.onUpdate);
        }
        // In any case, return the status
        return resp.toSupervisionResult();
    }
    /**
     * Sends a command to a Z-Wave node. The return value depends on several factors:
     * * If the node returns a command in response, that command will be the return value.
     * * If the command is a SET-type command and Supervision CC can and should be used, a {@link SupervisionResult} will be returned.
     * * If the command expects no response **or** the response times out, nothing will be returned.
     *
     * @param command The command to send. It will be encapsulated in a SendData[Multicast]Request.
     * @param options (optional) Options regarding the message transmission
     */
    async sendCommand(command, options) {
        if (options?.encapsulationFlags != undefined) {
            command.encapsulationFlags = options.encapsulationFlags;
        }
        // For S2 multicast, the Security encapsulation flag does not get set automatically by the CC constructor
        if (options?.s2MulticastGroupId != undefined) {
            command.toggleEncapsulationFlag(core_1.EncapsulationFlags.Security, true);
        }
        // Only use supervision if...
        if (
        // ... not disabled
        options?.useSupervision !== false
            // ... and it is legal for the command
            && cc_1.SupervisionCC.mayUseSupervision(this, command)) {
            const result = await this.sendSupervisedCommand(command, options);
            if (result?.status !== core_1.SupervisionStatus.NoSupport) {
                // @ts-expect-error TS doesn't know we've narrowed the return type to match
                return result;
            }
            // The node should support supervision but it doesn't for this command. Remember this
            cc_1.SupervisionCC.setCCSupportedWithSupervision(this, command.getEndpoint(this), command.ccId, false);
            // And retry the command without supervision
        }
        // Fall back to non-supervised commands
        // @ts-expect-error TS doesn't know we've narrowed the return type to match
        return this.sendCommandInternal(command, options);
    }
    /** @internal */
    async sendZWaveProtocolCC(command, options = {}) {
        await this.sendCommandInternal(command, {
            priority: core_1.MessagePriority.Controller,
            // No shenanigans, just send the raw command
            autoEncapsulate: false,
            useSupervision: false,
            changeNodeStatusOnMissingACK: options.changeNodeStatusOnMissingACK
                ?? false,
            maxSendAttempts: options.maxSendAttempts || 1,
            transmitOptions: core_1.TransmitOptions.AutoRoute | core_1.TransmitOptions.ACK,
        });
    }
    async abortSendData() {
        try {
            const abort = new SendDataMessages_1.SendDataAbort(this);
            await this.writeSerial(abort.serialize());
            this.driverLog.logMessage(abort, {
                direction: "outbound",
            });
            // We're bypassing the serial API machine, so we need to wait for the ACK ourselves
            // This could also cause a NAK or CAN, but we don't really care
            await this.waitForMessageHeader(() => true, 500).catch(shared_1.noop);
        }
        catch {
            // ignore
        }
    }
    /**
     * Sends a low-level message like ACK, NAK or CAN immediately
     * @param header The low-level message to send
     */
    writeHeader(header) {
        // ACK, CAN, NAK
        return this.writeSerial(Buffer.from([header]));
    }
    /** Sends a raw datagram to the serialport (if that is open) */
    async writeSerial(data) {
        return this.serial?.writeAsync(data);
    }
    /**
     * Waits until a matching message header is received or a timeout has elapsed. Returns the received message.
     *
     * @param timeout The number of milliseconds to wait. If the timeout elapses, the returned promise will be rejected
     * @param predicate A predicate function to test all incoming message headers.
     */
    waitForMessageHeader(predicate, timeout) {
        return new Promise((resolve, reject) => {
            const promise = (0, deferred_promise_1.createDeferredPromise)();
            const entry = {
                predicate,
                handler: (msg) => promise.resolve(msg),
                timeout: undefined,
            };
            this.awaitedMessageHeaders.push(entry);
            const removeEntry = () => {
                if (entry.timeout)
                    clearTimeout(entry.timeout);
                const index = this.awaitedMessageHeaders.indexOf(entry);
                if (index !== -1)
                    this.awaitedMessageHeaders.splice(index, 1);
            };
            // When the timeout elapses, remove the wait entry and reject the returned Promise
            entry.timeout = setTimeout(() => {
                removeEntry();
                reject(new core_1.ZWaveError(`Received no matching serial frame within the provided timeout!`, core_1.ZWaveErrorCodes.Controller_Timeout));
            }, timeout);
            // When the promise is resolved, remove the wait entry and resolve the returned Promise
            void promise.then((cc) => {
                removeEntry();
                resolve(cc);
            });
        });
    }
    /**
     * Waits until an unsolicited serial message is received or a timeout has elapsed. Returns the received message.
     *
     * **Note:** To wait for a certain CommandClass, better use {@link waitForCommand}.
     * @param timeout The number of milliseconds to wait. If the timeout elapses, the returned promise will be rejected
     * @param predicate A predicate function to test all incoming messages.
     * @param refreshPredicate A predicate function to test partial messages. If this returns `true` for a message, the timer will be restarted.
     */
    waitForMessage(predicate, timeout, refreshPredicate) {
        return new Promise((resolve, reject) => {
            const promise = (0, deferred_promise_1.createDeferredPromise)();
            const entry = {
                predicate,
                refreshPredicate,
                handler: (msg) => promise.resolve(msg),
                timeout: undefined,
            };
            this.awaitedMessages.push(entry);
            const removeEntry = () => {
                if (entry.timeout)
                    clearTimeout(entry.timeout);
                const index = this.awaitedMessages.indexOf(entry);
                if (index !== -1)
                    this.awaitedMessages.splice(index, 1);
            };
            // When the timeout elapses, remove the wait entry and reject the returned Promise
            entry.timeout = setTimeout(() => {
                removeEntry();
                reject(new core_1.ZWaveError(`Received no matching message within the provided timeout!`, core_1.ZWaveErrorCodes.Controller_Timeout));
            }, timeout);
            // When the promise is resolved, remove the wait entry and resolve the returned Promise
            void promise.then((cc) => {
                removeEntry();
                resolve(cc);
            });
        });
    }
    /**
     * Waits until a CommandClass is received or a timeout has elapsed. Returns the received command.
     * @param timeout The number of milliseconds to wait. If the timeout elapses, the returned promise will be rejected
     * @param predicate A predicate function to test all incoming command classes
     */
    waitForCommand(predicate, timeout) {
        return new Promise((resolve, reject) => {
            const promise = (0, deferred_promise_1.createDeferredPromise)();
            const entry = {
                predicate,
                handler: (cc) => promise.resolve(cc),
                timeout: undefined,
            };
            this.awaitedCommands.push(entry);
            const removeEntry = () => {
                if (entry.timeout)
                    clearTimeout(entry.timeout);
                const index = this.awaitedCommands.indexOf(entry);
                if (index !== -1)
                    this.awaitedCommands.splice(index, 1);
            };
            // When the timeout elapses, remove the wait entry and reject the returned Promise
            entry.timeout = setTimeout(() => {
                removeEntry();
                reject(new core_1.ZWaveError(`Received no matching command within the provided timeout!`, core_1.ZWaveErrorCodes.Controller_NodeTimeout));
            }, timeout);
            // When the promise is resolved, remove the wait entry and resolve the returned Promise
            void promise.then((cc) => {
                removeEntry();
                resolve(cc);
            });
        });
    }
    /**
     * Calls the given handler function every time a CommandClass is received that matches the given predicate.
     * @param predicate A predicate function to test all incoming command classes
     */
    registerCommandHandler(predicate, handler) {
        const entry = {
            predicate,
            handler: (cc) => handler(cc),
            timeout: undefined,
        };
        this.awaitedCommands.push(entry);
        const removeEntry = () => {
            if (entry.timeout)
                clearTimeout(entry.timeout);
            const index = this.awaitedCommands.indexOf(entry);
            if (index !== -1)
                this.awaitedCommands.splice(index, 1);
        };
        return {
            unregister: removeEntry,
        };
    }
    handleFailedTransaction(transaction, error) {
        // If a node failed to respond in time, it might be sleeping
        if (this.isMissingNodeACK(transaction, error)) {
            if (this.handleMissingNodeACK(transaction, error))
                return;
        }
        else if ((0, core_1.isMissingControllerACK)(error)) {
            if (this.handleMissingControllerACK(transaction, error))
                return;
        }
        else if ((0, SendDataShared_1.isSendData)(transaction.message)
            && ((0, core_1.isMissingControllerResponse)(error)
                || (0, core_1.isMissingControllerCallback)(error))) {
            if (this.handleMissingSendDataResponseOrCallback(transaction, error))
                return;
        }
        this.rejectTransaction(transaction, error);
    }
    rejectTransaction(transaction, error) {
        transaction.setProgress({
            state: core_1.TransactionState.Failed,
            reason: error.message,
        });
        transaction.abort(error);
    }
    resolveTransaction(transaction, result) {
        transaction.abort(result);
    }
    /** Checks if a message is allowed to go into the wakeup queue */
    mayMoveToWakeupQueue(transaction) {
        const msg = transaction.message;
        switch (true) {
            // Pings, nonces and Supervision Reports will block the send queue until wakeup, so they must be dropped
            case (0, cc_1.messageIsPing)(msg):
            case transaction.priority === core_1.MessagePriority.Immediate:
            // We also don't want to immediately send the node to sleep when it wakes up
            case (0, cc_1.isCommandClassContainer)(msg)
                && msg.command instanceof cc_1.WakeUpCCNoMoreInformation:
            // compat queries because they will be recreated when the node wakes up
            case transaction.tag === "compat":
                return false;
        }
        return true;
    }
    /** Moves all messages for a given node into the wakeup queue */
    moveMessagesToWakeupQueue(nodeId) {
        const reject = {
            type: "reject",
            message: `The node is asleep`,
            code: core_1.ZWaveErrorCodes.Controller_MessageDropped,
        };
        const requeue = {
            type: "requeue",
            priority: core_1.MessagePriority.WakeUp,
            // Reset the transaction so it doesn't simply resolve to `undefined` when we attempt to continue it
            reset: true,
        };
        const requeueAndTagAsInterview = {
            ...requeue,
            tag: "interview",
        };
        this.reduceQueues((transaction, _source) => {
            const msg = transaction.message;
            if (msg.getNodeId() !== nodeId)
                return { type: "keep" };
            // Drop all messages that are not allowed in the wakeup queue
            // For all other messages, change the priority to wakeup
            return this.mayMoveToWakeupQueue(transaction)
                ? transaction.priority === core_1.MessagePriority.NodeQuery
                    ? requeueAndTagAsInterview
                    : requeue
                : reject;
        });
    }
    /**
     * @internal
     * Rejects all pending transactions that match a predicate and removes them from the send queue
     */
    rejectTransactions(predicate, errorMsg = `The message has been removed from the queue`, errorCode = core_1.ZWaveErrorCodes.Controller_MessageDropped) {
        this.reduceQueues((transaction, _source) => {
            if (predicate(transaction)) {
                return {
                    type: "reject",
                    message: errorMsg,
                    code: errorCode,
                };
            }
            else {
                return { type: "keep" };
            }
        });
    }
    /**
     * @internal
     * Rejects all pending transactions for a node and removes them from the send queue
     */
    rejectAllTransactionsForNode(nodeId, errorMsg = `The node is dead`, errorCode = core_1.ZWaveErrorCodes.Controller_MessageDropped) {
        this.rejectTransactions((t) => t.message.getNodeId() === nodeId, errorMsg, errorCode);
    }
    /**
     * Pauses the send queue, avoiding commands to be sent to the controller
     */
    pauseSendQueue() {
        this.queuePaused = true;
    }
    /**
     * Unpauses the send queue, allowing commands to be sent to the controller again
     */
    unpauseSendQueue() {
        this.queuePaused = false;
        this.triggerQueues();
    }
    reduceQueues(reducer) {
        for (const queue of this.queues) {
            this.reduceQueue(queue, reducer);
        }
    }
    reduceQueue(queue, reducer) {
        const dropQueued = [];
        let stopActive;
        const requeue = [];
        const reduceTransaction = (transaction, source) => {
            const reducerResult = reducer(transaction, source);
            switch (reducerResult.type) {
                case "drop":
                    if (source === "queue") {
                        dropQueued.push(transaction);
                        // This will silently drop the transaction, so awaiting it will never resolve.
                        // At least notify the listeners about it.
                        transaction.setProgress({
                            state: core_1.TransactionState.Failed,
                            reason: "The message was dropped",
                        });
                    }
                    else {
                        stopActive = transaction;
                    }
                    break;
                case "requeue":
                    if (reducerResult.priority != undefined) {
                        transaction.priority = reducerResult.priority;
                    }
                    if (reducerResult.tag != undefined) {
                        transaction.tag = reducerResult.tag;
                    }
                    if (reducerResult.reset) {
                        transaction.reset();
                    }
                    if (source === "active")
                        stopActive = transaction;
                    requeue.push(transaction);
                    break;
                case "resolve":
                    this.resolveTransaction(transaction, reducerResult.message);
                    if (source === "queue") {
                        dropQueued.push(transaction);
                    }
                    else {
                        stopActive = transaction;
                    }
                    break;
                case "reject":
                    this.rejectTransaction(transaction, new core_1.ZWaveError(reducerResult.message, reducerResult.code, undefined, transaction.stack));
                    if (source === "queue") {
                        dropQueued.push(transaction);
                    }
                    else {
                        stopActive = transaction;
                    }
                    break;
            }
        };
        for (const transaction of queue.transactions) {
            reduceTransaction(transaction, "queue");
        }
        if (queue.currentTransaction) {
            reduceTransaction(queue.currentTransaction, "active");
        }
        // Now we know what to do with the transactions
        queue.remove(...dropQueued, ...requeue);
        const requeued = requeue.map((t) => t.clone());
        queue.add(...requeued);
        // Notify listeners about re-queued transactions
        for (const t of requeued) {
            t.setProgress({ state: core_1.TransactionState.Queued });
        }
        // Abort ongoing SendData messages that should be dropped
        if ((0, SendDataShared_1.isSendData)(stopActive?.message)) {
            void this.abortSendData();
        }
    }
    /** @internal */
    resolvePendingPings(nodeId) {
        // When a previously sleeping node sends a NIF after a ping was sent to it, but not acknowledged yet,
        // the node is awake, but the ping would fail. Resolve pending pings, so communication can continue.
        for (const { currentTransaction } of this.queues) {
            if (!currentTransaction)
                continue;
            const msg = currentTransaction.parts.current;
            if (!!msg && (0, cc_1.messageIsPing)(msg) && msg.getNodeId() === nodeId) {
                // The pending transaction is a ping. Short-circuit its message generator by throwing something that's not an error
                currentTransaction.abort(undefined);
            }
        }
    }
    /**
     * @internal
     * Helper function to read and convert potentially existing values from the network cache
     */
    cacheGet(cacheKey, options) {
        let ret = this.networkCache.get(cacheKey);
        if (ret !== undefined && typeof options?.reviver === "function") {
            try {
                ret = options.reviver(ret);
            }
            catch {
                // ignore, invalid entry
            }
        }
        return ret;
    }
    /**
     * @internal
     * Helper function to convert values and write them to the network cache
     */
    cacheSet(cacheKey, value, options) {
        if (value !== undefined && typeof options?.serializer === "function") {
            value = options.serializer(value);
        }
        if (value === undefined) {
            this.networkCache.delete(cacheKey);
        }
        else {
            this.networkCache.set(cacheKey, value);
        }
    }
    cachePurge(prefix) {
        for (const key of this.networkCache.keys()) {
            if (key.startsWith(prefix)) {
                this.networkCache.delete(key);
            }
        }
    }
    /**
     * Restores a previously stored Z-Wave network state from cache to speed up the startup process
     */
    async restoreNetworkStructureFromCache() {
        if (!this._controller
            || !this.controller.homeId
            || !this._networkCache) {
            return;
        }
        if (this._networkCache.size <= 1) {
            // If the size is 0 or 1, the cache is empty, so we cannot restore it
            return;
        }
        try {
            this.driverLog.print(`Cache file for homeId ${(0, shared_1.num2hex)(this.controller.homeId)} found, attempting to restore the network from cache...`);
            await this.controller.deserialize();
            this.driverLog.print(`Restoring the network from cache was successful!`);
        }
        catch (e) {
            const message = `Restoring the network from cache failed: ${(0, shared_1.getErrorMessage)(e, true)}`;
            this.emit("error", new core_1.ZWaveError(message, core_1.ZWaveErrorCodes.Driver_InvalidCache));
            this.driverLog.print(message, "error");
        }
    }
    sendNodeToSleepTimers = new Map();
    /**
     * @internal
     * Marks a node for a later sleep command. Every call refreshes the period until the node actually goes to sleep
     */
    debounceSendNodeToSleep(node) {
        // TODO: This should be a single command to the send thread
        // Delete old timers if any exist
        if (this.sendNodeToSleepTimers.has(node.id)) {
            clearTimeout(this.sendNodeToSleepTimers.get(node.id));
        }
        // Sends a node to sleep if it has no more messages.
        const sendNodeToSleep = (node) => {
            this.sendNodeToSleepTimers.delete(node.id);
            if (!this.hasPendingMessages(node)) {
                void node.sendNoMoreInformation().catch(() => {
                    /* ignore errors */
                });
            }
        };
        // If a sleeping node has no messages pending (and supports the Wake Up CC), we may send it back to sleep
        if (node.supportsCC(core_1.CommandClasses["Wake Up"])
            && !this.hasPendingMessages(node)) {
            const wakeUpInterval = node.getValue(cc_1.WakeUpCCValues.wakeUpInterval.id);
            // GH#2179: when a device only wakes up manually, don't send it back to sleep
            // Best case, the user wanted to interact with it.
            // Worst case, the device won't ACK this and cause a delay
            if (wakeUpInterval !== 0) {
                this.sendNodeToSleepTimers.set(node.id, setTimeout(() => sendNodeToSleep(node), this.options.timeouts.sendToSleep).unref());
            }
        }
    }
    /** Computes the maximum net CC payload size for the given CC or SendDataRequest */
    computeNetCCPayloadSize(commandOrMsg) {
        // Recreate the correct encapsulation structure
        let msg;
        if ((0, SendDataShared_1.isSendDataSinglecast)(commandOrMsg)) {
            msg = commandOrMsg;
        }
        else {
            const SendDataConstructor = this.getSendDataSinglecastConstructor();
            msg = new SendDataConstructor(this, { command: commandOrMsg });
        }
        msg.command = this.encapsulateCommands(msg.command);
        return msg.command.getMaxPayloadLength(msg.getMaxPayloadLength());
    }
    /** Determines time in milliseconds to wait for a report from a node */
    getReportTimeout(msg) {
        const node = this.getNodeUnsafe(msg);
        return (
        // If there's a message-specific timeout, use that
        msg.nodeUpdateTimeout
            // If the node has a compat flag to override the timeout, use that
            ?? node?.deviceConfig?.compat?.reportTimeout
            // otherwise use the driver option
            ?? this._options.timeouts.report);
    }
    /** Returns the preferred constructor to use for singlecast SendData commands */
    getSendDataSinglecastConstructor() {
        return this._controller?.isFunctionSupported(serial_1.FunctionType.SendDataBridge)
            ? SendDataBridgeMessages_1.SendDataBridgeRequest
            : SendDataMessages_1.SendDataRequest;
    }
    /** Returns the preferred constructor to use for multicast SendData commands */
    getSendDataMulticastConstructor() {
        return this._controller?.isFunctionSupported(serial_1.FunctionType.SendDataMulticastBridge)
            ? SendDataBridgeMessages_1.SendDataMulticastBridgeRequest
            : SendDataMessages_1.SendDataMulticastRequest;
    }
    // This does not all need to be printed to the console
    [util.inspect.custom]() {
        return "[Driver]";
    }
    /**
     * Checks whether there is a compatible update for the currently installed config package.
     * Returns the new version if there is an update, `undefined` otherwise.
     */
    async checkForConfigUpdates(silent = false) {
        this.ensureReady();
        try {
            if (!silent) {
                this.driverLog.print("Checking for configuration updates...");
            }
            const ret = await (0, UpdateConfig_1.checkForConfigUpdates)(this.configVersion);
            if (ret) {
                if (!silent) {
                    this.driverLog.print(`Configuration update available: ${ret}`);
                }
            }
            else {
                if (!silent) {
                    this.driverLog.print("No configuration update available...");
                }
            }
            return ret;
        }
        catch (e) {
            this.driverLog.print((0, shared_1.getErrorMessage)(e), "error");
        }
    }
    /**
     * Installs an update for the embedded configuration DB if there is a compatible one.
     * Returns `true` when an update was installed, `false` otherwise.
     *
     * **Note:** Bugfixes and changes to device configuration generally require a restart or re-interview to take effect.
     */
    async installConfigUpdate() {
        this.ensureReady();
        const newVersion = await this.checkForConfigUpdates(true);
        if (!newVersion)
            return false;
        try {
            this.driverLog.print(`Installing version ${newVersion} of configuration DB...`);
            // We have 3 variants of this.
            const extConfigDir = (0, config_1.externalConfigDir)();
            if (this.configManager.useExternalConfig && extConfigDir) {
                // 1. external config dir, leave node_modules alone
                await (0, UpdateConfig_1.installConfigUpdateInDocker)(newVersion, {
                    cacheDir: this._options.storage.cacheDir,
                    configDir: extConfigDir,
                });
            }
            else if ((0, shared_1.isDocker)()) {
                // 2. Docker, but no external config dir, extract into node_modules
                await (0, UpdateConfig_1.installConfigUpdateInDocker)(newVersion);
            }
            else {
                // 3. normal environment, use npm/yarn to install a new version of @zwave-js/config
                await (0, UpdateConfig_1.installConfigUpdate)(newVersion);
            }
        }
        catch (e) {
            this.driverLog.print((0, shared_1.getErrorMessage)(e), "error");
            return false;
        }
        this.driverLog.print(`Configuration DB updated to version ${newVersion}, activating...`);
        // Reload the config files
        await this.configManager.loadAll();
        // Now try to apply them to all known devices
        if (this._controller) {
            for (const node of this._controller.nodes.values()) {
                if (node.ready) {
                    await node["loadDeviceConfig"]();
                    // TODO: If the device config did change, expose this information
                }
            }
        }
        return true;
    }
    _enteringBootloader = false;
    _enterBootloaderPromise;
    /** @internal */
    async enterBootloader() {
        this.controllerLog.print("Entering bootloader...");
        this._enteringBootloader = true;
        try {
            // await this.controller.toggleRF(false);
            // Avoid re-transmissions etc. communicating with the bootloader
            this.rejectTransactions((_t) => true, "The controller is entering bootloader mode.");
            await this.trySoftReset();
            this.pauseSendQueue();
            // Again, just to be very sure
            this.rejectTransactions((_t) => true, "The controller is entering bootloader mode.");
            // It would be nicer to not hardcode the command here, but since we're switching stream parsers
            // mid-command - thus ignoring the ACK, we can't really use the existing communication machinery
            const promise = this.writeSerial(Buffer.from("01030027db", "hex"));
            this.serial.mode = serial_1.ZWaveSerialMode.Bootloader;
            await promise;
            // Wait if the menu shows up
            this._enterBootloaderPromise = (0, deferred_promise_1.createDeferredPromise)();
            const success = await Promise.race([
                this._enterBootloaderPromise.then(() => true),
                (0, async_1.wait)(5000, true).then(() => false),
            ]);
            if (success) {
                this.controllerLog.print("Entered bootloader");
            }
            else {
                throw new core_1.ZWaveError("Failed to enter bootloader", core_1.ZWaveErrorCodes.Controller_Timeout);
            }
        }
        finally {
            this._enteringBootloader = false;
        }
    }
    leaveBootloaderInternal() {
        const promise = this.bootloader.runApplication();
        // Reset the known serial mode. We might end up in serial or bootloader mode afterwards.
        this.serial.mode = undefined;
        this._bootloader = undefined;
        return promise;
    }
    /**
     * @internal
     * Leaves the bootloader and destroys the driver instance if desired
     */
    async leaveBootloader(destroy = false) {
        this.controllerLog.print("Leaving bootloader...");
        await this.leaveBootloaderInternal();
        // TODO: do we need to wait here?
        if (destroy) {
            const restartReason = "Restarting driver after OTW update...";
            this.controllerLog.print(restartReason);
            await this.destroy();
            // Let the async calling context finish before emitting the error
            process.nextTick(() => {
                this.emit("error", new core_1.ZWaveError(restartReason, core_1.ZWaveErrorCodes.Driver_Failed));
            });
        }
        else {
            this.unpauseSendQueue();
            await this.ensureSerialAPI();
        }
    }
    serialport_onBootloaderData(data) {
        switch (data.type) {
            case serial_1.BootloaderChunkType.Message: {
                this.controllerLog.print(`[BOOTLOADER] ${data.message}`, "verbose");
                break;
            }
            case serial_1.BootloaderChunkType.FlowControl: {
                if (data.command === serial_1.XModemMessageHeaders.C) {
                    this.controllerLog.print(`[BOOTLOADER] awaiting input...`, "verbose");
                }
                break;
            }
        }
        // Check if there is a handler waiting for this chunk
        for (const entry of this.awaitedBootloaderChunks) {
            if (entry.predicate(data)) {
                // there is!
                entry.handler(data);
                return;
            }
        }
        if (!this._bootloader && data.type === serial_1.BootloaderChunkType.Menu) {
            // We just entered the bootloader
            this.controllerLog.print(`[BOOTLOADER] version ${data.version}`, "verbose");
            this._bootloader = new Bootloader_1.Bootloader(this.writeSerial.bind(this), data.version, data.options);
            if (this._enterBootloaderPromise) {
                this._enterBootloaderPromise.resolve();
                this._enterBootloaderPromise = undefined;
            }
        }
    }
    /**
     * Waits until a specific chunk is received from the bootloader or a timeout has elapsed. Returns the received chunk.
     * @param timeout The number of milliseconds to wait. If the timeout elapses, the returned promise will be rejected
     * @param predicate A predicate function to test all incoming chunks
     */
    waitForBootloaderChunk(predicate, timeout) {
        return new Promise((resolve, reject) => {
            const promise = (0, deferred_promise_1.createDeferredPromise)();
            const entry = {
                predicate,
                handler: (chunk) => promise.resolve(chunk),
                timeout: undefined,
            };
            this.awaitedBootloaderChunks.push(entry);
            const removeEntry = () => {
                if (entry.timeout)
                    clearTimeout(entry.timeout);
                const index = this.awaitedBootloaderChunks.indexOf(entry);
                if (index !== -1)
                    this.awaitedBootloaderChunks.splice(index, 1);
            };
            // When the timeout elapses, remove the wait entry and reject the returned Promise
            entry.timeout = setTimeout(() => {
                removeEntry();
                reject(new core_1.ZWaveError(`Received no matching chunk within the provided timeout!`, core_1.ZWaveErrorCodes.Controller_Timeout));
            }, timeout);
            // When the promise is resolved, remove the wait entry and resolve the returned Promise
            void promise.then((chunk) => {
                removeEntry();
                resolve(chunk);
            });
        });
    }
    pollBackgroundRSSITimer;
    lastBackgroundRSSITimestamp = 0;
    handleQueueIdleChange(idle) {
        if (!this.ready)
            return;
        if (this.controller.isFunctionSupported(serial_1.FunctionType.GetBackgroundRSSI)) {
            // When the send thread stays idle for 5 seconds, poll the background RSSI, but at most every 30s
            if (idle) {
                const timeout = Math.max(
                // Wait at least 5s
                5000, 
                // and up to 30s if we recently queried the RSSI
                30000 - (Date.now() - this.lastBackgroundRSSITimestamp));
                this.pollBackgroundRSSITimer = setTimeout(async () => {
                    // Due to the timeout, the driver might have been destroyed in the meantime
                    if (!this.ready)
                        return;
                    this.lastBackgroundRSSITimestamp = Date.now();
                    try {
                        await this.controller.getBackgroundRSSI();
                    }
                    catch {
                        // ignore errors
                    }
                }, timeout).unref();
            }
            else {
                clearTimeout(this.pollBackgroundRSSITimer);
                this.pollBackgroundRSSITimer = undefined;
            }
        }
    }
}
exports.Driver = Driver;
//# sourceMappingURL=Driver.js.map