/// <reference types="node" />
import type { Message } from "@zwave-js/serial";
import { type InterpreterFrom, type MachineConfig, type MachineOptions, type StateMachine } from "xstate";
import type { ZWaveOptions } from "./ZWaveOptions";
export interface SerialAPICommandStateSchema {
    states: {
        sending: {};
        waitForACK: {};
        waitForResponse: {};
        waitForCallback: {};
        retry: {};
        retryWait: {};
        failure: {};
        success: {};
    };
}
export type SerialAPICommandError = "send failure" | "CAN" | "NAK" | "ACK timeout" | "response timeout" | "callback timeout" | "response NOK" | "callback NOK";
export interface SerialAPICommandContext {
    msg: Message;
    data: Buffer;
    attempts: number;
    maxAttempts: number;
    lastError?: SerialAPICommandError;
    result?: Message;
    txTimestamp?: number;
}
export type SerialAPICommandEvent = {
    type: "ACK";
} | {
    type: "CAN";
} | {
    type: "NAK";
} | {
    type: "message";
    message: Message;
} | {
    type: "response";
    message: Message;
} | {
    type: "callback";
    message: Message;
};
export type SerialAPICommandDoneData = {
    type: "success";
    txTimestamp: number;
    result?: Message;
} | ({
    type: "failure";
} & ({
    reason: "send failure" | "CAN" | "NAK" | "ACK timeout" | "response timeout" | "callback timeout";
    result?: undefined;
} | {
    reason: "response NOK" | "callback NOK";
    result: Message;
}));
export interface SerialAPICommandServiceImplementations {
    timestamp: () => number;
    sendData: (data: Buffer) => Promise<void>;
    sendDataAbort: () => Promise<void>;
    notifyRetry: (lastError: SerialAPICommandError | undefined, message: Message, attempts: number, maxAttempts: number, delay: number) => void;
    notifyUnsolicited: (message: Message) => void;
    logOutgoingMessage: (message: Message) => void;
}
export type SerialAPICommandMachineConfig = MachineConfig<SerialAPICommandContext, SerialAPICommandStateSchema, SerialAPICommandEvent>;
export type SerialAPICommandMachine = StateMachine<SerialAPICommandContext, SerialAPICommandStateSchema, SerialAPICommandEvent>;
export type SerialAPICommandInterpreter = InterpreterFrom<SerialAPICommandMachine>;
export type SerialAPICommandMachineOptions = Partial<MachineOptions<SerialAPICommandContext, SerialAPICommandEvent>>;
export type SerialAPICommandMachineParams = {
    timeouts: Pick<ZWaveOptions["timeouts"], "ack" | "response" | "sendDataAbort" | "sendDataCallback">;
    attempts: Pick<ZWaveOptions["attempts"], "controller">;
};
export declare function getSerialAPICommandMachineConfig(message: Message, { timestamp, logOutgoingMessage, notifyUnsolicited, sendDataAbort, }: Pick<SerialAPICommandServiceImplementations, "timestamp" | "logOutgoingMessage" | "notifyUnsolicited" | "sendDataAbort">, attemptsConfig: SerialAPICommandMachineParams["attempts"]): SerialAPICommandMachineConfig;
export declare function getSerialAPICommandMachineOptions({ sendData, notifyRetry, }: Pick<SerialAPICommandServiceImplementations, "sendData" | "sendDataAbort" | "notifyRetry">, timeoutConfig: SerialAPICommandMachineParams["timeouts"]): SerialAPICommandMachineOptions;
export declare function createSerialAPICommandMachine(message: Message, implementations: SerialAPICommandServiceImplementations, params: SerialAPICommandMachineParams): SerialAPICommandMachine;
//# sourceMappingURL=SerialAPICommandMachine.d.ts.map